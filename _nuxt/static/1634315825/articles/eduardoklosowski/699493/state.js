window.__NUXT__=(function(a,b,c,d,e){return {staticAssetsBase:"\u002F_nuxt\u002Fstatic\u002F1634315825",layout:"default",error:a,state:{currentArticle:{type_of:"article",id:699493,title:"Álgebra booliana",description:"Há algum tempo, quando a bug_elseif ainda estava fazendo listas de exercícios em Python, apareceu um...",readable_publish_date:"May 16",slug:"algebra-booliana-20lc",path:"\u002Facaverna\u002Falgebra-booliana-20lc",url:"https:\u002F\u002Fdev.to\u002Facaverna\u002Falgebra-booliana-20lc",comments_count:2,public_reactions_count:b,collection_id:a,published_timestamp:c,positive_reactions_count:b,cover_image:a,social_image:"https:\u002F\u002Fdev.to\u002Fsocial_previews\u002Farticle\u002F699493.png",canonical_url:"https:\u002F\u002Feduardoklosowski.github.io\u002Fblog\u002Falgebra-booliana\u002F",created_at:"2021-05-16T01:44:01Z",edited_at:a,crossposted_at:a,published_at:c,last_comment_at:"2021-05-24T03:06:53Z",reading_time_minutes:4,tag_list:"math, braziliandevs",tags:["math","braziliandevs"],body_html:"\u003Cp\u003EHá algum tempo, quando a \u003Ca href=\"https:\u002F\u002Fwww.twitch.tv\u002Fbug_elseif\"\u003Ebug_elseif\u003C\u002Fa\u003E ainda estava fazendo \u003Ca href=\"https:\u002F\u002Fwiki.python.org.br\u002FListaDeExercicios\"\u003Elistas de exercícios em Python\u003C\u002Fa\u003E, apareceu um problema que envolvia verificar se um ano era bissexto ou não. Embora a construção de uma expressão para verificar se um ano é bissexto seja até intuitiva, como estávamos utilizando a condição invertida (verificar se o ano não era bissexto), sua construção não estava sendo fácil, porém é possível usar um pouco de matemática para chegar nela.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"constru%C3%A7%C3%A3o-da-express%C3%A3o\" href=\"#constru%C3%A7%C3%A3o-da-express%C3%A3o\"\u003E\n  \u003C\u002Fa\u003E\n  Construção da expressão\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EPrimeiramente vamos construir uma expressão para verificar se um ano é bissexto. Para isso, ele deve ser múltiplo de 4, porém se o ano terminar com 00, ele também deve ser múltiplo de 400. Para verificar se um número termina com 00, basta verificar se ele é múltiplo de 100, e para verificar se um número é múltiplo de outro, podemos verificar o resto da divisão ou módulo (quem sabe falo sobre matemática modular em outro artigo), caso o resultado dessa operação seja 0, o primeiro número é divisível pelo segundo, e caso seja qualquer outro valor, o primeiro número não é divisível pelo segundo (ou não possui uma divisão inteira).\u003C\u002Fp\u003E\n\n\u003Cp\u003EAssim, a expressão para verificar se o ano é bissexto pode ser construída como:\u003Cbr\u003E\n\u003C\u002Fp\u003E\n\n\u003Cdiv class=\"highlight js-code-highlight\"\u003E\n\u003Cpre class=\"highlight plaintext\"\u003E\u003Ccode\u003E(ano % 4 == 0 &amp;&amp; ano % 100 != 0) || ano % 400 == 0\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cdiv class=\"highlight__panel js-actions-panel\"\u003E\n\u003Cdiv class=\"highlight__panel-action js-fullscreen-code-action\"\u003E\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"\u003E\u003Ctitle\u003EEnter fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"\u003E\u003Ctitle\u003EExit fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\n\n\n\u003Cp\u003EA primeira coisa a ser observada é que existem duas subexpressões com o conectivo disjuntivo (\"ou\" \u003Ccode\u003E||\u003C\u002Fcode\u003E), ou seja, para um ano ser bissexto basta ele cumprir uma das duas condições (subexpressões). A primeira condição também é dividida em outras duas subexpressões, porém dessa vez com o conectivo conjuntivo (\"e\" \u003Ccode\u003E&amp;&amp;\u003C\u002Fcode\u003E), assim é necessário que as duas condições sejam verdadeiras para que o seu valor seja considerado verdadeiro, onde a primeira verifica se o ano é divisível por 4 (resto da divisão é igual a 0), e a segunda verifica se ele não é divisível por 100 (resto da divisão é diferente de 0). Essa é a primeira possibilidade para um ano ser bissexto. A outra possibilidade é se ele for divisível por 400 (resto da divisão é igual a zero).\u003C\u002Fp\u003E\n\n\u003Cp\u003EAssim, essa expressão retorna verdadeiro se o ano for bissexto, e falso caso ele não for.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"invertendo-a-express%C3%A3o\" href=\"#invertendo-a-express%C3%A3o\"\u003E\n  \u003C\u002Fa\u003E\n  Invertendo a expressão\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EPorém na ocasião, a expressão que estávamos usando deveria retornar verdadeiro caso o ano não fosse bissexto, e falso caso ele fosse bissexto (o contrário da expressão apresentada). Isso poderia ser feito negando a expressão anterior, ou escrevendo uma expressão de tal forma que retorne o oposto, e era justamente essa segunda opção que estávamos tentando fazer.\u003C\u002Fp\u003E\n\n\u003Cp\u003EEntretanto, existe uma forma matemática de trabalhar com a negação da expressão, alteando-a até que ela chegue próximo ou a exata expressão que estávamos construindo. Isso é possível através de propriedades das operações boolianas, substituindo parte da expressão a cada vez que uma propriedade por aplicada. Sendo as mais comuns para esse tipo de operação as propriedades de negação da negação (\u003Ccode\u003E!!a = a\u003C\u002Fcode\u003E), distributiva (\u003Ccode\u003Ea || (b &amp;&amp; c) = (a || b) &amp;&amp; (a || c)\u003C\u002Fcode\u003E e \u003Ccode\u003Ea &amp;&amp; (b || c) = (a &amp;&amp; b) || (a &amp;&amp; c)\u003C\u002Fcode\u003E, que lembra a distributiva da matemática \u003Ccode\u003E2 * (3 + 4) = (2 * 3) + (2 * 4)\u003C\u002Fcode\u003E), e as leis de De Morgan (\u003Ccode\u003E!(a || b) = !a &amp;&amp; !b\u003C\u002Fcode\u003E e \u003Ccode\u003E!(a &amp;&amp; b) = !a || !b\u003C\u002Fcode\u003E). Para mais propriedades veja a página sobre o assunto na \u003Ca href=\"https:\u002F\u002Fpt.wikipedia.org\u002Fwiki\u002F%C3%81lgebra_booliana\"\u003EWikipédia\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\n\u003Cp\u003EPara esse caso é necessário aplicar apenas as leis de De Morgan. Partindo da negação da expressão, aplicando-a passo a passo, temos:\u003Cbr\u003E\n\u003C\u002Fp\u003E\n\n\u003Cdiv class=\"highlight js-code-highlight\"\u003E\n\u003Cpre class=\"highlight plaintext\"\u003E\u003Ccode\u003E!((ano % 4 == 0 &amp;&amp; ano % 100 != 0) || ano % 400 == 0)\n!(ano % 4 == 0 &amp;&amp; ano % 100 != 0) &amp;&amp; !(ano % 400 == 0)\n(!(ano % 4 == 0) || !(ano % 100 != 0)) &amp;&amp; !(ano % 400 == 0)\n(ano % 4 != 0 || ano % 100 == 0) &amp;&amp; ano % 400 != 0\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cdiv class=\"highlight__panel js-actions-panel\"\u003E\n\u003Cdiv class=\"highlight__panel-action js-fullscreen-code-action\"\u003E\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"\u003E\u003Ctitle\u003EEnter fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"\u003E\u003Ctitle\u003EExit fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\n\n\n\u003Cp\u003EOnde essa última expressão é a que precisávamos para o código.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"considera%C3%A7%C3%B5es\" href=\"#considera%C3%A7%C3%B5es\"\u003E\n  \u003C\u002Fa\u003E\n  Considerações\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EÁlgebra booliana é interessante para trabalhar condições como de \u003Ccode\u003Eif\u003C\u002Fcode\u003E e laços de repetições dos códigos, seja para otimizá-la ou inverter os blocos de código do \u003Ccode\u003Eif\u003C\u002Fcode\u003E e \u003Ccode\u003Eelse\u003C\u002Fcode\u003E, por exemplo, o que pode ser utilizado para deixar o código mais fácil de entender, colocando os blocos de código em uma ordem que faça mais sentido para a leitura. Ela também pode ser utilizada para facilitar a construção de expressões, como no caso apresentando, onde é muito mais fácil e intuitivo escrever uma expressão que verifica se o ano é bissexto do que um ano que não é, onde essa última pode até ser contraintuitiva, onde a álgebra booliana permite partir da expressão mais fácil para a mais difícil.\u003C\u002Fp\u003E\n\n\u003Cp\u003EE para quem quiser se aprofundar nesse assunto, recomendo as \u003Ca href=\"https:\u002F\u002Fwww.youtube.com\u002Fplaylist?list=PL8iUCCJD339ezAJWqFaKriz_9tyBw6hE-\"\u003Eaulas do RiverFount\u003C\u002Fa\u003E, que é professor de filosofia.\u003C\u002Fp\u003E\n\n",body_markdown:"Há algum tempo, quando a [bug_elseif](https:\u002F\u002Fwww.twitch.tv\u002Fbug_elseif) ainda estava fazendo [listas de exercícios em Python](https:\u002F\u002Fwiki.python.org.br\u002FListaDeExercicios), apareceu um problema que envolvia verificar se um ano era bissexto ou não. Embora a construção de uma expressão para verificar se um ano é bissexto seja até intuitiva, como estávamos utilizando a condição invertida (verificar se o ano não era bissexto), sua construção não estava sendo fácil, porém é possível usar um pouco de matemática para chegar nela.\n\n## Construção da expressão\n\nPrimeiramente vamos construir uma expressão para verificar se um ano é bissexto. Para isso, ele deve ser múltiplo de 4, porém se o ano terminar com 00, ele também deve ser múltiplo de 400. Para verificar se um número termina com 00, basta verificar se ele é múltiplo de 100, e para verificar se um número é múltiplo de outro, podemos verificar o resto da divisão ou módulo (quem sabe falo sobre matemática modular em outro artigo), caso o resultado dessa operação seja 0, o primeiro número é divisível pelo segundo, e caso seja qualquer outro valor, o primeiro número não é divisível pelo segundo (ou não possui uma divisão inteira).\n\nAssim, a expressão para verificar se o ano é bissexto pode ser construída como:\n\n```\n(ano % 4 == 0 && ano % 100 != 0) || ano % 400 == 0\n```\n\nA primeira coisa a ser observada é que existem duas subexpressões com o conectivo disjuntivo (\"ou\" `||`), ou seja, para um ano ser bissexto basta ele cumprir uma das duas condições (subexpressões). A primeira condição também é dividida em outras duas subexpressões, porém dessa vez com o conectivo conjuntivo (\"e\" `&&`), assim é necessário que as duas condições sejam verdadeiras para que o seu valor seja considerado verdadeiro, onde a primeira verifica se o ano é divisível por 4 (resto da divisão é igual a 0), e a segunda verifica se ele não é divisível por 100 (resto da divisão é diferente de 0). Essa é a primeira possibilidade para um ano ser bissexto. A outra possibilidade é se ele for divisível por 400 (resto da divisão é igual a zero).\n\nAssim, essa expressão retorna verdadeiro se o ano for bissexto, e falso caso ele não for.\n\n## Invertendo a expressão\n\nPorém na ocasião, a expressão que estávamos usando deveria retornar verdadeiro caso o ano não fosse bissexto, e falso caso ele fosse bissexto (o contrário da expressão apresentada). Isso poderia ser feito negando a expressão anterior, ou escrevendo uma expressão de tal forma que retorne o oposto, e era justamente essa segunda opção que estávamos tentando fazer.\n\nEntretanto, existe uma forma matemática de trabalhar com a negação da expressão, alteando-a até que ela chegue próximo ou a exata expressão que estávamos construindo. Isso é possível através de propriedades das operações boolianas, substituindo parte da expressão a cada vez que uma propriedade por aplicada. Sendo as mais comuns para esse tipo de operação as propriedades de negação da negação (`!!a = a`), distributiva (`a || (b && c) = (a || b) && (a || c)` e `a && (b || c) = (a && b) || (a && c)`, que lembra a distributiva da matemática `2 * (3 + 4) = (2 * 3) + (2 * 4)`), e as leis de De Morgan (`!(a || b) = !a && !b` e `!(a && b) = !a || !b`). Para mais propriedades veja a página sobre o assunto na [Wikipédia](https:\u002F\u002Fpt.wikipedia.org\u002Fwiki\u002FÁlgebra_booliana).\n\nPara esse caso é necessário aplicar apenas as leis de De Morgan. Partindo da negação da expressão, aplicando-a passo a passo, temos:\n\n```\n!((ano % 4 == 0 && ano % 100 != 0) || ano % 400 == 0)\n!(ano % 4 == 0 && ano % 100 != 0) && !(ano % 400 == 0)\n(!(ano % 4 == 0) || !(ano % 100 != 0)) && !(ano % 400 == 0)\n(ano % 4 != 0 || ano % 100 == 0) && ano % 400 != 0\n```\n\nOnde essa última expressão é a que precisávamos para o código.\n\n## Considerações\n\nÁlgebra booliana é interessante para trabalhar condições como de `if` e laços de repetições dos códigos, seja para otimizá-la ou inverter os blocos de código do `if` e `else`, por exemplo, o que pode ser utilizado para deixar o código mais fácil de entender, colocando os blocos de código em uma ordem que faça mais sentido para a leitura. Ela também pode ser utilizada para facilitar a construção de expressões, como no caso apresentando, onde é muito mais fácil e intuitivo escrever uma expressão que verifica se o ano é bissexto do que um ano que não é, onde essa última pode até ser contraintuitiva, onde a álgebra booliana permite partir da expressão mais fácil para a mais difícil.\n\nE para quem quiser se aprofundar nesse assunto, recomendo as [aulas do RiverFount](https:\u002F\u002Fwww.youtube.com\u002Fplaylist?list=PL8iUCCJD339ezAJWqFaKriz_9tyBw6hE-), que é professor de filosofia.",user:{name:"Eduardo Klosowski",username:d,twitter_username:"eduklosowski",github_username:d,website_url:"https:\u002F\u002Feduardoklosowski.github.io\u002Fblog\u002F",profile_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--qXyoOI7n--\u002Fc_fill,f_auto,fl_progressive,h_640,q_auto,w_640\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F479712\u002F762f3efe-cdd6-45cd-bd4d-9d266c53f6fa.png",profile_image_90:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--Lv86KcCB--\u002Fc_fill,f_auto,fl_progressive,h_90,q_auto,w_90\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F479712\u002F762f3efe-cdd6-45cd-bd4d-9d266c53f6fa.png"},organization:{name:"A Caverna do Patocórnio",username:e,slug:e,profile_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--qeJ61pfY--\u002Fc_fill,f_auto,fl_progressive,h_640,q_auto,w_640\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Forganization\u002Fprofile_image\u002F3656\u002F7a75bb14-75e6-4c22-881d-a6039c110065.png",profile_image_90:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--jvezvnsi--\u002Fc_fill,f_auto,fl_progressive,h_90,q_auto,w_90\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Forganization\u002Fprofile_image\u002F3656\u002F7a75bb14-75e6-4c22-881d-a6039c110065.png"}}},serverRendered:true,routePath:"\u002Farticles\u002Feduardoklosowski\u002F699493",config:{_app:{basePath:"\u002F",assetsPath:"\u002F_nuxt\u002F",cdnURL:a}}}}(null,10,"2021-05-16T01:46:39Z","eduardoklosowski","acaverna"));