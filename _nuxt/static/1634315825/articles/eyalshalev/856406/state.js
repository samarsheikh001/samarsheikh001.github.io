window.__NUXT__=(function(a,b,c,d){return {staticAssetsBase:"\u002F_nuxt\u002Fstatic\u002F1634315825",layout:"default",error:a,state:{currentArticle:{type_of:"article",id:856406,title:"Introducing Async Channels",description:"What?   Channels are queue-like objects (First In First Out) that their enqueue (send) and...",readable_publish_date:"Oct 9",slug:"introducing-async-channels-333n",path:"\u002Feyalshalev\u002Fintroducing-async-channels-333n",url:c,comments_count:0,public_reactions_count:d,collection_id:a,published_timestamp:b,positive_reactions_count:d,cover_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--HvYOYwv0--\u002Fc_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F2yw3a637asa9nwsh95et.jpg",social_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--DW0Oyl3H--\u002Fc_imagga_scale,f_auto,fl_progressive,h_500,q_auto,w_1000\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F2yw3a637asa9nwsh95et.jpg",canonical_url:c,created_at:"2021-10-08T12:48:33Z",edited_at:a,crossposted_at:a,published_at:b,last_comment_at:b,reading_time_minutes:1,tag_list:"javascript, library, async, channels",tags:["javascript","library","async","channels"],body_html:"\u003Ch2\u003E\n  \u003Ca name=\"what\" href=\"#what\"\u003E\n  \u003C\u002Fa\u003E\n  What?\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EChannels are queue-like objects \u003Cem\u003E(First In First Out)\u003C\u002Fem\u003E that their \u003Ccode\u003Eenqueue\u003C\u002Fcode\u003E (send) and \u003Ccode\u003Edequeue\u003C\u002Fcode\u003E (get) functions are asynchronous (\u003Ccode\u003Easync\u003C\u002Fcode\u003E). By passing them between asynchronous functions we can synchronize operations between said functions.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"why\" href=\"#why\"\u003E\n  \u003C\u002Fa\u003E\n  Why?\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003ELet's say we want to process a large chunk of data \u003Cem\u003E(simulated by a several lorem-ipsum paragraphs)\u003C\u002Fem\u003E.\u003Cbr\u003E\nSome of the processes that we want to perform on that data are fast, while other are time (and resource) consuming.\u003Cbr\u003E\nTo avoid overwhelming our infrastructure, we want to make not to send data to a process that isn't ready to accept new data. In other words, we want to implement \u003Ca href=\"https:\u002F\u002Fmedium.com\u002F@jayphelps\u002Fbackpressure-explained-the-flow-of-data-through-software-2350b3e77ce7\"\u003Eback-preasure\u003C\u002Fa\u003E.\u003Cbr\u003E\nThis is where \u003Cstrong\u003EAsync Channels\u003C\u002Fstrong\u003E come into play.\u003C\u002Fp\u003E\n\n\u003Cp\u003EWhen you \u003Ccode\u003Esend\u003C\u002Fcode\u003E (or \u003Ccode\u003Eget\u003C\u002Fcode\u003E) a message to (or from) a channel, it returns a promise.\u003Cbr\u003E\nFor \u003Ccode\u003Esend\u003C\u002Fcode\u003E requests, it will resolve if the channel has available buffer, or (if not), after a \u003Ccode\u003Eget\u003C\u002Fcode\u003E is performed on the channel.\u003Cbr\u003E\nAnd on the opposite side, a \u003Ccode\u003Eget\u003C\u002Fcode\u003E request will resolve if there is buffered message on the channel, or after a \u003Ccode\u003Esend\u003C\u002Fcode\u003E request is made.\u003C\u002Fp\u003E\n\u003Ch2\u003E\n  \u003Ca name=\"how\" href=\"#how\"\u003E\n  \u003C\u002Fa\u003E\n  How?\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EBelow is an example usage of \u003Cstrong\u003Easync_channels\u003C\u002Fstrong\u003E, where long processes are simulated by calling \u003Ccode\u003Esleep\u003C\u002Fcode\u003E (a helper function that returns a promise that is resolved after \u003Ccode\u003En\u003C\u002Fcode\u003E seconds).\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ciframe height=\"600\" src=\"https:\u002F\u002Fcodepen.io\u002FEyal-Shalev\u002Fembed\u002FxxLKjwR?height=600&amp;default-tab=js,result&amp;embed-version=2\" scrolling=\"no\" frameborder=\"no\" allowtransparency=\"true\" loading=\"lazy\" style=\"width: 100%;\"\u003E\n\u003C\u002Fiframe\u003E\n\u003C\u002Fp\u003E\n\n\n\n\u003Chr\u003E\n\u003Cbr\u003E\u003Cbr\u003E\nYou can view the documentation on \u003Ca href=\"https:\u002F\u002Feyal-shalev.github.io\u002Fasync_channels\"\u003Eeyal-shalev.github.io\u002Fasync_channels\u003C\u002Fa\u003E\u003Cbr\u003E\n\n\u003Cdiv class=\"ltag-github-readme-tag\"\u003E\n  \u003Cdiv class=\"readme-overview\"\u003E\n    \u003Ch2\u003E\n      \u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--i3JOwpme--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev.to\u002Fassets\u002Fgithub-logo-ba8488d21cd8ee1fee097b8410db9deaa41d0ca30b004c0c63de0a479114156f.svg\" alt=\"GitHub logo\" loading=\"lazy\"\u003E\n      \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FEyal-Shalev\"\u003E\n        Eyal-Shalev\n      \u003C\u002Fa\u003E \u002F \u003Ca style=\"font-weight: 600;\" href=\"https:\u002F\u002Fgithub.com\u002FEyal-Shalev\u002Fasync_channels\"\u003E\n        async_channels\n      \u003C\u002Fa\u003E\n    \u003C\u002Fh2\u003E\n    \u003Ch3\u003E\n      Inspired by Go &amp; Clojure Channels, async_channels provides channels as an asynchronous communication method between asynchronous functions.\n    \u003C\u002Fh3\u003E\n  \u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\n",body_markdown:"## What?\n\nChannels are queue-like objects _(First In First Out)_ that their `enqueue` (send) and `dequeue` (get) functions are asynchronous (`async`). By passing them between asynchronous functions we can synchronize operations between said functions.\n\n## Why?\n\nLet's say we want to process a large chunk of data _(simulated by a several lorem-ipsum paragraphs)_.\nSome of the processes that we want to perform on that data are fast, while other are time (and resource) consuming.\nTo avoid overwhelming our infrastructure, we want to make not to send data to a process that isn't ready to accept new data. In other words, we want to implement [back-preasure](https:\u002F\u002Fmedium.com\u002F@jayphelps\u002Fbackpressure-explained-the-flow-of-data-through-software-2350b3e77ce7).\nThis is where **Async Channels** come into play.\n\nWhen you `send` (or `get`) a message to (or from) a channel, it returns a promise.\nFor `send` requests, it will resolve if the channel has available buffer, or (if not), after a `get` is performed on the channel.\nAnd on the opposite side, a `get` request will resolve if there is buffered message on the channel, or after a `send` request is made.\n\n## How?\n\nBelow is an example usage of **async_channels**, where long processes are simulated by calling `sleep` (a helper function that returns a promise that is resolved after `n` seconds).\n\n{% codepen https:\u002F\u002Fcodepen.io\u002FEyal-Shalev\u002Fpen\u002FxxLKjwR default-tab=js,result %}\n\n\u003Chr \u002F\u003E\nYou can view the documentation on [eyal-shalev.github.io\u002Fasync_channels](https:\u002F\u002Feyal-shalev.github.io\u002Fasync_channels)\n{% github eyal-shalev\u002Fasync_channels no-readme %}",user:{name:"Eyal Shalev",username:"eyalshalev",twitter_username:a,github_username:"Eyal-Shalev",website_url:a,profile_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--gx2q3usB--\u002Fc_fill,f_auto,fl_progressive,h_640,q_auto,w_640\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F702089\u002F8814e6db-8558-4527-be59-8b83c4ab112b.jpeg",profile_image_90:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--m36qVZRb--\u002Fc_fill,f_auto,fl_progressive,h_90,q_auto,w_90\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F702089\u002F8814e6db-8558-4527-be59-8b83c4ab112b.jpeg"}}},serverRendered:true,routePath:"\u002Farticles\u002Feyalshalev\u002F856406",config:{_app:{basePath:"\u002F",assetsPath:"\u002F_nuxt\u002F",cdnURL:a}}}}(null,"2021-10-09T13:44:04Z","https:\u002F\u002Fdev.to\u002Feyalshalev\u002Fintroducing-async-channels-333n",6));