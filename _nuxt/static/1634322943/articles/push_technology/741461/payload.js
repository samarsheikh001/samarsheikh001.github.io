__NUXT_JSONP__("/articles/push_technology/741461", (function(a,b,c,d,e,f){d.type_of="article";d.id=741461;d.title="Reconnection Strategy with Diffusion and iOS Apps";d.description="When developing an iOS app with Diffusion, you need to take careful consideration of the app’s life...";d.readable_publish_date="Jun 28";d.slug="reconnection-strategy-with-diffusion-and-ios-apps-3o00";d.path="\u002Fpush_technology\u002Freconnection-strategy-with-diffusion-and-ios-apps-3o00";d.url=e;d.comments_count=0;d.public_reactions_count=f;d.collection_id=a;d.published_timestamp=b;d.positive_reactions_count=f;d.cover_image="https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--zgzOTOIO--\u002Fc_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fxmwenaaf9prv3lrs1g5s.png";d.social_image="https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--pnCF8xYh--\u002Fc_imagga_scale,f_auto,fl_progressive,h_500,q_auto,w_1000\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fxmwenaaf9prv3lrs1g5s.png";d.canonical_url=e;d.created_at=b;d.edited_at=a;d.crossposted_at=a;d.published_at=b;d.last_comment_at=b;d.reading_time_minutes=4;d.tag_list="iosapplication, ios, strategy, application";d.tags=["iosapplication","ios","strategy","application"];d.body_html="\u003Cp\u003EWhen developing an iOS app with Diffusion, you need to take careful consideration of the app’s life cycle.\u003C\u002Fp\u003E\n\n\u003Cp\u003EDiffusion is designed to maintain a persistent connection to your client apps. In a mobile environment, the app can be backgrounded at any time, meaning that the app will need to reconnect to the server when it is restored. In this post, we’ll explore the default reconnection behavior, and then explain how you can use a custom reconnection strategy tailored to the needs of your particular app.\u003C\u002Fp\u003E\n\n\u003Cp\u003EConsider an iOS client app which connects to the Diffusion server, creates a session, and subscribes to a set of topics.\u003C\u002Fp\u003E\n\n\u003Cp\u003EIf the user switches to another app or locks the device, the Diffusion client app is placed in the background, triggering the delegate handler applicationDidEnterBackground: at the AppDelegate level. While the app is in the background, it cannot send or receive any messages from the Diffusion server.\u003C\u002Fp\u003E\n\n\u003Cp\u003EThe Diffusion server pings connected clients regularly to check they are still connected (by default, every 90 seconds; this can be configured using the system-ping-frequency property in Connectors.xml). The server determines that a connection should be closed if it pings a client and fails to receive a reply for two pings in a row.\u003C\u002Fp\u003E\n\n\u003Cp\u003EHowever, the server will keep the session alive and available for reconnection in a DISCONNECTED state for some time before it is closed permanently. By default this is 300 seconds, and can be configured with the keep-alive value in Connectors.xml.\u003C\u002Fp\u003E\n\n\u003Cp\u003EWhile the app is in the background, iOS can terminate the app at any point.\u003C\u002Fp\u003E\n\n\u003Cp\u003EIf the app is resumed by the user, the delegate handler applicationDidBecomeActive: is called.\u003Cbr\u003E\nIn this handler, the state and validity of the session need to be checked. For example:\u003C\u002Fp\u003E\n\n\u003Cp\u003E-(void)testConnectionWithServer {\u003Cbr\u003E\n    if (self.session) {\u003Cbr\u003E\n        [self.session.pings pingServerWithCompletionHandler:^(PTDiffusionPingDetails * _Nullable details, NSError * _Nullable error) {\u003Cbr\u003E\n            if (error) {\u003Cbr\u003E\n                \u002F\u002F only goes here after attempting all possible solutions in the reconnection strategy\u003C\u002Fp\u003E\n\n\u003Cdiv class=\"highlight js-code-highlight\"\u003E\n\u003Cpre class=\"highlight plaintext\"\u003E\u003Ccode\u003E            if ([error.domain isEqualToString:PTDiffusionSessionErrorDomain]) {\n                [self.session close];\n                self.session = nil;\n                [self connectToURL:self-&gt;_url withCompletionHandler:nil];\n            }\n        } else {\n            NSLog(@\"Ping successful (%dms)\", (int) round(details.roundTripTime * 1000));\n        }\n    }];\n} else {\n    NSLog(No session detected. Aborting\");\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cdiv class=\"highlight__panel js-actions-panel\"\u003E\n\u003Cdiv class=\"highlight__panel-action js-fullscreen-code-action\"\u003E\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"\u003E\u003Ctitle\u003EEnter fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"\u003E\u003Ctitle\u003EExit fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\n\u003Cp\u003E}\u003Cbr\u003E\nWhen the app becomes active, it checks if a session has been stored in the self.session variable. If so, the app will ping the server.\u003C\u002Fp\u003E\n\n\u003Cp\u003EDuring the ping call, if the client cannot connect to the server, the client session will enter RECOVERING_CONNECT state, and the client’s reconnection strategy will come into action.\u003C\u002Fp\u003E\n\n\u003Cp\u003EBy default, Diffusion clients follow a simple reconnection strategy, which is just to try to reconnect at 5 second intervals for 60 seconds.\u003C\u002Fp\u003E\n\n\u003Cp\u003EThis default reconnection strategy is not always suitable for every application. For example, you may prefer to attempt the first reconnection immediately rather than waiting 5 seconds. You may also wish to have increasing delays between connection attempts to avoid overloading the server if a lot of clients are trying to reconnect at once (for example, if the server has just restarted).\u003C\u002Fp\u003E\n\n\u003Cp\u003EWe can define a custom reconnection strategy for a particular session via the PTDiffusionMutableSessionConfiguration, passing it as a parameter when opening a new session with openWithURL:configuration:completionHandler:.\u003C\u002Fp\u003E\n\n\u003Cp\u003EThe chosen reconnection strategy for this example is a back-off reconnection strategy, where clients will try to reconnect immediately, but then have an increasing delay between later attempts.\u003C\u002Fp\u003E\n\n\u003Cp\u003ETo implement this, we create a new class that conforms to the PTDiffusionSessionReconnectionStrategy protocol:\u003C\u002Fp\u003E\n\n\u003Cp\u003E@interface BackOffReconnectionStrategy: NSObject\u003Cbr\u003E\nThen we need to implement the procedure diffusionSession:wishesToReconnectWithAttempt::\u003C\u002Fp\u003E\n\n\u003Cp\u003E-(void)diffusionSession:(PTDiffusionSession *)session wishesToReconnectWithAttempt:(PTDiffusionSessionReconnectionAttempt *)attempt {\u003Cbr\u003E\n    \u002F\u002F calculate the delay based on the amount of attempts while reconnecting to the server\u003Cbr\u003E\n    NSTimeInterval delay = MIN(_currentAttempt * _delayIncrementation, _maxDelay);\u003C\u002Fp\u003E\n\n\u003Cdiv class=\"highlight js-code-highlight\"\u003E\n\u003Cpre class=\"highlight plaintext\"\u003E\u003Ccode\u003E_currentAttempt += 1;\n\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n    [attempt start];\n});\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cdiv class=\"highlight__panel js-actions-panel\"\u003E\n\u003Cdiv class=\"highlight__panel-action js-fullscreen-code-action\"\u003E\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"\u003E\u003Ctitle\u003EEnter fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"\u003E\u003Ctitle\u003EExit fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\n\u003Cp\u003E}\u003Cbr\u003E\nThis is a simple reconnection strategy which attempts to reconnect immediately then increments the delay between attempts by one second (determined by _delayIncrementation), up to a maximum of 5 seconds (determined by _maxDelay).\u003C\u002Fp\u003E\n\n\u003Cp\u003EHowever, once the app has reconnected to the server using this reconnection strategy, the _currentAttempt variable is not cleared so the lingering _currentAttempt value will increase the delay for the following reconnection attempt.\u003C\u002Fp\u003E\n\n\u003Cp\u003ETo solve this, we need to create a control variable that determines when the last reconnection attempt was made:\u003C\u002Fp\u003E\n\n\u003Cp\u003E-(void)diffusionSession:(PTDiffusionSession *)session wishesToReconnectWithAttempt:(PTDiffusionSessionReconnectionAttempt *)attempt {\u003Cbr\u003E\n    \u002F\u002F calculate the delay based on the amount of attempts while reconnecting to the server\u003Cbr\u003E\n    NSTimeInterval delay = MIN(_currentAttempt * _delayIncrementation, _maxDelay);\u003C\u002Fp\u003E\n\n\u003Cdiv class=\"highlight js-code-highlight\"\u003E\n\u003Cpre class=\"highlight plaintext\"\u003E\u003Ccode\u003E\u002F\u002F if a connection attempt was made in the past of this session, _lastConnectionAttempt has a value set)\nif (_lastConnectionAttempt) {\n    NSTimeInterval elapsedSinceLastConnection = [[NSDate date] timeIntervalSinceDate:_lastConnectionAttempt];\n\n    if (elapsedSinceLastConnection &gt; delay * 2) {\n        _currentAttempt = 0;\n        delay = MIN(_currentAttempt * _delayIncrementation, _maxDelay);\n    }\n}\n_lastConnectionAttempt = [NSDate date];\n_currentAttempt += 1;\n\ndispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n    [attempt start];\n});\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cdiv class=\"highlight__panel js-actions-panel\"\u003E\n\u003Cdiv class=\"highlight__panel-action js-fullscreen-code-action\"\u003E\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"\u003E\u003Ctitle\u003EEnter fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"\u003E\u003Ctitle\u003EExit fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\n\u003Cp\u003E}\u003Cbr\u003E\nThis way, if the time elapsed from the last reconnection attempt is longer than twice the last applied delay, it is considered that the last attempt was successful, resetting the _currentAttempt value, and enabling an immediate reconnection attempt.\u003C\u002Fp\u003E\n\n\u003Cp\u003EYou should pick the values used to determine when to reset _currentAttempt based on the details of your custom reconnection strategy.\u003C\u002Fp\u003E\n\n\u003Cp\u003EOriginally Published on: \u003Ca href=\"https:\u002F\u002Fbit.ly\u002F3qzsLp5\"\u003Ehttps:\u002F\u002Fbit.ly\u002F3qzsLp5\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n";d.body_markdown="When developing an iOS app with Diffusion, you need to take careful consideration of the app’s life cycle.\n\nDiffusion is designed to maintain a persistent connection to your client apps. In a mobile environment, the app can be backgrounded at any time, meaning that the app will need to reconnect to the server when it is restored. In this post, we’ll explore the default reconnection behavior, and then explain how you can use a custom reconnection strategy tailored to the needs of your particular app.\n\nConsider an iOS client app which connects to the Diffusion server, creates a session, and subscribes to a set of topics.\n\nIf the user switches to another app or locks the device, the Diffusion client app is placed in the background, triggering the delegate handler applicationDidEnterBackground: at the AppDelegate level. While the app is in the background, it cannot send or receive any messages from the Diffusion server.\n\nThe Diffusion server pings connected clients regularly to check they are still connected (by default, every 90 seconds; this can be configured using the system-ping-frequency property in Connectors.xml). The server determines that a connection should be closed if it pings a client and fails to receive a reply for two pings in a row.\n\nHowever, the server will keep the session alive and available for reconnection in a DISCONNECTED state for some time before it is closed permanently. By default this is 300 seconds, and can be configured with the keep-alive value in Connectors.xml.\n\n\n\nWhile the app is in the background, iOS can terminate the app at any point.\n\nIf the app is resumed by the user, the delegate handler applicationDidBecomeActive: is called.\nIn this handler, the state and validity of the session need to be checked. For example:\n\n-(void)testConnectionWithServer {\n    if (self.session) {\n        [self.session.pings pingServerWithCompletionHandler:^(PTDiffusionPingDetails * _Nullable details, NSError * _Nullable error) {\n            if (error) {\n                \u002F\u002F only goes here after attempting all possible solutions in the reconnection strategy\n                \n                if ([error.domain isEqualToString:PTDiffusionSessionErrorDomain]) {\n                    [self.session close];\n                    self.session = nil;\n                    [self connectToURL:self-\u003E_url withCompletionHandler:nil];\n                }\n            } else {\n                NSLog(@\"Ping successful (%dms)\", (int) round(details.roundTripTime * 1000));\n            }\n        }];\n    } else {\n        NSLog(No session detected. Aborting\");\n    }\n}\nWhen the app becomes active, it checks if a session has been stored in the self.session variable. If so, the app will ping the server.\n\nDuring the ping call, if the client cannot connect to the server, the client session will enter RECOVERING_CONNECT state, and the client’s reconnection strategy will come into action.\n\nBy default, Diffusion clients follow a simple reconnection strategy, which is just to try to reconnect at 5 second intervals for 60 seconds.\n\n\n\nThis default reconnection strategy is not always suitable for every application. For example, you may prefer to attempt the first reconnection immediately rather than waiting 5 seconds. You may also wish to have increasing delays between connection attempts to avoid overloading the server if a lot of clients are trying to reconnect at once (for example, if the server has just restarted).\n\nWe can define a custom reconnection strategy for a particular session via the PTDiffusionMutableSessionConfiguration, passing it as a parameter when opening a new session with openWithURL:configuration:completionHandler:.\n\nThe chosen reconnection strategy for this example is a back-off reconnection strategy, where clients will try to reconnect immediately, but then have an increasing delay between later attempts.\n\nTo implement this, we create a new class that conforms to the PTDiffusionSessionReconnectionStrategy protocol:\n\n@interface BackOffReconnectionStrategy: NSObject\u003CPTDiffusionSessionReconnectionStrategy\u003E\nThen we need to implement the procedure diffusionSession:wishesToReconnectWithAttempt::\n\n-(void)diffusionSession:(PTDiffusionSession *)session wishesToReconnectWithAttempt:(PTDiffusionSessionReconnectionAttempt *)attempt {\n    \u002F\u002F calculate the delay based on the amount of attempts while reconnecting to the server\n    NSTimeInterval delay = MIN(_currentAttempt * _delayIncrementation, _maxDelay);\n  \n    _currentAttempt += 1;\n    \n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        [attempt start];\n    });\n}\nThis is a simple reconnection strategy which attempts to reconnect immediately then increments the delay between attempts by one second (determined by _delayIncrementation), up to a maximum of 5 seconds (determined by _maxDelay).\n\nHowever, once the app has reconnected to the server using this reconnection strategy, the _currentAttempt variable is not cleared so the lingering _currentAttempt value will increase the delay for the following reconnection attempt.\n\nTo solve this, we need to create a control variable that determines when the last reconnection attempt was made:\n\n-(void)diffusionSession:(PTDiffusionSession *)session wishesToReconnectWithAttempt:(PTDiffusionSessionReconnectionAttempt *)attempt {\n    \u002F\u002F calculate the delay based on the amount of attempts while reconnecting to the server\n    NSTimeInterval delay = MIN(_currentAttempt * _delayIncrementation, _maxDelay);\n    \n    \u002F\u002F if a connection attempt was made in the past of this session, _lastConnectionAttempt has a value set)\n    if (_lastConnectionAttempt) {\n        NSTimeInterval elapsedSinceLastConnection = [[NSDate date] timeIntervalSinceDate:_lastConnectionAttempt];\n        \n        if (elapsedSinceLastConnection \u003E delay * 2) {\n            _currentAttempt = 0;\n            delay = MIN(_currentAttempt * _delayIncrementation, _maxDelay);\n        }\n    }\n    _lastConnectionAttempt = [NSDate date];\n    _currentAttempt += 1;\n    \n    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{\n        [attempt start];\n    });\n}\nThis way, if the time elapsed from the last reconnection attempt is longer than twice the last applied delay, it is considered that the last attempt was successful, resetting the _currentAttempt value, and enabling an immediate reconnection attempt.\n\nYou should pick the values used to determine when to reset _currentAttempt based on the details of your custom reconnection strategy.\n\nOriginally Published on: https:\u002F\u002Fbit.ly\u002F3qzsLp5";d.user={name:c,username:c,twitter_username:c,github_username:a,website_url:"https:\u002F\u002Fwww.pushtechnology.com\u002F",profile_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs---5ZODZ7a--\u002Fc_fill,f_auto,fl_progressive,h_640,q_auto,w_640\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F589511\u002F9d38d3f8-94c6-430d-8249-566357b1b42e.png",profile_image_90:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--kX0Q0EdJ--\u002Fc_fill,f_auto,fl_progressive,h_90,q_auto,w_90\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F589511\u002F9d38d3f8-94c6-430d-8249-566357b1b42e.png"};return {data:[{}],fetch:{"data-v-25febe66:0":{article:d}},mutations:[["SET_CURRENT_ARTICLE",d]]}}(null,"2021-06-28T05:27:22Z","push_technology",{},"https:\u002F\u002Fdev.to\u002Fpush_technology\u002Freconnection-strategy-with-diffusion-and-ios-apps-3o00",1)));