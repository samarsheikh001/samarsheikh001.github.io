window.__NUXT__=(function(a,b,c,d,e){return {staticAssetsBase:"\u002F_nuxt\u002Fstatic\u002F1634322943",layout:"default",error:a,state:{currentArticle:{type_of:"article",id:574151,title:"Cleaner Flutter Vol. 2: SOLID Principles  ",description:"üí° Recommendation: Return to this article as many times as necessary to clarify the following volumes,...",readable_publish_date:"Jan 17",slug:"vol-2-solid-rules-in-dart-2e6m",path:"\u002Felianmortega\u002Fvol-2-solid-rules-in-dart-2e6m",url:c,comments_count:0,public_reactions_count:d,collection_id:a,published_timestamp:b,positive_reactions_count:d,cover_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--w9yzVdtp--\u002Fc_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fi\u002Fwpdwaeno4y2pfi1gcf96.png",social_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--_UkozRhe--\u002Fc_imagga_scale,f_auto,fl_progressive,h_500,q_auto,w_1000\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fi\u002Fwpdwaeno4y2pfi1gcf96.png",canonical_url:c,created_at:b,edited_at:"2021-01-17T15:07:18Z",crossposted_at:a,published_at:b,last_comment_at:b,reading_time_minutes:12,tag_list:"flutter, architecture, dart, clean",tags:["flutter","architecture","dart","clean"],body_html:"\u003Cp\u003Eüí° Recommendation: Return to this article as many times as necessary to clarify the following volumes, as there are concepts that complement these.\u003C\u002Fp\u003E\n\n\u003Cblockquote\u003E\n\u003Cp\u003EPrevious Volume: \u003Ca href=\"https:\u002F\u002Fdev.to\u002Fmarcossevilla\u002Fcleaner-flutter-vol-1-intro-to-clean-mo6\"\u003ECleaner Flutter Vol. 1: Intro to CLEAN\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003ENext Volume: \u003Ca href=\"https:\u002F\u002Fdev.to\u002Fmarcossevilla\u002Fcleaner-flutter-vol-3-dominating-entities-bk4\"\u003ECleaner Flutter Vol. 3: Dominating Entities\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\n\u003Cp\u003EAfter starting in the world of programming we all reach a point where we have to look back on the road and review some of the lines of code that we have written, either 1 day ago to remember an idea or years ago to review the implementation of any module of our software.\u003C\u002Fp\u003E\n\n\u003Cp\u003EMany times in these glances at the code of the past we come across a list of problems such as:\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003EHaving to search among many files for the answer to what we are looking for.\u003C\u002Fli\u003E\n\u003Cli\u003ENot understanding the code we wrote.\u003C\u002Fli\u003E\n\u003Cli\u003ENot understanding the code we write.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fi.giphy.com\u002Fmedia\u002FGPQL5xsaunjmGcVqLn\u002Fgiphy.gif\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fi.giphy.com\u002Fmedia\u002FGPQL5xsaunjmGcVqLn\u002Fgiphy.gif\" alt=\"https:\u002F\u002Fmedia.giphy.com\u002Fmedia\u002FGPQL5xsaunjmGcVqLn\u002Fgiphy.gif\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EThese problems start since we start a project because we do not spend enough time to have a clear idea not only of what we are going to do, but also of how we are going to do it.\u003C\u002Fp\u003E\n\n\u003Cp\u003EWe have to develop code imagining what would happen if I return in 2 years to review it, this ability to program clean and understandable code is essential to facilitate development, especially if you work in a team.\u003C\u002Fp\u003E\n\n\u003Ch1\u003E\n  \u003Ca name=\"what-is-solid\" href=\"#what-is-solid\"\u003E\n  \u003C\u002Fa\u003E\n  What is SOLID?\n\u003C\u002Fh1\u003E\n\n\u003Cp\u003ESOLID is the acronym for a set of principles that help us develop more maintainable code that also allows easy extension without compromising code already developed.\u003C\u002Fp\u003E\n\n\u003Cp\u003EIn other words ...\u003C\u002Fp\u003E\n\n\u003Cblockquote\u003E\n\u003Cp\u003EWrite more code without damaging what already works.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\n\u003Cp\u003EWe can even see them as a set of guidelines to follow. \u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--_I-RybtU--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fstatic.wikia.nocookie.net\u002Ffairlyoddparents\u002Fimages\u002F1\u002F1e\u002FDa_Rules.png\u002Frevision\u002Flatest%3Fcb%3D20180503070000%26path-prefix%3Den\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--_I-RybtU--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fstatic.wikia.nocookie.net\u002Ffairlyoddparents\u002Fimages\u002F1\u002F1e\u002FDa_Rules.png\u002Frevision\u002Flatest%3Fcb%3D20180503070000%26path-prefix%3Den\" alt=\"Da rules book\" width=\"60%\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003ENow we are going to explore each of the principles, which can be applied to any programming language, but I am going to cover them using Dart language since it is the language used by the Flutter framework. \u003C\u002Fp\u003E\n\n\u003Cp\u003EBefore continuing it is important to note that these were first introduced by Uncle Bob, I leave you a link in case you want to see his explanation: \u003Ca href=\"https:\u002F\u002Fwww.youtube.com\u002Fwatch?v=zHiWqnTWsn4&amp;t=1154s\"\u003ESOLID Principles Uncle Bob\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"s-single-responsibility-principle\" href=\"#s-single-responsibility-principle\"\u003E\n  \u003C\u002Fa\u003E\n  S: Single Responsibility Principle\n\u003C\u002Fh2\u003E\n\n\u003Cblockquote\u003E\n\u003Cp\u003EA class must have one, and only one, reason to change.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\n\u003Cp\u003ETo explain this principle we can imagine a messy room, as we have all had it at some point, perhaps even now that you are reading this.\u003C\u002Fp\u003E\n\n\u003Cp\u003EBut the truth is that within this, everything has its place and everything should be in its designated place.\u003Cbr\u003E\nTo put the analogy aside, this principle tells us more specifically:\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003EA class must have a unique responsibility (applies to methods, variables, entities, etc).\u003C\u002Fli\u003E\n\u003Cli\u003EThere is a place for everything and everything should be in its place.\u003C\u002Fli\u003E\n\u003Cli\u003EAll the variables and methods of the class must be aligned with the objective of the class.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003EBy following these principles, we achieve smaller and simpler classes that have unique objectives. Also we avoid giant classes with generic properties and methods that can be redundant in development.\u003C\u002Fp\u003E\n\n\u003Cp\u003ELet's see an example:\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fi.giphy.com\u002Fmedia\u002FPiQejEf31116URju4V\u002Fgiphy.gif\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fi.giphy.com\u002Fmedia\u002FPiQejEf31116URju4V\u002Fgiphy.gif\" alt=\"https:\u002F\u002Fmedia.giphy.com\u002Fmedia\u002FPiQejEf31116URju4V\u002Fgiphy.gif\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--vYMlx_pp--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fsingle_responsability1.png%3Fraw%3Dtrue\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--vYMlx_pp--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fsingle_responsability1.png%3Fraw%3Dtrue\" alt=\"https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fsingle_responsability1.png?raw=true\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003ELet's take a look at this \u003Ccode\u003EsignUp ()\u003C\u002Fcode\u003E function. This could be the method we call from our UI layer to perform the user sign-up process.\u003C\u002Fp\u003E\n\n\u003Cp\u003EIn the code we see that there is functionality of creation, validation, conversion to JSON, and even the call to the database that is normally an API call, so we are clearly not fulfilling the principle.\u003C\u002Fp\u003E\n\n\u003Cp\u003EThis is one of the most common mistakes, especially in Flutter, since developers easily make the mistake of combining different things within the same class or methods.\u003C\u002Fp\u003E\n\n\u003Cp\u003E‚ö†Ô∏è In other articles and videos we will see how this applies to Clean Architecture ....\u003C\u002Fp\u003E\n\n\u003Cp\u003EDone, I got it, now ... how do I apply it?\u003C\u002Fp\u003E\n\n\u003Cp\u003ETo follow the \u003Ccode\u003ESingle Responsibility Principle\u003C\u002Fcode\u003E correctly, we could create methods and classes with simple and unique functionalities.\u003C\u002Fp\u003E\n\n\u003Cp\u003EIn the example method \u003Ccode\u003EsignUp ()\u003C\u002Fcode\u003E many things are done with different objectives, each of these functionalities could be separated into an individual class with a single objective.\u003C\u002Fp\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"the-validation\" href=\"#the-validation\"\u003E\n  \u003C\u002Fa\u003E\n  The validation\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003EWe could implement a class that is responsible for performing the validation, there are many ways to do this, one of them can be to use \u003Ccode\u003Eformz\u003C\u002Fcode\u003E which is a Flutter package that allows us to create classes for a data type and perform a validation\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--Q9vn_ryr--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fsingle_responsability2.png%3Fraw%3Dtrue\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--Q9vn_ryr--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fsingle_responsability2.png%3Fraw%3Dtrue\" alt=\"https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fsingle_responsability2.png?raw=true\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EDo not focus too much on the logic of the code, the important thing is to understand that now the validation is decoupled from the rest of the logic with the \u003Ccode\u003Evalidator ()\u003C\u002Fcode\u003E method.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fpub.dev\u002Fpackages\u002Fformz\"\u003EHere is the link to formz in pub.dev.\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"the-connection-to-the-data-source\" href=\"#the-connection-to-the-data-source\"\u003E\n  \u003C\u002Fa\u003E\n  The connection to the data source\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003EThe other error is to call an API from the business logic or UI, this would not fulfill the principle since the connection with the API is a complex functionality by itself, so it would be best to implement a class as \u003Cstrong\u003Erepository\u003C\u002Fstrong\u003E to which we pass the parameters that we are going to send and delegate the rest of the process to it.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--2bpq6-9F--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fsingle_responsability3.png%3Fraw%3Dtrue\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--2bpq6-9F--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fsingle_responsability3.png%3Fraw%3Dtrue\" alt=\"https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fsingle_responsability3.png?raw=true\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EThis repository concept is key to meeting the \u003Cem\u003EClean Architecture\u003C\u002Fem\u003E standards but we can see that the principle of \u003Cstrong\u003ESingle Responsibility\u003C\u002Fstrong\u003E is behind this whole idea.\u003C\u002Fp\u003E\n\n\u003Cp\u003EBy implementing these classes applying the principle we would achieve a simpler method compared to how we started with:\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--jHGohaOX--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fsingle_responsability4.png%3Fraw%3Dtrue\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--jHGohaOX--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fsingle_responsability4.png%3Fraw%3Dtrue\" alt=\"https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fsingle_responsability4.png?raw=true\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003ESimpler, more maintainable and \u003Cstrong\u003Edecoupled\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"o-openedclosed-principle\" href=\"#o-openedclosed-principle\"\u003E\n  \u003C\u002Fa\u003E\n  O: Opened\u002FClosed Principle\n\u003C\u002Fh3\u003E\n\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Cem\u003EAn entity must be open to extend, but closed to modify.\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\n\u003Cp\u003EEste principio nos dice, en resumen, que debemos extender de la entidad para agregar nuevo c√≥digo en vez de modificar el existente. \u003C\u002Fp\u003E\n\n\u003Cp\u003EThis principles tell us that we must extend our classes to add new code, instead of modifying the existing one.\u003C\u002Fp\u003E\n\n\u003Cp\u003EThe first time we read this it can be a bit confusing but it just is:\u003C\u002Fp\u003E\n\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Cem\u003EDon't modify what already works, just extend and add new code.\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\n\u003Cp\u003En this way, we can develop without damaging the previously tested code. To understand this principle we can see an example provided by \u003Ca href=\"https:\u002F\u002Fwww.youtube.com\u002Fwatch?v=rtmFCcjEgEw&amp;t=735s\"\u003EKaterian Trjchevska at LaraconEU 2018\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003ELet's imagine that our app has a payment module that currently only accepts debit \u002F credit cards and PayPal as payment methods.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--XAq_IPXn--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fopen_closed1.png%3Fraw%3Dtrue\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--XAq_IPXn--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fopen_closed1.png%3Fraw%3Dtrue\" alt=\"https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fopen_closed1.png?raw=true\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EAt a first glance at the code we may think that everything is fine, but when we analyze its long term \u003Cstrong\u003Escalability\u003C\u002Fstrong\u003E, we realize the problem.\u003C\u002Fp\u003E\n\n\u003Cp\u003ELet's imagine that our client asks us to add a new payment method such as Alipay, gift cards and others.\u003C\u002Fp\u003E\n\n\u003Cp\u003EEach new payment method implies a new function and a new \u003Ccode\u003Eelse if\u003C\u002Fcode\u003E in the\u003Ccode\u003Epay ()\u003C\u002Fcode\u003Emethod and we could say that this is not a problem, but if we keep adding code within the same class, we would never achieve a stable, ready for production code.\u003C\u002Fp\u003E\n\n\u003Cp\u003EBy applying the \u003Cstrong\u003Eopen \u002F closed principle\u003C\u002Fstrong\u003E, we can create an abstract class \u003Ccode\u003EPayableInterface\u003C\u002Fcode\u003E that serves as a payment interface, in this way each of our payment methods extends this abstract class\u003Ccode\u003E[Payment Method Name] extends PayableInterface\u003C\u002Fcode\u003E and it can be a separate class that is not affected by modifications made to another.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--Vtj7Xfx7--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fopen_closed2.png%3Fraw%3Dtrue\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--Vtj7Xfx7--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fopen_closed2.png%3Fraw%3Dtrue\" alt=\"https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fopen_closed2.png?raw=true\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EAfter having our payment logic implemented, we can receive a parameter with the \u003Ccode\u003EpaymentType\u003C\u002Fcode\u003E that allows us to select the \u003Ccode\u003EPayableInterface\u003C\u002Fcode\u003E indicated for the transaction and in this way we do not have to worry about how the\u003Ccode\u003Epay ()\u003C\u002Fcode\u003Emethod makes the payment, only to make a type of filtering so that the correct instance of the interface is used; be it Card, PayPal or Alipay.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--40DhDXJ0--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fopen_closed3.png%3Fraw%3Dtrue\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--40DhDXJ0--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fopen_closed3.png%3Fraw%3Dtrue\" alt=\"https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fopen_closed3.png?raw=true\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EIn the end we would have a method like this where we can see that the code was reduced to only 3 lines and it is much easier to read.\u003C\u002Fp\u003E\n\n\u003Cp\u003EIt is also more scalable since if we wanted to add a new type of payment method we would only have to extend from \u003Ccode\u003EPayableInterface\u003C\u002Fcode\u003E and add it as an option in the filtering method.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EüëÜ I know these concepts of abstractions and instances are confusing at first but throughout this series of articles and by practice I promise they'll  become simple concepts.\u003C\u002Fstrong\u003E \u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"l-liskov-substitution-principle\" href=\"#l-liskov-substitution-principle\"\u003E\n  \u003C\u002Fa\u003E\n  L: Liskov Substitution Principle\n\u003C\u002Fh2\u003E\n\n\u003Cblockquote\u003E\n\u003Cp\u003EWe can change any concrete instance of a class with any class that implements the same interface.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\n\u003Cp\u003EThe main objective of this principle is that we should always obtain the expected behavior of the code regardless of the class instance that is being used.\u003C\u002Fp\u003E\n\n\u003Cp\u003ETo be able to fulfill this principle correctly there are 2 important parts:\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003EImplementation\u003C\u002Fli\u003E\n\u003Cli\u003EAbstraction\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003EThe first we can see in the previous example of  \u003Cstrong\u003EOpen \u002F Closed Principle\u003C\u002Fstrong\u003E when we have \u003Ccode\u003EPayableInterface\u003C\u002Fcode\u003E and the payment methods that implements it as\u003Ccode\u003ECardPayment\u003C\u002Fcode\u003E and \u003Ccode\u003EPaypalPayment\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\n\u003Cp\u003EIn the implementation of the code we see that it doesn't matter with implementation we choose, our code should continue to work correctly, this is because both make a correct implementation of the \u003Ccode\u003EPayableInterface\u003C\u002Fcode\u003E interface.\u003C\u002Fp\u003E\n\n\u003Cp\u003EWith this example the idea is easy to understand but in practice there are many times that we perform the abstraction process wrong, so we cannot truly make a great use of the principle.\u003C\u002Fp\u003E\n\n\u003Cp\u003EIf you are not very familiar with concepts such as interface, implementation, and abstraction this may sound a bit complex but let's see it with a simple example.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--90KAsCEW--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fi.stack.imgur.com\u002FilxzO.jpg\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--90KAsCEW--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fi.stack.imgur.com\u002FilxzO.jpg\" alt=\"https:\u002F\u002Fi.stack.imgur.com\u002FilxzO.jpg\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EThis is one of the iconic images of the principle as it makes it easy to understand.\u003C\u002Fp\u003E\n\n\u003Cp\u003ELet's imagine that in our code we have a class called \u003Ccode\u003EDuckInterface\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\n\u003Cp\u003EThis gives us the basic functionality of a duck like \u003Ccode\u003Efly\u003C\u002Fcode\u003E,\u003Ccode\u003Eswim\u003C\u002Fcode\u003E, \u003Ccode\u003Equack\u003C\u002Fcode\u003E and we would have the\u003Ccode\u003ERubberDuck\u003C\u002Fcode\u003E class that implements the interface.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--wgUhip8g--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fliskov_substitution1.png%3Fraw%3Dtrue\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--wgUhip8g--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fliskov_substitution1.png%3Fraw%3Dtrue\" alt=\"https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fliskov_substitution1.png?raw=true\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EAt a first glance we could say that our abstraction is fine since we are using an interface that gives us the functionality we need, but the \u003Ccode\u003Efly ()\u003C\u002Fcode\u003E method does not apply to a rubber duck,  imagine that our program is going to have different Animals with shared functionality such as flying and swimming, so it would not make sense to leave this method on the \u003Ccode\u003EDuckInterface\u003C\u002Fcode\u003E interface.\u003C\u002Fp\u003E\n\n\u003Cp\u003ETo solve this and comply with the \u003Cstrong\u003ELiskov Principle\u003C\u002Fstrong\u003E we can create more specific interfaces that allow us to reuse code, which also makes our code more maintainable.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--9xfVNZh4--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fliskov_substitution2.png%3Fraw%3Dtrue\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--9xfVNZh4--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fliskov_substitution2.png%3Fraw%3Dtrue\" alt=\"https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fliskov_substitution2.png?raw=true\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EWith this implementation, our \u003Ccode\u003ERubberDuck\u003C\u002Fcode\u003E class only implements the methods it needs and now, for example, if we need an animal that fulfills a specific function such as swimming, we could use any class that implements the\u003Ccode\u003ESwimInterface\u003C\u002Fcode\u003E interface. This is because by fulfilling the \u003Cstrong\u003ELiskov Principle\u003C\u002Fstrong\u003E we can switch any declaration of an \u003Cstrong\u003Eabstract class\u003C\u002Fstrong\u003E by any class that implements it. \u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"i-interface-segregation-principle\" href=\"#i-interface-segregation-principle\"\u003E\n  \u003C\u002Fa\u003E\n  I: Interface Segregation Principle\n\u003C\u002Fh2\u003E\n\n\u003Cblockquote\u003E\n\u003Cp\u003EThe code should not depend on methods that it does not use.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\n\u003Cp\u003EAt first this could seem to be the simplest principle but for this very reason, at the beginning, it can even confuse us.\u003C\u002Fp\u003E\n\n\u003Cp\u003EIn the previous principles we have seen the importance of using interfaces to decouple our code.\u003C\u002Fp\u003E\n\n\u003Cp\u003EThis principle ensures that our abstractions for creating interfaces are correct, since we cannot create a new instance of an interface without implementing one of the methods defined by them. The above would be violating the principle\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--6cPDk_mN--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Finnovationm.co\u002Fwp-content\u002Fuploads\u002F2017\u002F11\u002FInterfaceSegregationPrinciple.jpg\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--6cPDk_mN--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Finnovationm.co\u002Fwp-content\u002Fuploads\u002F2017\u002F11\u002FInterfaceSegregationPrinciple.jpg\" alt=\"https:\u002F\u002Finnovationm.co\u002Fwp-content\u002Fuploads\u002F2017\u002F11\u002FInterfaceSegregationPrinciple.jpg\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EThis image shows the problem of not fulfilling this principle, we have some instances of classes that do not use all the interface methods, which lead to a dirty code and indicates bad abstraction. \u003C\u002Fp\u003E\n\n\u003Cp\u003EIt is easier to see it with the typical anima example, this is very similar to the example we saw from Liskov.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Cstrong\u003Eüí° At this point the examples become similar but the important thing is to see the code from another perspective.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EWe have an abstract class \u003Ccode\u003EAnimal\u003C\u002Fcode\u003E that is our interface, it has 3 methods defined  \u003Ccode\u003Eeat ()\u003C\u002Fcode\u003E,\u003Ccode\u003Esleep ()\u003C\u002Fcode\u003E, and\u003Ccode\u003Efly ()\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\n\u003Cp\u003EIf we create a \u003Ccode\u003EBird\u003C\u002Fcode\u003E class that implements the animal interface we don't see any problem, but what if we want to create the Dog class?\u003C\u002Fp\u003E\n\n\u003Cp\u003EExactly, we realize that we cannot implement the \u003Ccode\u003Efly ()\u003C\u002Fcode\u003E method because it does not apply to a dog.\u003C\u002Fp\u003E\n\n\u003Cp\u003EWe could leave it like that and avoid the time needed to restructure the code since we logically know that this would not affect our code, but this breaks the principle.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--8YVDrPvy--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Finterface_segregation1.png%3Fraw%3Dtrue\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--8YVDrPvy--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Finterface_segregation1.png%3Fraw%3Dtrue\" alt=\"https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Finterface_segregation1.png?raw=true\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EThe mistake is made by having a bad abstraction in our class and the right thing to do is always refactor to ensure that the principles are being met.\u003C\u002Fp\u003E\n\n\u003Cp\u003EIt may take us a little longer at the moment but the results of having a clean and scalable code should always be priorities.\u003C\u002Fp\u003E\n\n\u003Cp\u003EA solution to this could be that our \u003Ccode\u003EAnimal\u003C\u002Fcode\u003E interface only has the methods shared by animals like\u003Ccode\u003Eeat (), sleep ()\u003C\u002Fcode\u003Eand we create another interface for the\u003Ccode\u003Efly ()\u003C\u002Fcode\u003Emethod. In this way, only animals that need this method implement its interface.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--waVbbqk2--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Finterface_segregation2.png%3Fraw%3Dtrue\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--waVbbqk2--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Finterface_segregation2.png%3Fraw%3Dtrue\" alt=\"https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Finterface_segregation2.png?raw=true\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Cstrong\u003Eüî• Almost there! Last SOLID principle ...\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"d-dependency-inversion-principle\" href=\"#d-dependency-inversion-principle\"\u003E\n  \u003C\u002Fa\u003E\n  D: Dependency Inversion Principle\n\u003C\u002Fh2\u003E\n\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Cem\u003EHigh-level modules should not depend on low-level modules. Both must depend on abstractions.\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\n\u003Cp\u003EIn my opinion, this should be the first principle that every developer should understand.\u003C\u002Fp\u003E\n\n\u003Cp\u003EThis principle tells us:\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003EYou never have to depend on a concrete implementation of a class, only on its abstractions (interfaces).\u003C\u002Fli\u003E\n\u003Cli\u003ESame as the image presented in \u003Ca href=\"https:\u002F\u002Fdev.to\u002Fmarcossevilla\u002Fcleaner-flutter-vol-1-intro-to-clean-mo6\"\u003EVolume 1 of this series of  A Cleaner Flutter\u003C\u002Fa\u003E we follow the rule that modules High-level modules should not strictly rely on low-level modules.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003ETo understand it more simply, let's look at the example.\u003C\u002Fp\u003E\n\n\u003Cp\u003ENowadays, every app or software that is developed needs to communicate with the outside world. Normally this is done through code repositories that we instantiate and call from the business logic in our software.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--uY1wxb3f--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fdependency_inversion1.png%3Fraw%3Dtrue\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--uY1wxb3f--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fdependency_inversion1.png%3Fraw%3Dtrue\" alt=\"https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fdependency_inversion1.png?raw=true\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EDeclaring and using a concrete class, such as the \u003Ccode\u003EDataRepository ()\u003C\u002Fcode\u003E within \u003Ccode\u003EBusinessLogic ()\u003C\u002Fcode\u003E, is a very common practice and is one of the common mistakes that makes our code not very scalable.By depending on a particular instance of a class we surely know it will never be stable because you are constantly adding code to it.\u003C\u002Fp\u003E\n\n\u003Cp\u003ETo solve this problem, the principle tells us to create an interface that communicates both modules. You can even develop a the whole functionality of the business logic and UI of an app by depending on a interface which hasn't been implemented. \u003C\u002Fp\u003E\n\n\u003Cp\u003EThis also allows better communication in a team of developers because when creating an interface, everyone is clear about the objectives of the module and from that definition, it can be verified that the SOLID principles are being met.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--ufXna4VQ--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fdependency_inversion2.png%3Fraw%3Dtrue\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--ufXna4VQ--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fdependency_inversion2.png%3Fraw%3Dtrue\" alt=\"https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fdependency_inversion2.png?raw=true\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EWith this implementation, we create a \u003Ccode\u003EDataRepositoryInterface\u003C\u002Fcode\u003E that we can then implement in\u003Ccode\u003EDataRepository\u003C\u002Fcode\u003E and the magic happens inside the class that uses this functionality when we do not depend on a concrete instance but instead on an interface  we could pass as parameters any concrete class that implements this interface.\u003C\u002Fp\u003E\n\n\u003Cp\u003EIt could be a local or external database and that would not affect the development since I repeat it again \u003Cstrong\u003Ewe do not depend on a single concrete instance, we can use any class that complies with the implementation of the interface.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EAnd this, ladies and gentlemen, is what allows us to fulfill the magic word of \u003Cstrong\u003EClean Architecture: \u003Cem\u003EDecoupling\u003C\u002Fem\u003E!\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"wrap-up-\" href=\"#wrap-up-\"\u003E\n  \u003C\u002Fa\u003E\n  Wrap up ...\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EI remind you that these are principles, not rules, so there is no single way to follow them, their use and compliance with the code will depend on each project, since for many of these the objectives of the project are key to make decisions. Just as something within the scope of a project can be considered small it may under other requirements become something large.\u003C\u002Fp\u003E\n\n\u003Cp\u003EI hope now you have a better idea of what the \u003Cstrong\u003ESOLID\u003C\u002Fstrong\u003E principles are and how to apply them. For any questions or comments you can contact me through my social media accounts and if you learned something do not hesitate to share it with your fellow developers and friends, so that as a community we continue to improve and develop high quality and scalable projects. \u003C\u002Fp\u003E\n\n\u003Cp\u003EAlso, if you liked this content, you can find even more and keep in touch with me on my social networks:\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Felian-ortega\"\u003EGitHub,\u003C\u002Fa\u003E \u003Ca href=\"https:\u002F\u002Fwww.linkedin.com\u002Fin\u002Felian-ortega\u002F\"\u003ELinkedIn\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Ftwitter.com\u002FElianOrtegaNCA\"\u003ETwitter\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fwww.youtube.com\u002Fchannel\u002FUCPz6bJ3DptMMXu7_hMb1oJQ\"\u003EYouTube\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\n",body_markdown:"\nüí° Recommendation: Return to this article as many times as necessary to clarify the following volumes, as there are concepts that complement these.\n\n\u003E Previous Volume: [Cleaner Flutter Vol. 1: Intro to CLEAN](https:\u002F\u002Fdev.to\u002Fmarcossevilla\u002Fcleaner-flutter-vol-1-intro-to-clean-mo6)\n\n\u003E Next Volume: [Cleaner Flutter Vol. 3: Dominating Entities](https:\u002F\u002Fdev.to\u002Fmarcossevilla\u002Fcleaner-flutter-vol-3-dominating-entities-bk4)\n\nAfter starting in the world of programming we all reach a point where we have to look back on the road and review some of the lines of code that we have written, either 1 day ago to remember an idea or years ago to review the implementation of any module of our software.\n\nMany times in these glances at the code of the past we come across a list of problems such as:\n\n- Having to search among many files for the answer to what we are looking for.\n- Not understanding the code we wrote.\n- Not understanding the code we write.\n\n![https:\u002F\u002Fmedia.giphy.com\u002Fmedia\u002FGPQL5xsaunjmGcVqLn\u002Fgiphy.gif](https:\u002F\u002Fmedia.giphy.com\u002Fmedia\u002FGPQL5xsaunjmGcVqLn\u002Fgiphy.gif)\n\nThese problems start since we start a project because we do not spend enough time to have a clear idea not only of what we are going to do, but also of how we are going to do it.\n\nWe have to develop code imagining what would happen if I return in 2 years to review it, this ability to program clean and understandable code is essential to facilitate development, especially if you work in a team.\n\n# What is SOLID?\n\nSOLID is the acronym for a set of principles that help us develop more maintainable code that also allows easy extension without compromising code already developed.\n\nIn other words ...\n\n\u003E Write more code without damaging what already works.\n\nWe can even see them as a set of guidelines to follow. \n\n\u003Cimg src=\"https:\u002F\u002Fstatic.wikia.nocookie.net\u002Ffairlyoddparents\u002Fimages\u002F1\u002F1e\u002FDa_Rules.png\u002Frevision\u002Flatest?cb=20180503070000&path-prefix=en\" alt=\"Da rules book\" width=\"60%\"\u002F\u003E\n\nNow we are going to explore each of the principles, which can be applied to any programming language, but I am going to cover them using Dart language since it is the language used by the Flutter framework. \n\nBefore continuing it is important to note that these were first introduced by Uncle Bob, I leave you a link in case you want to see his explanation: [SOLID Principles Uncle Bob](https:\u002F\u002Fwww.youtube.com\u002Fwatch?v=zHiWqnTWsn4&t=1154s).\n\n## S: Single Responsibility Principle\n\n\u003E A class must have one, and only one, reason to change.\n\nTo explain this principle we can imagine a messy room, as we have all had it at some point, perhaps even now that you are reading this.\n\nBut the truth is that within this, everything has its place and everything should be in its designated place.\nTo put the analogy aside, this principle tells us more specifically:\n\n- A class must have a unique responsibility (applies to methods, variables, entities, etc).\n- There is a place for everything and everything should be in its place.\n- All the variables and methods of the class must be aligned with the objective of the class.\n\nBy following these principles, we achieve smaller and simpler classes that have unique objectives. Also we avoid giant classes with generic properties and methods that can be redundant in development.\n\nLet's see an example:\n\n![https:\u002F\u002Fmedia.giphy.com\u002Fmedia\u002FPiQejEf31116URju4V\u002Fgiphy.gif](https:\u002F\u002Fmedia.giphy.com\u002Fmedia\u002FPiQejEf31116URju4V\u002Fgiphy.gif)\n\n![https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fsingle_responsability1.png?raw=true](https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fsingle_responsability1.png?raw=true)\n\nLet's take a look at this `signUp ()` function. This could be the method we call from our UI layer to perform the user sign-up process.\n\nIn the code we see that there is functionality of creation, validation, conversion to JSON, and even the call to the database that is normally an API call, so we are clearly not fulfilling the principle.\n\nThis is one of the most common mistakes, especially in Flutter, since developers easily make the mistake of combining different things within the same class or methods.\n\n‚ö†Ô∏è In other articles and videos we will see how this applies to Clean Architecture ....\n\nDone, I got it, now ... how do I apply it?\n\nTo follow the `Single Responsibility Principle` correctly, we could create methods and classes with simple and unique functionalities.\n\nIn the example method `signUp ()` many things are done with different objectives, each of these functionalities could be separated into an individual class with a single objective.\n\n### The validation\n\nWe could implement a class that is responsible for performing the validation, there are many ways to do this, one of them can be to use `formz` which is a Flutter package that allows us to create classes for a data type and perform a validation\n\n![https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fsingle_responsability2.png?raw=true](https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fsingle_responsability2.png?raw=true)\n\nDo not focus too much on the logic of the code, the important thing is to understand that now the validation is decoupled from the rest of the logic with the `validator ()` method.\n\n[Here is the link to formz in pub.dev.](https:\u002F\u002Fpub.dev\u002Fpackages\u002Fformz)\n\n### The connection to the data source\n\nThe other error is to call an API from the business logic or UI, this would not fulfill the principle since the connection with the API is a complex functionality by itself, so it would be best to implement a class as **repository** to which we pass the parameters that we are going to send and delegate the rest of the process to it.\n\n![https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fsingle_responsability3.png?raw=true](https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fsingle_responsability3.png?raw=true)\n\nThis repository concept is key to meeting the *Clean Architecture* standards but we can see that the principle of **Single Responsibility** is behind this whole idea.\n\nBy implementing these classes applying the principle we would achieve a simpler method compared to how we started with:\n\n![https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fsingle_responsability4.png?raw=true](https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fsingle_responsability4.png?raw=true)\n\nSimpler, more maintainable and **decoupled**.\n\n### O: Opened\u002FClosed Principle\n\n\u003E *An entity must be open to extend, but closed to modify.*\n\nEste principio nos dice, en resumen, que debemos extender de la entidad para agregar nuevo c√≥digo en vez de modificar el existente. \n\nThis principles tell us that we must extend our classes to add new code, instead of modifying the existing one.\n\nThe first time we read this it can be a bit confusing but it just is:\n\n\u003E *Don't modify what already works, just extend and add new code.*\n\nn this way, we can develop without damaging the previously tested code. To understand this principle we can see an example provided by [Katerian Trjchevska at LaraconEU 2018](https:\u002F\u002Fwww.youtube.com\u002Fwatch?v=rtmFCcjEgEw&t=735s)\n\nLet's imagine that our app has a payment module that currently only accepts debit \u002F credit cards and PayPal as payment methods.\n\n![https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fopen_closed1.png?raw=true](https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fopen_closed1.png?raw=true)\n\nAt a first glance at the code we may think that everything is fine, but when we analyze its long term **scalability**, we realize the problem.\n\nLet's imagine that our client asks us to add a new payment method such as Alipay, gift cards and others.\n\nEach new payment method implies a new function and a new `else if` in the`pay ()`method and we could say that this is not a problem, but if we keep adding code within the same class, we would never achieve a stable, ready for production code.\n\nBy applying the **open \u002F closed principle**, we can create an abstract class `PayableInterface` that serves as a payment interface, in this way each of our payment methods extends this abstract class`[Payment Method Name] extends PayableInterface` and it can be a separate class that is not affected by modifications made to another.\n\n![https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fopen_closed2.png?raw=true](https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fopen_closed2.png?raw=true)\n\nAfter having our payment logic implemented, we can receive a parameter with the `paymentType` that allows us to select the `PayableInterface` indicated for the transaction and in this way we do not have to worry about how the`pay ()`method makes the payment, only to make a type of filtering so that the correct instance of the interface is used; be it Card, PayPal or Alipay.\n\n![https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fopen_closed3.png?raw=true](https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fopen_closed3.png?raw=true)\n\nIn the end we would have a method like this where we can see that the code was reduced to only 3 lines and it is much easier to read.\n\nIt is also more scalable since if we wanted to add a new type of payment method we would only have to extend from `PayableInterface` and add it as an option in the filtering method.\n\n**üëÜ I know these concepts of abstractions and instances are confusing at first but throughout this series of articles and by practice I promise they'll  become simple concepts.** \n\n## L: Liskov Substitution Principle\n\n\u003E We can change any concrete instance of a class with any class that implements the same interface.\n\nThe main objective of this principle is that we should always obtain the expected behavior of the code regardless of the class instance that is being used.\n\nTo be able to fulfill this principle correctly there are 2 important parts:\n\n- Implementation\n- Abstraction\n\nThe first we can see in the previous example of  **Open \u002F Closed Principle** when we have `PayableInterface` and the payment methods that implements it as`CardPayment` and `PaypalPayment`.\n\nIn the implementation of the code we see that it doesn't matter with implementation we choose, our code should continue to work correctly, this is because both make a correct implementation of the `PayableInterface` interface.\n\nWith this example the idea is easy to understand but in practice there are many times that we perform the abstraction process wrong, so we cannot truly make a great use of the principle.\n\nIf you are not very familiar with concepts such as interface, implementation, and abstraction this may sound a bit complex but let's see it with a simple example.\n\n![https:\u002F\u002Fi.stack.imgur.com\u002FilxzO.jpg](https:\u002F\u002Fi.stack.imgur.com\u002FilxzO.jpg)\n\nThis is one of the iconic images of the principle as it makes it easy to understand.\n\nLet's imagine that in our code we have a class called `DuckInterface`.\n\nThis gives us the basic functionality of a duck like `fly`,`swim`, `quack` and we would have the`RubberDuck` class that implements the interface.\n\n![https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fliskov_substitution1.png?raw=true](https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fliskov_substitution1.png?raw=true)\n\nAt a first glance we could say that our abstraction is fine since we are using an interface that gives us the functionality we need, but the `fly ()` method does not apply to a rubber duck,  imagine that our program is going to have different Animals with shared functionality such as flying and swimming, so it would not make sense to leave this method on the `DuckInterface` interface.\n\nTo solve this and comply with the **Liskov Principle** we can create more specific interfaces that allow us to reuse code, which also makes our code more maintainable.\n\n![https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fliskov_substitution2.png?raw=true](https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fliskov_substitution2.png?raw=true)\n\nWith this implementation, our `RubberDuck` class only implements the methods it needs and now, for example, if we need an animal that fulfills a specific function such as swimming, we could use any class that implements the`SwimInterface` interface. This is because by fulfilling the **Liskov Principle** we can switch any declaration of an **abstract class** by any class that implements it. \n\n## I: Interface Segregation Principle\n\n\u003E The code should not depend on methods that it does not use.\n\nAt first this could seem to be the simplest principle but for this very reason, at the beginning, it can even confuse us.\n\nIn the previous principles we have seen the importance of using interfaces to decouple our code.\n\nThis principle ensures that our abstractions for creating interfaces are correct, since we cannot create a new instance of an interface without implementing one of the methods defined by them. The above would be violating the principle\n\n![https:\u002F\u002Finnovationm.co\u002Fwp-content\u002Fuploads\u002F2017\u002F11\u002FInterfaceSegregationPrinciple.jpg](https:\u002F\u002Finnovationm.co\u002Fwp-content\u002Fuploads\u002F2017\u002F11\u002FInterfaceSegregationPrinciple.jpg)\n\nThis image shows the problem of not fulfilling this principle, we have some instances of classes that do not use all the interface methods, which lead to a dirty code and indicates bad abstraction. \n\nIt is easier to see it with the typical anima example, this is very similar to the example we saw from Liskov.\n\n**üí° At this point the examples become similar but the important thing is to see the code from another perspective.**\n\nWe have an abstract class `Animal` that is our interface, it has 3 methods defined  `eat ()`,`sleep ()`, and`fly ()`.\n\nIf we create a `Bird` class that implements the animal interface we don't see any problem, but what if we want to create the Dog class?\n\nExactly, we realize that we cannot implement the `fly ()` method because it does not apply to a dog.\n\nWe could leave it like that and avoid the time needed to restructure the code since we logically know that this would not affect our code, but this breaks the principle.\n\n![https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Finterface_segregation1.png?raw=true](https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Finterface_segregation1.png?raw=true)\n\nThe mistake is made by having a bad abstraction in our class and the right thing to do is always refactor to ensure that the principles are being met.\n\nIt may take us a little longer at the moment but the results of having a clean and scalable code should always be priorities.\n\nA solution to this could be that our `Animal` interface only has the methods shared by animals like`eat (), sleep ()`and we create another interface for the`fly ()`method. In this way, only animals that need this method implement its interface.\n\n![https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Finterface_segregation2.png?raw=true](https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Finterface_segregation2.png?raw=true)\n\n**üî• Almost there! Last SOLID principle ...**\n\n## D: Dependency Inversion Principle\n\n\u003E *High-level modules should not depend on low-level modules. Both must depend on abstractions.*\n\nIn my opinion, this should be the first principle that every developer should understand.\n\nThis principle tells us:\n\n- You never have to depend on a concrete implementation of a class, only on its abstractions (interfaces).\n- Same as the image presented in [Volume 1 of this series of  A Cleaner Flutter](https:\u002F\u002Fdev.to\u002Fmarcossevilla\u002Fcleaner-flutter-vol-1-intro-to-clean-mo6) we follow the rule that modules High-level modules should not strictly rely on low-level modules.\n\nTo understand it more simply, let's look at the example.\n\nNowadays, every app or software that is developed needs to communicate with the outside world. Normally this is done through code repositories that we instantiate and call from the business logic in our software.\n\n![https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fdependency_inversion1.png?raw=true](https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fdependency_inversion1.png?raw=true)\n\nDeclaring and using a concrete class, such as the `DataRepository ()` within `BusinessLogic ()`, is a very common practice and is one of the common mistakes that makes our code not very scalable.By depending on a particular instance of a class we surely know it will never be stable because you are constantly adding code to it.\n\nTo solve this problem, the principle tells us to create an interface that communicates both modules. You can even develop a the whole functionality of the business logic and UI of an app by depending on a interface which hasn't been implemented. \n\nThis also allows better communication in a team of developers because when creating an interface, everyone is clear about the objectives of the module and from that definition, it can be verified that the SOLID principles are being met.\n\n![https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fdependency_inversion2.png?raw=true](https:\u002F\u002Fgithub.com\u002Felian-ortega\u002Fsolid-dart\u002Fblob\u002Fmain\u002Fassets\u002Fdependency_inversion2.png?raw=true)\n\nWith this implementation, we create a `DataRepositoryInterface` that we can then implement in`DataRepository` and the magic happens inside the class that uses this functionality when we do not depend on a concrete instance but instead on an interface  we could pass as parameters any concrete class that implements this interface.\n\nIt could be a local or external database and that would not affect the development since I repeat it again **we do not depend on a single concrete instance, we can use any class that complies with the implementation of the interface.**\n\nAnd this, ladies and gentlemen, is what allows us to fulfill the magic word of **Clean Architecture: *Decoupling*!**\n\n## Wrap up ...\n\nI remind you that these are principles, not rules, so there is no single way to follow them, their use and compliance with the code will depend on each project, since for many of these the objectives of the project are key to make decisions. Just as something within the scope of a project can be considered small it may under other requirements become something large.\n\nI hope now you have a better idea of what the **SOLID** principles are and how to apply them. For any questions or comments you can contact me through my social media accounts and if you learned something do not hesitate to share it with your fellow developers and friends, so that as a community we continue to improve and develop high quality and scalable projects. \n\nAlso, if you liked this content, you can find even more and keep in touch with me on my social networks:\n\n[GitHub,](https:\u002F\u002Fgithub.com\u002Felian-ortega) [LinkedIn](https:\u002F\u002Fwww.linkedin.com\u002Fin\u002Felian-ortega\u002F), [Twitter](https:\u002F\u002Ftwitter.com\u002FElianOrtegaNCA), [YouTube](https:\u002F\u002Fwww.youtube.com\u002Fchannel\u002FUCPz6bJ3DptMMXu7_hMb1oJQ).",user:{name:"Elian Ortega",username:e,twitter_username:a,github_username:e,website_url:a,profile_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--XyVos6G5--\u002Fc_fill,f_auto,fl_progressive,h_640,q_auto,w_640\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F405494\u002F0b88c710-5560-4066-b747-27f5102c9753.jpeg",profile_image_90:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--Iot911wL--\u002Fc_fill,f_auto,fl_progressive,h_90,q_auto,w_90\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F405494\u002F0b88c710-5560-4066-b747-27f5102c9753.jpeg"}}},serverRendered:true,routePath:"\u002Farticles\u002Felianmortega\u002F574151",config:{_app:{basePath:"\u002F",assetsPath:"\u002F_nuxt\u002F",cdnURL:a}}}}(null,"2021-01-17T15:02:01Z","https:\u002F\u002Fdev.to\u002Felianmortega\u002Fvol-2-solid-rules-in-dart-2e6m",32,"elianmortega"));