__NUXT_JSONP__("/articles/fstorz/656927", (function(a,b,c,d,e,f){c.type_of="article";c.id=656927;c.title="Automate Let's Encrypt Wildcard Certificate creation with Ionos DNS Rest API";c.description="“At the end of the day, the goals are simple: safety and security.” – Jodi Rell   The majority of pa...";c.readable_publish_date="Apr 6";c.slug="automate-let-s-encrypt-automate-let-s-encrypt-wildcard-certificate-creation-with-ionos-dns-rest-api-o23";c.path="\u002Fdevlix-blog\u002Fautomate-let-s-encrypt-automate-let-s-encrypt-wildcard-certificate-creation-with-ionos-dns-rest-api-o23";c.url="https:\u002F\u002Fdev.to\u002Fdevlix-blog\u002Fautomate-let-s-encrypt-automate-let-s-encrypt-wildcard-certificate-creation-with-ionos-dns-rest-api-o23";c.comments_count=0;c.public_reactions_count=d;c.collection_id=a;c.published_timestamp=b;c.positive_reactions_count=d;c.cover_image="https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--K9NYdR4d--\u002Fc_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fevrkch7y52k4000744fk.png";c.social_image="https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--_IyfVlLW--\u002Fc_imagga_scale,f_auto,fl_progressive,h_500,q_auto,w_1000\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fevrkch7y52k4000744fk.png";c.canonical_url="https:\u002F\u002Fwww.devlix.de\u002Flets-encrypt-wildcard-zertifikate-mit-ionos-dns-api-erzeugen\u002F";c.created_at="2021-04-06T18:06:05Z";c.edited_at="2021-04-07T06:51:13Z";c.crossposted_at=a;c.published_at=b;c.last_comment_at=b;c.reading_time_minutes=9;c.tag_list="ionos, letsencrypt, dns, certificate";c.tags=["ionos","letsencrypt","dns","certificate"];c.body_html="\u003Cblockquote\u003E\n\u003Cp\u003E“At the end of the day, the goals are simple: safety and security.” – Jodi Rell\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\n\u003Cp\u003EThe majority of page views on the Internet are using encrypted connections.\u003C\u002Fp\u003E\n\n\u003Cfigure\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--rQaUuhfM--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fc36as4yizabjgdgafvhm.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--rQaUuhfM--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fc36as4yizabjgdgafvhm.png\" alt=\"Google Transparency Report\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cfigcaption\u003E\n  \u003Cb\u003EFigure 1:\u003C\u002Fb\u003E Source: \u003Ca href=\"https:\u002F\u002Ftransparencyreport.google.com\u002Fhttps\u002Foverview?hl=en\"\u003EGoogle Transparency Report\u003C\u002Fa\u003E\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\n\n\n\n\u003Cp\u003EA website has to provide a certificate, issued by a trusted certification authority to establish those connections.\u003C\u002Fp\u003E\n\n\u003Cp\u003EUntil a few years ago, you only got such certificates with an annual fee for issuing from commercial companies like GeoTrust, DigiCert, etc. \u003C\u002Fp\u003E\n\n\u003Cp\u003EWith Let's Encrypt, an open-source certification authority has been available since the end of 2015, which provides free certificates via a more automated protocol.\u003C\u002Fp\u003E\n\n\u003Cp\u003ETo avoid the effort of managing many subdomains and their associated certificates, there is the option of using so-called wildcard certificates. However, applying for such certificates is a bit more complicated and was previously only possible through manual interaction with the DNS provider Ionos in combination with Let's Encrypt.\u003C\u002Fp\u003E\n\n\n\u003Chr\u003E\n\n\u003Ch1\u003E\n  \u003Ca name=\"what-are-wildcard-certificates\" href=\"#what-are-wildcard-certificates\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  What are wildcard certificates?\n\u003C\u002Fh1\u003E\n\n\u003Cp\u003EIn order for your own certificate to be displayed as \"secure\" in the browser, it must first be applied for from a trustworthy certification authority (so-called CAs \u002F Certificate Authorities). When the certificate for a website is presented to the browser, it is checked against a list of CAs stored in the operating system.\u003C\u002Fp\u003E\n\n\u003Cp\u003EEach certificate has a unique name (the so-called \"CN - Common Name\"), which represents the domain that is to be protected by the certificate. \u003C\u002Fp\u003E\n\n\u003Cp\u003EFor example, if a website is accessed under \u003Ccode\u003Eexample.com\u003C\u002Fcode\u003E, the common name of the associated certificate must be \u003Ccode\u003ECN=example.com\u003C\u002Fcode\u003E. Now, if a website is provided under \u003Ccode\u003Esub.example.com\u003C\u002Fcode\u003E, it needs its own certificate with the common name \u003Ccode\u003ECN=sub.example.com\u003C\u002Fcode\u003E. The website under the subdomain cannot be protected by the top-level domain (TLD) certificate.\u003C\u002Fp\u003E\n\n\u003Cp\u003EIf a company uses many subdomains, it can become much of administrative work to maintain all the certificates of the individual subdomains. For this reason there are the so-called \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FWildcard_certificate\"\u003Ewildcard certificates\u003C\u002Fa\u003E. \u003C\u002Fp\u003E\n\n\u003Cp\u003EThe name already implies the functionality of this special type. If the CN contains e.g. the value \u003Ccode\u003ECN=*.example.com\u003C\u002Fcode\u003E, the TLD and all direct subdomains of the TLD are automatically protected by this certificate.\u003C\u002Fp\u003E\n\n\n\u003Chr\u003E\n\n\u003Ch1\u003E\n  \u003Ca name=\"what-is-lets%C2%A0encrypt\" href=\"#what-is-lets%C2%A0encrypt\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  What is Let's Encrypt?\n\u003C\u002Fh1\u003E\n\n\u003Cp\u003EThere have been established certification authorities for a very long time, such as DigiCert, GeoTrust or similar. Since these are commercial companies, they usually charge an annual fee for the \"authentication\" of the certificates. \u003C\u002Fp\u003E\n\n\u003Cp\u003EIn contrast, since the end of 2015, there is an open-source certification authority called \u003Ca href=\"https:\u002F\u002Fletsencrypt.org\"\u003ELet's Encrypt\u003C\u002Fa\u003E. Let's Encrypt is a free, automated and open certification authority provided by the \u003Ca href=\"https:\u002F\u002Fwww.abetterinternet.org\u002F\"\u003EInternet Security Research Group (ISRG)\u003C\u002Fa\u003E. \u003C\u002Fp\u003E\n\n\u003Cp\u003ELet's Encrypt uses the Automated Certificate Management Environment (ACME) protocol, which was standardized in \u003Ca href=\"https:\u002F\u002Ftools.ietf.org\u002Fhtml\u002Frfc8555\"\u003ERFC 8555\u003C\u002Fa\u003E, to validate the ownership of a domain. Since March 2018, Let's Encrypt also offers wildcard certificates using the ACMEv2 protocol (see also \u003Ca href=\"https:\u002F\u002Fcommunity.letsencrypt.org\u002Ft\u002Facme-v2-and-wildcard-certificate-support-is-live\u002F55579\"\u003ELet's Encrypt blog post\u003C\u002Fa\u003E).\u003C\u002Fp\u003E\n\n\n\u003Chr\u003E\n\n\u003Ch1\u003E\n  \u003Ca name=\"how-to-request-a-wildcard-certificate-at-lets-encrypt\" href=\"#how-to-request-a-wildcard-certificate-at-lets-encrypt\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  How to request a (wildcard) certificate at Let's Encrypt?\n\u003C\u002Fh1\u003E\n\n\u003Cp\u003ELet's Encrypt certificates for a specific domain can be requested through the \u003Ca href=\"https:\u002F\u002Fletsencrypt.org\u002Fdocs\u002Fchallenge-types\u002F#http-01-challenge\"\u003EHTTP Challenge\u003C\u002Fa\u003E or the \u003Ca href=\"https:\u002F\u002Fletsencrypt.org\u002Fdocs\u002Fchallenge-types\u002F#dns-01-challenge\"\u003EDNS Challenge\u003C\u002Fa\u003E. For wildcard certificates from Let's Encrypt, only the DNS Challenge can be used (see the article in the \u003Ca href=\"https:\u002F\u002Fletsencrypt.org\u002Fdocs\u002Ffaq\u002F#does-let-s-encrypt-issue-wildcard-certificates\"\u003ELet's Encrypt FAQ\u003C\u002Fa\u003E).\u003C\u002Fp\u003E\n\n\u003Cp\u003EWith the DNS Challenge, validation is accomplished by setting dedicated DNS records. This means that during the process a TXT entry must be created, e.g. for the domain \u003Ccode\u003E_acme-challenge.example.com\u003C\u002Fcode\u003E with a unique value defined by Let's Encrypt. It then checks whether the specified value can be retrieved via the DNS system under the named domain. To ensured that the person making the request has access to the domain and is therefore authorized to carry out the process.\u003C\u002Fp\u003E\n\n\n\u003Chr\u003E\n\n\u003Ch1\u003E\n  \u003Ca name=\"workflow-until-now-with-lets-encrypt-and-ionos-dns\" href=\"#workflow-until-now-with-lets-encrypt-and-ionos-dns\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  Workflow until now with Let's Encrypt and Ionos DNS\n\u003C\u002Fh1\u003E\n\n\u003Cp\u003EIn the past, Ionos as domain and DNS provider at the same time only offered the possibility to create, change or delete DNS entries via web UI. Since TXT entries must be available in the DNS for the domain for the validation process, it was previously necessary to add these manually and then remove them again.\u003C\u002Fp\u003E\n\n\u003Cp\u003EThe Let's Encrypt certificates are only valid for 3 months. Therefore, this process must be performed regularly and manually. The following steps are showing how the steps looked like so far.\u003C\u002Fp\u003E\n\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003EIn order to create or delete DNS entries, authentication at the web UI and navigation to the DNS management.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003EThe validation process is started e.g. with \u003Ca href=\"https:\u002F\u002Fcertbot.eff.org\u002F\"\u003ECertbot\u003C\u002Fa\u003E by executing the following command (replace  with the desired TLD)\u003Cbr\u003E\n\u003C\u002Fp\u003E\n\u003Cpre class=\"highlight plaintext\"\u003E\u003Ccode\u003Ecertbot certonly \n  -d *.&lt;your.domain&gt; \n  --preferred-challenges dns \n  --manual\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003EDuring the DNS challenge protocol, the process is paused for a short time so that a TXT entry with a value defined by Let's Encrypt (\u003Ccode\u003E&lt;acme-challenge-value&gt;\u003C\u002Fcode\u003E) can be entered in the DNS under a defined sub-domain (\u003Ccode\u003E_acme-challenge.&lt;your.domain&gt;\u003C\u002Fcode\u003E).\u003Cbr\u003E\n\u003C\u002Fp\u003E\n\u003Cpre class=\"highlight plaintext\"\u003E\u003Ccode\u003ESaving debug log to \u002Fvar\u002Flog\u002Fletsencrypt\u002Fletsencrypt.log\nPlugins selected: Authenticator manual, Installer None\nObtaining a new certificate\nPerforming the following challenges:\ndns-01 challenge for &lt;your.domain&gt;\n\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nPlease deploy a DNS TXT record under the name\n_acme-challenge.&lt;your.domain&gt; with the following value:\n\n&lt;acme-challenge-value&gt;\n\nBefore continuing, verify the record is deployed.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nPress Enter to Continue\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003EThe values are entered and saved in the Ionos web UI.\u003Cbr\u003E\n\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--ws5wZ5Gg--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fu7g80hg4f0gcvt4kwerq.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--ws5wZ5Gg--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fu7g80hg4f0gcvt4kwerq.png\" alt=\"Ionos add dns entry dialog\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003EWhen the DNS entries have been saved, the process can be continued. The certificate is stored in the filesystem after the DNS entries have been successfully validated.\u003Cbr\u003E\n\u003C\u002Fp\u003E\n\u003Cpre class=\"highlight plaintext\"\u003E\u003Ccode\u003EWaiting for verification...\nCleaning up challenges\n\nIMPORTANT NOTES:\n- Congratulations! Your certificate and chain have been saved at:\n  \u002Fetc\u002Fletsencrypt\u002Flive\u002F&lt;your.domain&gt;\u002Ffullchain.pem\n  Your key file has been saved at:\n  \u002Fetc\u002Fletsencrypt\u002Flive\u002F&lt;your.domain&gt;\u002Fprivkey.pem\n  Your cert will expire on 2019-08-01. To obtain a new or tweaked\n  version of this certificate in the future, simply run certbot\n  again. To non-interactively renew *all* of your certificates, \n  run \"certbot renew\"\n- If you like Certbot, please consider supporting our work by:\n\n  Donating to ISRG \u002F Let's Encrypt:   &lt;https:\u002F\u002Fletsencrypt.org\u002Fdonate&gt;\n  Donating to EFF:                    &lt;https:\u002F\u002Feff.org\u002Fdonate-le&gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003EAfter the DNS challenge has finished, the created DNS entries should be deleted again. The deletion of the entries needs to be done manually in the Ionos web UI.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\n\n\u003Chr\u003E\n\n\u003Ch1\u003E\n  \u003Ca name=\"the-new-ionos-dns-api\" href=\"#the-new-ionos-dns-api\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  The new Ionos DNS API\n\u003C\u002Fh1\u003E\n\n\u003Cp\u003ESince December 2020 Ionos provides a beta API for their DNS system. \u003C\u002Fp\u003E\n\n\u003Cp\u003EIn the \u003Ca href=\"https:\u002F\u002Fdeveloper.hosting.ionos.de\"\u003EDeveloper Portal\u003C\u002Fa\u003E of Ionos you can find a section for the \u003Ca href=\"https:\u002F\u002Fdeveloper.hosting.ionos.de\u002Fdocs\u002Fdns\"\u003EDNS API\u003C\u002Fa\u003E with a Swagger UI. For an easier start, a \"\u003Ca href=\"https:\u002F\u002Fdeveloper.hosting.ionos.de\u002Fdocs\u002Fgetstarted\"\u003EGetting Started\u003C\u002Fa\u003E\" is provided, which provides some details on how to use and register for the API. \u003C\u002Fp\u003E\n\n\u003Cp\u003EIn order to use the DNS API, a registration must be completed. On the page for \u003Ca href=\"https:\u002F\u002Fdeveloper.hosting.ionos.de\u002Fkeys\"\u003Eretrieving the associated API keys\u003C\u002Fa\u003E, you will be directed to the \u003Ca href=\"https:\u002F\u002Fmein.ionos.de\u002Fcontact\"\u003Econtact page\u003C\u002Fa\u003E of Ionos for this purpose.\u003C\u002Fp\u003E\n\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Cstrong\u003EHint:\u003C\u002Fstrong\u003E In our own experience, the registration can only be done via the support hotline, since the activation of the API is a free \"order\"!\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\n\u003Cp\u003EAfter successful ordering, the \"access key\" can be requested in the Developer Portal via the \"Create a new key\" button. The key consists of a \u003Ccode\u003Epublicprefix\u003C\u002Fcode\u003E and a \u003Ccode\u003Esecret\u003C\u002Fcode\u003E. \u003Cstrong\u003EThe secret is only displayed once and should be stored securely.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\n\n\u003Chr\u003E\n\n\u003Ch1\u003E\n  \u003Ca name=\"automation-scripts\" href=\"#automation-scripts\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  Automation Scripts\n\u003C\u002Fh1\u003E\n\n\u003Cp\u003EThere is a plugin for the Certbot tool for \u003Ca href=\"https:\u002F\u002Fcertbot.eff.org\u002Fdocs\u002Fusing.html#dns-plugins\"\u003Esome DNS providers\u003C\u002Fa\u003E to automate the validation process and to create or remove entries via their APIs. \u003C\u002Fp\u003E\n\n\u003Cp\u003EThere is no such plugin for Ionos. However, there is the possibility to \u003Ca href=\"https:\u002F\u002Fcertbot.eff.org\u002Fdocs\u002Fusing.html#pre-and-post-validation-hooks\"\u003Eautomate the process with shell scripts\u003C\u002Fa\u003E for Certbot itself.\u003C\u002Fp\u003E\n\n\u003Cp\u003EWe want to show you such shell scripts, which can be used to create wildcard certificates with the DNS provider Ionos in an automated way and how the scripts can be used in combination with Certbot.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"auth-hook\" href=\"#auth-hook\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  Auth Hook\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EThe Auth Hook Script creates the DNS entries required for validating the domain at Ionos via the DNS API. In the process, the Certbot tool sets certain \u003Ca href=\"https:\u002F\u002Fcertbot.eff.org\u002Fdocs\u002Fusing.html#pre-and-post-validation-hooks\"\u003Eenvironment variables\u003C\u002Fa\u003E at runtime, which can be used during processing. These include, for example, the domain to be validated (\u003Ccode\u003ECERTBOT_DOMAIN\u003C\u002Fcode\u003E) or the token for validating the domain (\u003Ccode\u003ECERTBOT_VALIDATION\u003C\u002Fcode\u003E).\u003C\u002Fp\u003E\n\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Cstrong\u003EPrecondition:\u003C\u002Fstrong\u003E On the system, which executes the script, curl &amp; python must be installed!\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EExecution note:\u003C\u002Fstrong\u003E To display debug logs, remove the \u003Ccode\u003E#\u003C\u002Fcode\u003E character before the command \u003Ccode\u003Eset -x\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"auth-hook-shell-script\" href=\"#auth-hook-shell-script\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  Auth Hook Shell Script\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003EIn the first step, the script searches for the name of the DNS zone based on the domain for which a certificate is requested. \u003C\u002Fp\u003E\n\n\u003Cp\u003EIn the next step, the identifier for the zone is requested from Ionos via the DNS API. This identifier is needed to create DNS entries in this zone via the API. \u003C\u002Fp\u003E\n\n\u003Cp\u003EThe TXT DNS entry is then created with the validation token under the subdomain expected by Let's Encrypt (\u003Ccode\u003E_acme-challenge.&lt;your.domain&gt;\u003C\u002Fcode\u003E). \u003C\u002Fp\u003E\n\n\u003Cp\u003EFinally, the identifier of the zone is written to a temporary file, which is later used for the cleanup.\u003Cbr\u003E\n\u003C\u002Fp\u003E\n\n\u003Cdiv class=\"highlight js-code-highlight\"\u003E\n\u003Cpre class=\"highlight plaintext\"\u003E\u003Ccode\u003E#!\u002Fbin\u002Fsh\n#set -x\n\nAPI_URL=\"https:\u002F\u002Fapi.hosting.ionos.com\u002Fdns\u002Fv1\"\nAPI_KEY_HEADER=\"X-API-Key: $API_KEY\"\n\n# Strip only the top domain to get the zone id\nZONE_NAME=$(expr match \"$CERTBOT_DOMAIN\" '.*\\.\\(.*\\..*\\)')\n# When already the TLD then use it\nif [ -z \"$ZONE_NAME\" ]; then\n  ZONE_NAME=\"$CERTBOT_DOMAIN\"\nfi\n\n# Get the Ionos zone id\nZONE_RESPONSE=$(curl -s -X GET \"$API_URL\u002Fzones\" \\\n                     -H \"$API_KEY_HEADER\" \\\n                     -H \"Accept: application\u002Fjson\")\nZONE_ID=$(echo $ZONE_RESPONSE \\\n     | python -c \"import sys,json;response=json.load(sys.stdin);print(next((x for x in response if x['name']=='$ZONE_NAME'))['id'])\")\n\n# Create TXT record\nCREATE_DOMAIN=\"_acme-challenge.$CERTBOT_DOMAIN\"\nRECORD_CREATE_RESPONSE=$(curl -s -X POST \"$API_URL\u002Fzones\u002F$ZONE_ID\u002Frecords\" \\\n                              -H \"$API_KEY_HEADER\" \\\n                              -H \"Content-Type: application\u002Fjson\" \\\n                              --data '[{\"name\": \"'\"$CREATE_DOMAIN\"'\", \"type\": \"TXT\", \"content\": \"'\"$CERTBOT_VALIDATION\"'\", \"ttl\": 3600, \"prio\": 100, \"disabled\": false}]')\n\n# Save info for cleanup\necho $ZONE_ID &gt; \u002Ftmp\u002FCERTBOT_$CERTBOT_DOMAIN\n\n# Sleep to make sure the change has time to propagate over to DNS\nsleep 25\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cdiv class=\"highlight__panel js-actions-panel\"\u003E\n\u003Cdiv class=\"highlight__panel-action js-fullscreen-code-action\"\u003E\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"\u003E\u003Ctitle\u003EEnter fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"\u003E\u003Ctitle\u003EExit fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\n\n\n\u003Ch2\u003E\n  \u003Ca name=\"cleanup-hook\" href=\"#cleanup-hook\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  Cleanup Hook\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EThe cleanup hook script deletes the DNS records created for domain validation at Ionos via the DNS API.\u003C\u002Fp\u003E\n\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Cstrong\u003EPrecondition:\u003C\u002Fstrong\u003E On the system, which executes the script, curl &amp; python must be installed!\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EExecution note:\u003C\u002Fstrong\u003E To display debug logs, remove the \u003Ccode\u003E#\u003C\u002Fcode\u003E character before the command \u003Ccode\u003Eset -x\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"cleanup-hook-shell-script\" href=\"#cleanup-hook-shell-script\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  Cleanup Hook Shell Script\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003EIn the first step, the script checks whether a file exists for the validated domain, which contains an identifier of a DNS zone. \u003C\u002Fp\u003E\n\n\u003Cp\u003EIf this exists, all identifiers of the DNS entries that were created for the validation of the domain are retrieved for this zone via the DNS API. \u003C\u002Fp\u003E\n\n\u003Cp\u003EFinally, all DNS entries found are deleted using their identifiers via the DNS API.\u003Cbr\u003E\n\u003C\u002Fp\u003E\n\n\u003Cdiv class=\"highlight js-code-highlight\"\u003E\n\u003Cpre class=\"highlight plaintext\"\u003E\u003Ccode\u003E#!\u002Fbin\u002Fsh\n#set -x\n\nAPI_URL=\"https:\u002F\u002Fapi.hosting.ionos.com\u002Fdns\u002Fv1\"\nAPI_KEY_HEADER=\"X-API-Key: $API_KEY\"\n\nif [ -f \u002Ftmp\u002FCERTBOT_$CERTBOT_DOMAIN ]; then\n    ZONE_ID=$(cat \u002Ftmp\u002FCERTBOT_$CERTBOT_DOMAIN)\n    rm -f \u002Ftmp\u002FCERTBOT_$CERTBOT_DOMAIN\n\n    CREATE_DOMAIN=\"_acme-challenge.$CERTBOT_DOMAIN\"\n    # request the created records\n    RECORD_GET_RESPONSE=$(curl -s -X GET \"$API_URL\u002Fzones\u002F$ZONE_ID?recordName=$CREATE_DOMAIN&amp;recordType=TXT\" \\\n                             -H \"$API_KEY_HEADER\" \\\n                             -H \"Accept: application\u002Fjson\")\n    RECORD_IDS=$(echo $RECORD_GET_RESPONSE \\\n            | python -c \"import sys,json;records=json.load(sys.stdin)['records'];print('\\n'.join([x['id'] for x in records]))\")\nfi\n\n# Remove the challenge TXT record from the zone\nif [ -n \"$ZONE_ID\" -a -n \"$RECORD_IDS\" ]; then\n    echo \"$RECORD_IDS\" \\\n    | xargs -n1 -I {} curl -s -X DELETE \"$API_URL\u002Fzones\u002F$ZONE_ID\u002Frecords\u002F{}\" \\\n            -H \"$API_KEY_HEADER\"\nfi\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cdiv class=\"highlight__panel js-actions-panel\"\u003E\n\u003Cdiv class=\"highlight__panel-action js-fullscreen-code-action\"\u003E\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"\u003E\u003Ctitle\u003EEnter fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"\u003E\u003Ctitle\u003EExit fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\n\n\n\u003Ch2\u003E\n  \u003Ca name=\"usage\" href=\"#usage\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  Usage\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EFor simplicity, we use the official Certbot docker image for this demo. The certbot tool and python are already installed. In order to create the certificate, several things have to be prepared.\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003E\u003Cp\u003EA folder for the Let's Encrypt certificate structure must be created. In our example this is located under \u003Ccode\u003E\u002Fopt\u002Fletsencrypt\u002Fcert\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003EA folder where the scripts are located. In our example these are located under \u003Ccode\u003E\u002Fopt\u002Fletsencrypt\u002Fscripts\u003C\u002Fcode\u003E and are executable (\u003Ccode\u003Echmod +x \u002Fopt\u002Fletsencrypt\u002Fscripts\u002F*.sh\u003C\u002Fcode\u003E).\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003E\u002Fopt\u002Fletsencrypt\u002Fscripts\u002Fauthenticate.sh\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003E\u002Fopt\u002Fletsencrypt\u002Fscripts\u002Fcleanup.sh\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\n\u003Cp\u003EAPI access must have been requested (see above) and the \u003Ccode\u003E&lt;publicprefix&gt;\u003C\u002Fcode\u003E and \u003Ccode\u003E&lt;secret&gt;\u003C\u002Fcode\u003E must be set in the following code block. \u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cstrong\u003ENOTE:\u003C\u002Fstrong\u003E A dot (\u003Ccode\u003E.\u003C\u002Fcode\u003E) must be placed between publicprefix and secret!\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003EAn email for expiration notifications and as identifier for a Let's Encrypt account must be set in the following code block (\u003Ccode\u003E&lt;email-address&gt;\u003C\u002Fcode\u003E).\u003C\u002Fp\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003EThe domain for which the certificate is to be created must be set in the following code block (\u003Ccode\u003E&lt;your.domain&gt;\u003C\u002Fcode\u003E).\u003C\u002Fp\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Cstrong\u003EExecution note:\u003C\u002Fstrong\u003E Since the Certbot docker image does not have the tool curl installed, it has to be added additionally. The easiest way to do this is to add the apk add curl command in the auth hook script, e.g. in line 3. Alternatively, you could create your own Docker image, which installs the curl tool in the associated Dockerfile.\u003Cbr\u003E\n\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\n\u003Cdiv class=\"highlight js-code-highlight\"\u003E\n\u003Cpre class=\"highlight plaintext\"\u003E\u003Ccode\u003Edocker run -i --rm \\\n  -v \u002Fopt\u002Fletsencrypt\u002Fcert:\u002Fetc\u002Fletsencrypt \\\n  -v \u002Fopt\u002Fletsencrypt\u002Fscripts:\u002Ftmp\u002Fscripts \\\n  -e \"API_KEY=&lt;publicprefix&gt;.&lt;secret&gt;\" \\\n  certbot\u002Fcertbot \\\n  certonly \\\n  --keep-until-expiring \\\n  --preferred-challenges dns \\\n  --non-interactive \\\n  --agree-tos \\\n  -m &lt;email-address&gt; \\\n  --manual \\\n  --manual-auth-hook \u002Ftmp\u002Fscripts\u002Fauthenticate.sh \\\n  --manual-cleanup-hook \u002Ftmp\u002Fscripts\u002Fcleanup.sh \\\n  -d *.&lt;your.domain&gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cdiv class=\"highlight__panel js-actions-panel\"\u003E\n\u003Cdiv class=\"highlight__panel-action js-fullscreen-code-action\"\u003E\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"\u003E\u003Ctitle\u003EEnter fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"\u003E\u003Ctitle\u003EExit fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\n\n\n\u003Cp\u003EAfter successful validation, the certificate, the complete certificate chain and the corresponding private key are located in the directory \u003Ccode\u003E\u002Fopt\u002Fletsencrypt\u002Fcert\u002Flive\u002F&lt;your.domain&gt;\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\n\n\u003Chr\u003E\n\n\u003Ch1\u003E\n  \u003Ca name=\"conclusion\" href=\"#conclusion\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  Conclusion\n\u003C\u002Fh1\u003E\n\n\u003Cp\u003EThe two shell scripts can be used to completely automate the process of applying for and renewing wildcard certificates. \u003C\u002Fp\u003E\n\n\u003Cp\u003EFor example, the command shown above can be executed regularly using a cron job on a server. This prevents the certificate from expiring and the website visitors from receiving an error message\u002Fwarning. \u003C\u002Fp\u003E\n\n\u003Cp\u003EThe implementation of a native plugin for the Certbot tool would be best, but until then, the scripts shown can be used :)\u003C\u002Fp\u003E\n\n\n\u003Chr\u003E\n\n\u003Cp\u003EFlorian Storz is writing for the devlix Blog at \u003Ca href=\"https:\u002F\u002Fwww.devlix.de\u002Fblog\"\u003Ehttps:\u002F\u002Fwww.devlix.de\u002Fblog\u003C\u002Fa\u003E\u003Cbr\u003E\nThis article was published first here (german): \u003Ca href=\"https:\u002F\u002Fwww.devlix.de\u002Flets-encrypt-wildcard-zertifikate-mit-ionos-dns-api-erzeugen\u002F\"\u003Ehttps:\u002F\u002Fwww.devlix.de\u002Flets-encrypt-wildcard-zertifikate-mit-ionos-dns-api-erzeugen\u002F\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cfigure\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--E8I17rfk--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fzmqebdbqusql1ibky1lr.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--E8I17rfk--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fzmqebdbqusql1ibky1lr.png\" alt=\"devlix logo\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cfigcaption\u003Edevlix GmbH: quality, consulting, development\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\n\n\n\n\n\u003Chr\u003E\n\n\u003Cp\u003EFeature image: Photo by Markus Spiske on Unsplash\u003C\u002Fp\u003E\n\n";c.body_markdown="\u003E “At the end of the day, the goals are simple: safety and security.” – Jodi Rell\n\nThe majority of page views on the Internet are using encrypted connections.\n\n![Google Transparency Report](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fc36as4yizabjgdgafvhm.png)\n\u003Cfigcaption\u003E\n  \u003Cb\u003EFigure 1:\u003C\u002Fb\u003E Source: \u003Ca href=\"https:\u002F\u002Ftransparencyreport.google.com\u002Fhttps\u002Foverview?hl=en\"\u003EGoogle Transparency Report\u003C\u002Fa\u003E\u003C\u002Ffigcaption\u003E\n\nA website has to provide a certificate, issued by a trusted certification authority to establish those connections.\n\nUntil a few years ago, you only got such certificates with an annual fee for issuing from commercial companies like GeoTrust, DigiCert, etc. \n\nWith Let's Encrypt, an open-source certification authority has been available since the end of 2015, which provides free certificates via a more automated protocol.\n\nTo avoid the effort of managing many subdomains and their associated certificates, there is the option of using so-called wildcard certificates. However, applying for such certificates is a bit more complicated and was previously only possible through manual interaction with the DNS provider Ionos in combination with Let's Encrypt.\n\n---\n\n# What are wildcard certificates?\n\nIn order for your own certificate to be displayed as \"secure\" in the browser, it must first be applied for from a trustworthy certification authority (so-called CAs \u002F Certificate Authorities). When the certificate for a website is presented to the browser, it is checked against a list of CAs stored in the operating system.\n\nEach certificate has a unique name (the so-called \"CN - Common Name\"), which represents the domain that is to be protected by the certificate. \n\nFor example, if a website is accessed under `example.com`, the common name of the associated certificate must be `CN=example.com`. Now, if a website is provided under `sub.example.com`, it needs its own certificate with the common name `CN=sub.example.com`. The website under the subdomain cannot be protected by the top-level domain (TLD) certificate.\n\nIf a company uses many subdomains, it can become much of administrative work to maintain all the certificates of the individual subdomains. For this reason there are the so-called [wildcard certificates](https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FWildcard_certificate). \n\nThe name already implies the functionality of this special type. If the CN contains e.g. the value `CN=*.example.com`, the TLD and all direct subdomains of the TLD are automatically protected by this certificate.\n\n---\n\n# What is Let's Encrypt?\n\nThere have been established certification authorities for a very long time, such as DigiCert, GeoTrust or similar. Since these are commercial companies, they usually charge an annual fee for the \"authentication\" of the certificates. \n\nIn contrast, since the end of 2015, there is an open-source certification authority called [Let's Encrypt](https:\u002F\u002Fletsencrypt.org). Let's Encrypt is a free, automated and open certification authority provided by the [Internet Security Research Group (ISRG)](https:\u002F\u002Fwww.abetterinternet.org\u002F). \n\nLet's Encrypt uses the Automated Certificate Management Environment (ACME) protocol, which was standardized in [RFC 8555](https:\u002F\u002Ftools.ietf.org\u002Fhtml\u002Frfc8555), to validate the ownership of a domain. Since March 2018, Let's Encrypt also offers wildcard certificates using the ACMEv2 protocol (see also [Let's Encrypt blog post](https:\u002F\u002Fcommunity.letsencrypt.org\u002Ft\u002Facme-v2-and-wildcard-certificate-support-is-live\u002F55579)).\n\n---\n\n# How to request a (wildcard) certificate at Let's Encrypt?\n\nLet's Encrypt certificates for a specific domain can be requested through the [HTTP Challenge](https:\u002F\u002Fletsencrypt.org\u002Fdocs\u002Fchallenge-types\u002F#http-01-challenge) or the [DNS Challenge](https:\u002F\u002Fletsencrypt.org\u002Fdocs\u002Fchallenge-types\u002F#dns-01-challenge). For wildcard certificates from Let's Encrypt, only the DNS Challenge can be used (see the article in the [Let's Encrypt FAQ](https:\u002F\u002Fletsencrypt.org\u002Fdocs\u002Ffaq\u002F#does-let-s-encrypt-issue-wildcard-certificates)).\n\nWith the DNS Challenge, validation is accomplished by setting dedicated DNS records. This means that during the process a TXT entry must be created, e.g. for the domain `_acme-challenge.example.com` with a unique value defined by Let's Encrypt. It then checks whether the specified value can be retrieved via the DNS system under the named domain. To ensured that the person making the request has access to the domain and is therefore authorized to carry out the process.\n\n---\n\n# Workflow until now with Let's Encrypt and Ionos DNS\n\nIn the past, Ionos as domain and DNS provider at the same time only offered the possibility to create, change or delete DNS entries via web UI. Since TXT entries must be available in the DNS for the domain for the validation process, it was previously necessary to add these manually and then remove them again.\n\nThe Let's Encrypt certificates are only valid for 3 months. Therefore, this process must be performed regularly and manually. The following steps are showing how the steps looked like so far.\n\n1. In order to create or delete DNS entries, authentication at the web UI and navigation to the DNS management.\n\n2. The validation process is started e.g. with [Certbot](https:\u002F\u002Fcertbot.eff.org\u002F) by executing the following command (replace \u003Cyour.domain\u003E with the desired TLD)\n    ```\n    certbot certonly \n      -d *.\u003Cyour.domain\u003E \n      --preferred-challenges dns \n      --manual\n    ```\n\n3. During the DNS challenge protocol, the process is paused for a short time so that a TXT entry with a value defined by Let's Encrypt (`\u003Cacme-challenge-value\u003E`) can be entered in the DNS under a defined sub-domain (`_acme-challenge.\u003Cyour.domain\u003E`).\n    ```\n    Saving debug log to \u002Fvar\u002Flog\u002Fletsencrypt\u002Fletsencrypt.log\n    Plugins selected: Authenticator manual, Installer None\n    Obtaining a new certificate\n    Performing the following challenges:\n    dns-01 challenge for \u003Cyour.domain\u003E\n    \n    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    Please deploy a DNS TXT record under the name\n    _acme-challenge.\u003Cyour.domain\u003E with the following value:\n    \n    \u003Cacme-challenge-value\u003E\n    \n    Before continuing, verify the record is deployed.\n    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    Press Enter to Continue\n    ```\n\n4. The values are entered and saved in the Ionos web UI.\n    ![Ionos add dns entry dialog](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fu7g80hg4f0gcvt4kwerq.png)\n\n5. When the DNS entries have been saved, the process can be continued. The certificate is stored in the filesystem after the DNS entries have been successfully validated.\n    ```\n    Waiting for verification...\n    Cleaning up challenges\n    \n    IMPORTANT NOTES:\n    - Congratulations! Your certificate and chain have been saved at:\n      \u002Fetc\u002Fletsencrypt\u002Flive\u002F\u003Cyour.domain\u003E\u002Ffullchain.pem\n      Your key file has been saved at:\n      \u002Fetc\u002Fletsencrypt\u002Flive\u002F\u003Cyour.domain\u003E\u002Fprivkey.pem\n      Your cert will expire on 2019-08-01. To obtain a new or tweaked\n      version of this certificate in the future, simply run certbot\n      again. To non-interactively renew *all* of your certificates, \n      run \"certbot renew\"\n    - If you like Certbot, please consider supporting our work by:\n    \n      Donating to ISRG \u002F Let's Encrypt:   \u003Chttps:\u002F\u002Fletsencrypt.org\u002Fdonate\u003E\n      Donating to EFF:                    \u003Chttps:\u002F\u002Feff.org\u002Fdonate-le\u003E\n    ```\n\n6. After the DNS challenge has finished, the created DNS entries should be deleted again. The deletion of the entries needs to be done manually in the Ionos web UI.\n\n---\n\n# The new Ionos DNS API\n\nSince December 2020 Ionos provides a beta API for their DNS system. \n\nIn the [Developer Portal](https:\u002F\u002Fdeveloper.hosting.ionos.de) of Ionos you can find a section for the [DNS API](https:\u002F\u002Fdeveloper.hosting.ionos.de\u002Fdocs\u002Fdns) with a Swagger UI. For an easier start, a \"[Getting Started](https:\u002F\u002Fdeveloper.hosting.ionos.de\u002Fdocs\u002Fgetstarted)\" is provided, which provides some details on how to use and register for the API. \n\nIn order to use the DNS API, a registration must be completed. On the page for [retrieving the associated API keys](https:\u002F\u002Fdeveloper.hosting.ionos.de\u002Fkeys), you will be directed to the [contact page](https:\u002F\u002Fmein.ionos.de\u002Fcontact) of Ionos for this purpose.\n\n\u003E **Hint:** In our own experience, the registration can only be done via the support hotline, since the activation of the API is a free \"order\"!\n\nAfter successful ordering, the \"access key\" can be requested in the Developer Portal via the \"Create a new key\" button. The key consists of a `publicprefix` and a `secret`. **The secret is only displayed once and should be stored securely.**\n\n---\n\n# Automation Scripts\n\nThere is a plugin for the Certbot tool for [some DNS providers](https:\u002F\u002Fcertbot.eff.org\u002Fdocs\u002Fusing.html#dns-plugins) to automate the validation process and to create or remove entries via their APIs. \n\nThere is no such plugin for Ionos. However, there is the possibility to [automate the process with shell scripts](https:\u002F\u002Fcertbot.eff.org\u002Fdocs\u002Fusing.html#pre-and-post-validation-hooks) for Certbot itself.\n\nWe want to show you such shell scripts, which can be used to create wildcard certificates with the DNS provider Ionos in an automated way and how the scripts can be used in combination with Certbot.\n\n## Auth Hook\n\nThe Auth Hook Script creates the DNS entries required for validating the domain at Ionos via the DNS API. In the process, the Certbot tool sets certain [environment variables](https:\u002F\u002Fcertbot.eff.org\u002Fdocs\u002Fusing.html#pre-and-post-validation-hooks) at runtime, which can be used during processing. These include, for example, the domain to be validated (`CERTBOT_DOMAIN`) or the token for validating the domain (`CERTBOT_VALIDATION`).\n\n\u003E **Precondition:** On the system, which executes the script, curl & python must be installed!\n\n\u003E **Execution note:** To display debug logs, remove the `#` character before the command `set -x`.\n\n### Auth Hook Shell Script\n\nIn the first step, the script searches for the name of the DNS zone based on the domain for which a certificate is requested. \n\nIn the next step, the identifier for the zone is requested from Ionos via the DNS API. This identifier is needed to create DNS entries in this zone via the API. \n\nThe TXT DNS entry is then created with the validation token under the subdomain expected by Let's Encrypt (`_acme-challenge.\u003Cyour.domain\u003E`). \n\nFinally, the identifier of the zone is written to a temporary file, which is later used for the cleanup.\n\n```\n#!\u002Fbin\u002Fsh\n#set -x\n\nAPI_URL=\"https:\u002F\u002Fapi.hosting.ionos.com\u002Fdns\u002Fv1\"\nAPI_KEY_HEADER=\"X-API-Key: $API_KEY\"\n\n# Strip only the top domain to get the zone id\nZONE_NAME=$(expr match \"$CERTBOT_DOMAIN\" '.*\\.\\(.*\\..*\\)')\n# When already the TLD then use it\nif [ -z \"$ZONE_NAME\" ]; then\n  ZONE_NAME=\"$CERTBOT_DOMAIN\"\nfi\n\n# Get the Ionos zone id\nZONE_RESPONSE=$(curl -s -X GET \"$API_URL\u002Fzones\" \\\n                     -H \"$API_KEY_HEADER\" \\\n                     -H \"Accept: application\u002Fjson\")\nZONE_ID=$(echo $ZONE_RESPONSE \\\n     | python -c \"import sys,json;response=json.load(sys.stdin);print(next((x for x in response if x['name']=='$ZONE_NAME'))['id'])\")\n\n# Create TXT record\nCREATE_DOMAIN=\"_acme-challenge.$CERTBOT_DOMAIN\"\nRECORD_CREATE_RESPONSE=$(curl -s -X POST \"$API_URL\u002Fzones\u002F$ZONE_ID\u002Frecords\" \\\n                              -H \"$API_KEY_HEADER\" \\\n                              -H \"Content-Type: application\u002Fjson\" \\\n                              --data '[{\"name\": \"'\"$CREATE_DOMAIN\"'\", \"type\": \"TXT\", \"content\": \"'\"$CERTBOT_VALIDATION\"'\", \"ttl\": 3600, \"prio\": 100, \"disabled\": false}]')\n\n# Save info for cleanup\necho $ZONE_ID \u003E \u002Ftmp\u002FCERTBOT_$CERTBOT_DOMAIN\n\n# Sleep to make sure the change has time to propagate over to DNS\nsleep 25\n```\n\n## Cleanup Hook\n\nThe cleanup hook script deletes the DNS records created for domain validation at Ionos via the DNS API.\n\n\u003E **Precondition:** On the system, which executes the script, curl & python must be installed!\n\n\u003E **Execution note:** To display debug logs, remove the `#` character before the command `set -x`.\n\n### Cleanup Hook Shell Script\n\nIn the first step, the script checks whether a file exists for the validated domain, which contains an identifier of a DNS zone. \n\nIf this exists, all identifiers of the DNS entries that were created for the validation of the domain are retrieved for this zone via the DNS API. \n\nFinally, all DNS entries found are deleted using their identifiers via the DNS API.\n\n```\n#!\u002Fbin\u002Fsh\n#set -x\n\nAPI_URL=\"https:\u002F\u002Fapi.hosting.ionos.com\u002Fdns\u002Fv1\"\nAPI_KEY_HEADER=\"X-API-Key: $API_KEY\"\n\nif [ -f \u002Ftmp\u002FCERTBOT_$CERTBOT_DOMAIN ]; then\n    ZONE_ID=$(cat \u002Ftmp\u002FCERTBOT_$CERTBOT_DOMAIN)\n    rm -f \u002Ftmp\u002FCERTBOT_$CERTBOT_DOMAIN\n\n    CREATE_DOMAIN=\"_acme-challenge.$CERTBOT_DOMAIN\"\n    # request the created records\n    RECORD_GET_RESPONSE=$(curl -s -X GET \"$API_URL\u002Fzones\u002F$ZONE_ID?recordName=$CREATE_DOMAIN&recordType=TXT\" \\\n                             -H \"$API_KEY_HEADER\" \\\n                             -H \"Accept: application\u002Fjson\")\n    RECORD_IDS=$(echo $RECORD_GET_RESPONSE \\\n            | python -c \"import sys,json;records=json.load(sys.stdin)['records'];print('\\n'.join([x['id'] for x in records]))\")\nfi\n\n# Remove the challenge TXT record from the zone\nif [ -n \"$ZONE_ID\" -a -n \"$RECORD_IDS\" ]; then\n    echo \"$RECORD_IDS\" \\\n    | xargs -n1 -I {} curl -s -X DELETE \"$API_URL\u002Fzones\u002F$ZONE_ID\u002Frecords\u002F{}\" \\\n            -H \"$API_KEY_HEADER\"\nfi\n```\n\n## Usage\n\nFor simplicity, we use the official Certbot docker image for this demo. The certbot tool and python are already installed. In order to create the certificate, several things have to be prepared.\n\n* A folder for the Let's Encrypt certificate structure must be created. In our example this is located under `\u002Fopt\u002Fletsencrypt\u002Fcert`.\n\n* A folder where the scripts are located. In our example these are located under `\u002Fopt\u002Fletsencrypt\u002Fscripts` and are executable (`chmod +x \u002Fopt\u002Fletsencrypt\u002Fscripts\u002F*.sh`).\n    * `\u002Fopt\u002Fletsencrypt\u002Fscripts\u002Fauthenticate.sh`\n    * `\u002Fopt\u002Fletsencrypt\u002Fscripts\u002Fcleanup.sh`\n\n* API access must have been requested (see above) and the `\u003Cpublicprefix\u003E` and `\u003Csecret\u003E` must be set in the following code block. \n    * **NOTE:** A dot (`.`) must be placed between publicprefix and secret!\n\n* An email for expiration notifications and as identifier for a Let's Encrypt account must be set in the following code block (`\u003Cemail-address\u003E`).\n\n* The domain for which the certificate is to be created must be set in the following code block (`\u003Cyour.domain\u003E`).\n\n\u003E **Execution note:** Since the Certbot docker image does not have the tool curl installed, it has to be added additionally. The easiest way to do this is to add the apk add curl command in the auth hook script, e.g. in line 3. Alternatively, you could create your own Docker image, which installs the curl tool in the associated Dockerfile.\n\n```\ndocker run -i --rm \\\n  -v \u002Fopt\u002Fletsencrypt\u002Fcert:\u002Fetc\u002Fletsencrypt \\\n  -v \u002Fopt\u002Fletsencrypt\u002Fscripts:\u002Ftmp\u002Fscripts \\\n  -e \"API_KEY=\u003Cpublicprefix\u003E.\u003Csecret\u003E\" \\\n  certbot\u002Fcertbot \\\n  certonly \\\n  --keep-until-expiring \\\n  --preferred-challenges dns \\\n  --non-interactive \\\n  --agree-tos \\\n  -m \u003Cemail-address\u003E \\\n  --manual \\\n  --manual-auth-hook \u002Ftmp\u002Fscripts\u002Fauthenticate.sh \\\n  --manual-cleanup-hook \u002Ftmp\u002Fscripts\u002Fcleanup.sh \\\n  -d *.\u003Cyour.domain\u003E\n```\n\nAfter successful validation, the certificate, the complete certificate chain and the corresponding private key are located in the directory `\u002Fopt\u002Fletsencrypt\u002Fcert\u002Flive\u002F\u003Cyour.domain\u003E`.\n\n---\n\n# Conclusion\n\nThe two shell scripts can be used to completely automate the process of applying for and renewing wildcard certificates. \n\nFor example, the command shown above can be executed regularly using a cron job on a server. This prevents the certificate from expiring and the website visitors from receiving an error message\u002Fwarning. \n\nThe implementation of a native plugin for the Certbot tool would be best, but until then, the scripts shown can be used :)\n\n---\n\nFlorian Storz is writing for the devlix Blog at https:\u002F\u002Fwww.devlix.de\u002Fblog\nThis article was published first here (german): https:\u002F\u002Fwww.devlix.de\u002Flets-encrypt-wildcard-zertifikate-mit-ionos-dns-api-erzeugen\u002F\n\n![devlix logo](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fzmqebdbqusql1ibky1lr.png)\n\u003Cfigcaption\u003Edevlix GmbH: quality, consulting, development\u003C\u002Ffigcaption\u003E\n\n---\n\nFeature image: Photo by Markus Spiske on Unsplash";c.user={name:"Florian Storz",username:e,twitter_username:a,github_username:e,website_url:a,profile_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--nTLWzzdt--\u002Fc_fill,f_auto,fl_progressive,h_640,q_auto,w_640\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F608984\u002F6cf32b9d-6a8f-4520-af7b-d8880f50c587.jpg",profile_image_90:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--aD2Fd2pK--\u002Fc_fill,f_auto,fl_progressive,h_90,q_auto,w_90\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F608984\u002F6cf32b9d-6a8f-4520-af7b-d8880f50c587.jpg"};c.organization={name:"devlix Blog",username:f,slug:f,profile_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--IXTfckt2--\u002Fc_fill,f_auto,fl_progressive,h_640,q_auto,w_640\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Forganization\u002Fprofile_image\u002F3650\u002F8cf01f38-d3c8-4277-951e-26e1c1848c58.png",profile_image_90:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--xa6cMmsG--\u002Fc_fill,f_auto,fl_progressive,h_90,q_auto,w_90\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Forganization\u002Fprofile_image\u002F3650\u002F8cf01f38-d3c8-4277-951e-26e1c1848c58.png"};return {data:[{}],fetch:{"data-v-25febe66:0":{article:c}},mutations:[["SET_CURRENT_ARTICLE",c]]}}(null,"2021-04-06T19:46:03Z",{},5,"fstorz","devlix-blog")));