window.__NUXT__=(function(a,b,c,d,e){return {staticAssetsBase:"\u002F_nuxt\u002Fstatic\u002F1634322943",layout:"default",error:a,state:{currentArticle:{type_of:"article",id:549520,title:"Reflecting on a year with Node.js and why I should have stuck with Laravel",description:"A year ago I made a bet on full-stack JS and switched my focus from Laravel to Node.js. A year later, I found that Node just slowed me down.",readable_publish_date:"Dec 23 '20",slug:"reflecting-on-a-year-with-node-js-and-why-i-should-have-stuck-with-laravel-e5a",path:"\u002Ftylerlwsmith\u002Freflecting-on-a-year-with-node-js-and-why-i-should-have-stuck-with-laravel-e5a",url:b,comments_count:48,public_reactions_count:c,collection_id:a,published_timestamp:d,positive_reactions_count:c,cover_image:a,social_image:"https:\u002F\u002Fdev.to\u002Fsocial_previews\u002Farticle\u002F549520.png",canonical_url:b,created_at:"2020-12-22T09:26:45Z",edited_at:"2020-12-23T02:05:17Z",crossposted_at:a,published_at:d,last_comment_at:"2021-08-25T21:31:12Z",reading_time_minutes:5,tag_list:"laravel, php, node, javascript",tags:["laravel","php","node","javascript"],body_html:"\u003Cp\u003EEarlier this year, I was two months into building a full-stack JavaScript app. I used an Express server, set up Next.js for server-side rendering, added Chokidar for instant server reloading, used Next.js's Webpack config to compile my server's TypeScript code, hooked up cookie authentication with Argon2 encryption, found the perfect Node ORM, and had the app running in separate containers for Node, PostgreSQL and Redis.\u003C\u002Fp\u003E\n\n\u003Cp\u003EAfter two months of hard work, all I had built was a mediocre server-rendered CRUD app hacked together with two-dozen NPM libraries. If I had used Laravel and jQuery, I could have built this all in a weekend.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EAfter a year of building Node.js apps, I discovered I was spending more time piecing together tools than writing application code.\u003C\u002Fstrong\u003E Laravel gives me 80% of my tooling out-of-the-box for 20% of the work. If moving fast is important to you, you should consider batteries-included frameworks like Laravel and Rails first.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"the-failed-promises-of-fullstack-js\" href=\"#the-failed-promises-of-fullstack-js\"\u003E\n  \u003C\u002Fa\u003E\n  The failed promises of full-stack JS\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EFull-stack JavaScript evangelists preach that developers can work faster by staying in one language and sharing code between the front-end and back-end of an app. I spent a year chasing that dream without ever reaping its promised benefits.\u003C\u002Fp\u003E\n\n\u003Cp\u003EWhile Node.js and ES6 are both JavaScript, they are very different implementations. Node historically hasn't worked well with ES6 modules, which means you must compile ES6 code to CommonJS to run it on the server. Configuring Webpack and other bundlers is a completely separate skillset from application development, and it can take days to set everything up correctly. Opinionated tools like Next.js have eased this pain slightly, but its serverless-first approach can make it feel constraining when implementing features that would be standard in a server environment (like using the filesystem).\u003C\u002Fp\u003E\n\n\u003Cp\u003EI had hoped that by staying in a single language I could at least gain speed by not switching contexts, but instead I spent my time switching between endless tabs of third-party package documentation in my browser. Node.js doesn't have a killer back-end app like Laravel that the community has rallied around. Instead, it has a multitude of frameworks gunning for the spot but with no significant adoption or traction. To mitigate the risk of picking a framework that could disappear, many developers use Express.js and piece together an application around that. Unfortunately, using this approach leaves you with countless decisions to make. What ORM or DB driver do you use? Cookie auth or JWT? What encryption algorithm is best? What library should you use for data validation? \u003C\u002Fp\u003E\n\n\u003Cp\u003EEvery one of these decisions can take a week to fully understand the implications of, all while you could have been building your app. It's death by 1,000 paper cuts.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"laravel-rapid-application-development-done-right\" href=\"#laravel-rapid-application-development-done-right\"\u003E\n  \u003C\u002Fa\u003E\n  Laravel: Rapid Application Development done right\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003ELaravel is an incredibly productive application platform. It comes with all of the things you'd expect from a batteries-included framework: routing, an ORM, middleware, authentication, validation, migrations, and testing (just to name a few). But Laravel has two killer features that other full-stack frameworks don't have: a vibrant \u003Cstrong\u003Efirst-party package ecosystem\u003C\u002Fstrong\u003E and \u003Cstrong\u003Eincredible documentation\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\n\n\u003Cp\u003ELaravel has a first-party Stripe integration for billing. The framework includes a first-party integration for users to use social OAuth to log in. Laravel has first-party app scaffolding, a pre-configured docker environment, a powerful queue system, and if you're willing to pay a few extra dollars, you can get managed Laravel deployment and a gorgeous application dashboard.\u003C\u002Fp\u003E\n\n\u003Cp\u003ELaravel's first-party paid modules are a differentiator: its paid offerings have made it a self-sustaining business with full-time employees who can maintain first-party packages and sweat the details on things like documentation. \u003C\u002Fp\u003E\n\n\u003Cp\u003ELaravel's documentation might be its most powerful feature. While many documentation sites feel bleak and inhospitable, the design on Laravel's docs is bright and inviting. The docs are well-organized and maintain a consistent voice throughout the pages. The docs also have an instantaneous full-text typo-tolerant search, which will not only take you to the correct page, but also put you on the relevant part of the page.\u003C\u002Fp\u003E\n\n\u003Cp\u003ELaravel's powerful first-party integrations and superior documentation let you get to the business of building your application right away. Rather than comparing the six most popular ORMs for Node, you use the one that comes with Laravel. Rather than researching all the ways to authenticate your users with their social profiles, you use Laravel's first-party package. All of your framework's documentation lives in one place instead of across a dozen sites, and you can leverage the entire Laravel community when you have challenges instead of the few people using the same libraries as you.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"what-ive-learned\" href=\"#what-ive-learned\"\u003E\n  \u003C\u002Fa\u003E\n  What I've learned\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EWhat I've learned is if you want to develop applications quickly, it isn't about staying in one language: it's about reaching for the tools that let you move quickly, whatever those are. \u003C\u002Fp\u003E\n\n\u003Cp\u003EI use Laravel because it lets me build my server-side apps fast. I use React for most of my front-end web applications, and Laravel gives me the tools I need to spin up the backend quickly. On sites where SEO is important, I can pair a server-rendered Laravel site with Vue widgets for the more interactive parts of the site. Laravel Mix's zero-configuration bundling makes compiling a project's assets a breeze.\u003C\u002Fp\u003E\n\n\u003Cp\u003ERather than sharing code between the front-end and back-end, I've learned to move almost all of my business and validation logic to the back-end, and I consume it on the front-end via API. Just because you're using two different languages doesn't mean you need to write the same code twice.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EI prefer Laravel over Node.js because it lets me move fast.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"parting-thoughts\" href=\"#parting-thoughts\"\u003E\n  \u003C\u002Fa\u003E\n  Parting Thoughts\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EI could end with a note about \"using the right tool for the job,\" but I don't feel like that's the right take away. Instead, use the fastest, most productive tool you have available to kick apps out the door quickly and get feedback from your users. For some developers and for some projects, Node.js will be that tool. However, for those who are already proficient with Laravel, Rails, or Django and want to use full-stack JavaScript to move faster, I would caution you that you might just lose a year piecing together your own framework with little to show for your investment.\u003C\u002Fp\u003E\n\n",body_markdown:"---\ntitle: Reflecting on a year with Node.js and why I should have stuck with Laravel\npublished: true\ndescription: A year ago I made a bet on full-stack JS and switched my focus from Laravel to Node.js. A year later, I found that Node just slowed me down.\ntags: Laravel, PHP, Node, JavaScript\n\u002F\u002Fcover_image: https:\u002F\u002Fdirect_url_to_image.jpg\n---\n\nEarlier this year, I was two months into building a full-stack JavaScript app. I used an Express server, set up Next.js for server-side rendering, added Chokidar for instant server reloading, used Next.js's Webpack config to compile my server's TypeScript code, hooked up cookie authentication with Argon2 encryption, found the perfect Node ORM, and had the app running in separate containers for Node, PostgreSQL and Redis.\n\nAfter two months of hard work, all I had built was a mediocre server-rendered CRUD app hacked together with two-dozen NPM libraries. If I had used Laravel and jQuery, I could have built this all in a weekend.\n\n**After a year of building Node.js apps, I discovered I was spending more time piecing together tools than writing application code.** Laravel gives me 80% of my tooling out-of-the-box for 20% of the work. If moving fast is important to you, you should consider batteries-included frameworks like Laravel and Rails first.\n\n## The failed promises of full-stack JS\n\nFull-stack JavaScript evangelists preach that developers can work faster by staying in one language and sharing code between the front-end and back-end of an app. I spent a year chasing that dream without ever reaping its promised benefits.\n\nWhile Node.js and ES6 are both JavaScript, they are very different implementations. Node historically hasn't worked well with ES6 modules, which means you must compile ES6 code to CommonJS to run it on the server. Configuring Webpack and other bundlers is a completely separate skillset from application development, and it can take days to set everything up correctly. Opinionated tools like Next.js have eased this pain slightly, but its serverless-first approach can make it feel constraining when implementing features that would be standard in a server environment (like using the filesystem).\n\nI had hoped that by staying in a single language I could at least gain speed by not switching contexts, but instead I spent my time switching between endless tabs of third-party package documentation in my browser. Node.js doesn't have a killer back-end app like Laravel that the community has rallied around. Instead, it has a multitude of frameworks gunning for the spot but with no significant adoption or traction. To mitigate the risk of picking a framework that could disappear, many developers use Express.js and piece together an application around that. Unfortunately, using this approach leaves you with countless decisions to make. What ORM or DB driver do you use? Cookie auth or JWT? What encryption algorithm is best? What library should you use for data validation? \n\nEvery one of these decisions can take a week to fully understand the implications of, all while you could have been building your app. It's death by 1,000 paper cuts.\n\n## Laravel: Rapid Application Development done right\n\nLaravel is an incredibly productive application platform. It comes with all of the things you'd expect from a batteries-included framework: routing, an ORM, middleware, authentication, validation, migrations, and testing (just to name a few). But Laravel has two killer features that other full-stack frameworks don't have: a vibrant **first-party package ecosystem** and **incredible documentation**.\n\nLaravel has a first-party Stripe integration for billing. The framework includes a first-party integration for users to use social OAuth to log in. Laravel has first-party app scaffolding, a pre-configured docker environment, a powerful queue system, and if you're willing to pay a few extra dollars, you can get managed Laravel deployment and a gorgeous application dashboard.\n\nLaravel's first-party paid modules are a differentiator: its paid offerings have made it a self-sustaining business with full-time employees who can maintain first-party packages and sweat the details on things like documentation. \n\nLaravel's documentation might be its most powerful feature. While many documentation sites feel bleak and inhospitable, the design on Laravel's docs is bright and inviting. The docs are well-organized and maintain a consistent voice throughout the pages. The docs also have an instantaneous full-text typo-tolerant search, which will not only take you to the correct page, but also put you on the relevant part of the page.\n\nLaravel's powerful first-party integrations and superior documentation let you get to the business of building your application right away. Rather than comparing the six most popular ORMs for Node, you use the one that comes with Laravel. Rather than researching all the ways to authenticate your users with their social profiles, you use Laravel's first-party package. All of your framework's documentation lives in one place instead of across a dozen sites, and you can leverage the entire Laravel community when you have challenges instead of the few people using the same libraries as you.\n\n## What I've learned\n\nWhat I've learned is if you want to develop applications quickly, it isn't about staying in one language: it's about reaching for the tools that let you move quickly, whatever those are. \n\nI use Laravel because it lets me build my server-side apps fast. I use React for most of my front-end web applications, and Laravel gives me the tools I need to spin up the backend quickly. On sites where SEO is important, I can pair a server-rendered Laravel site with Vue widgets for the more interactive parts of the site. Laravel Mix's zero-configuration bundling makes compiling a project's assets a breeze.\n\nRather than sharing code between the front-end and back-end, I've learned to move almost all of my business and validation logic to the back-end, and I consume it on the front-end via API. Just because you're using two different languages doesn't mean you need to write the same code twice.\n\n**I prefer Laravel over Node.js because it lets me move fast.**\n\n## Parting Thoughts\n\nI could end with a note about \"using the right tool for the job,\" but I don't feel like that's the right take away. Instead, use the fastest, most productive tool you have available to kick apps out the door quickly and get feedback from your users. For some developers and for some projects, Node.js will be that tool. However, for those who are already proficient with Laravel, Rails, or Django and want to use full-stack JavaScript to move faster, I would caution you that you might just lose a year piecing together your own framework with little to show for your investment.",user:{name:"Tyler Smith",username:e,twitter_username:e,github_username:a,website_url:"https:\u002F\u002Fdeadhandmedia.com",profile_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--gxyw5f_9--\u002Fc_fill,f_auto,fl_progressive,h_640,q_auto,w_640\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F68031\u002F8a9c06d6-49f7-48a4-bbe8-d859874d382a.jpg",profile_image_90:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--x5GK6YJt--\u002Fc_fill,f_auto,fl_progressive,h_90,q_auto,w_90\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F68031\u002F8a9c06d6-49f7-48a4-bbe8-d859874d382a.jpg"}}},serverRendered:true,routePath:"\u002Farticles\u002Ftylerlwsmith\u002F549520",config:{_app:{basePath:"\u002F",assetsPath:"\u002F_nuxt\u002F",cdnURL:a}}}}(null,"https:\u002F\u002Fdev.to\u002Ftylerlwsmith\u002Freflecting-on-a-year-with-node-js-and-why-i-should-have-stuck-with-laravel-e5a",103,"2020-12-23T01:15:50Z","tylerlwsmith"));