window.__NUXT__=(function(a,b,c,d){return {staticAssetsBase:"\u002F_nuxt\u002Fstatic\u002F1634322943",layout:"default",error:a,state:{currentArticle:{type_of:"article",id:823456,title:"How to Reduce\nReact App Loading Time By 70% ",description:"Steps to decrease your React app initial loading time using code splitting.  We build large-scale...",readable_publish_date:"Sep 14",slug:"how-to-reduce-react-app-loading-time-by-70-1kmm",path:"\u002Fnilanth\u002Fhow-to-reduce-react-app-loading-time-by-70-1kmm",url:"https:\u002F\u002Fdev.to\u002Fnilanth\u002Fhow-to-reduce-react-app-loading-time-by-70-1kmm",comments_count:15,public_reactions_count:c,collection_id:a,published_timestamp:d,positive_reactions_count:c,cover_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--6Qq32URN--\u002Fc_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F5dm9huqwfbb3g94vuzvt.png",social_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--hf1JYPAh--\u002Fc_imagga_scale,f_auto,fl_progressive,h_500,q_auto,w_1000\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F5dm9huqwfbb3g94vuzvt.png",canonical_url:"https:\u002F\u002Fjavascript.plainenglish.io\u002Fspeed-up-your-react-app-initial-load-using-code-splitting-f2de58c01ed2",created_at:"2021-09-14T09:23:54Z",edited_at:"2021-09-15T14:05:30Z",crossposted_at:a,published_at:d,last_comment_at:"2021-09-22T05:41:42Z",reading_time_minutes:4,tag_list:"react, javascript, webdev, beginners",tags:["react","javascript","webdev","beginners"],body_html:"\u003Cp\u003ESteps to decrease your React app initial loading time using code splitting.\u003C\u002Fp\u003E\n\n\u003Cp\u003EWe build large-scale apps using React. When building these apps, the major issue we face is app performance. When the app grows larger and larger, the performance might deteriorate. Particularly the initial loading time of the app will be affected more. Initial app loading needs to be fast without showing a blank screen for few seconds to the user. As taking more time to load will create a bad impression for the user.\u003C\u002Fp\u003E\n\n\u003Cp\u003EThe major cause for this issue is adding too many components into a single bundle file, so the loading of that bundle file might take more time. To avoid this kind of issue, we need to structure our components in an optimized way. To solve this react itself has a native solution, which is code-splitting and lazy loading. Which allows splitting bundle files into a smaller size.\u003C\u002Fp\u003E\n\n\u003Cp\u003EThe best place to introduce code splitting is in routes. Route-based code splitting solve half of the issues. But most of the apps are utilizing only 50% of the advantages of code splitting.\u003C\u002Fp\u003E\n\n\u003Cp\u003EAre we structuring the components properly when using code splitting? We can see why and how to fix it using some code samples. For that, we are going to use a sample React app with some UI components.\u003C\u002Fp\u003E\n\n\u003Cp\u003EIn the below screenshot, we can see a dashboard component, which has multiple tabs. Each tab has multiple components.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--i7I9ESxb--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fm86yxfplki8f6m4y85ps.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--i7I9ESxb--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fm86yxfplki8f6m4y85ps.png\" alt=\"dashboard component\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EThe Dashboard component uses route-based code splitting as the below code.\u003C\u002Fp\u003E\n\n\n\u003Cdiv class=\"ltag_gist-liquid-tag\"\u003E\n  \u003Cscript id=\"gist-ltag\" src=\"https:\u002F\u002Fgist.github.com\u002FNilanth\u002Fafd17cb0cb15b014efb99048f44553b0.js\"\u003E\u003C\u002Fscript\u003E\n\u003C\u002Fdiv\u003E\n\n\n\u003Cp\u003EThe Dashboard component contains some sub-components like Sales, Profit, Chart, Tiles and Trends like the below code\u003C\u002Fp\u003E\n\n\n\u003Cdiv class=\"ltag_gist-liquid-tag\"\u003E\n  \u003Cscript id=\"gist-ltag\" src=\"https:\u002F\u002Fgist.github.com\u002FNilanth\u002F5ed60b31397d81103e1252d71230d396.js\"\u003E\u003C\u002Fscript\u003E\n\u003C\u002Fdiv\u003E\n\n\n\u003Cp\u003EWe have split the code into routes. so when the app is bundled, we get a separate build file for each route as below\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--6mGWrJJd--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Filf5k7rggx1l1zv2zccb.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--6mGWrJJd--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Filf5k7rggx1l1zv2zccb.png\" alt=\"build-files\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EFrom the above image, the file with a size \u003Cstrong\u003E405.1 KB\u003C\u002Fstrong\u003E is the dashboard component and other files are for the Header, sidebar, other components and CSS.\u003C\u002Fp\u003E\n\n\u003Cp\u003EI have hosted the app in \u003Ca href=\"https:\u002F\u002Fwww.netlify.com\u002F\"\u003ENetlify\u003C\u002Fa\u003E to test the performance. As if we test the app locally we cannot find the difference. When I tested the hosted app with \u003Ca href=\"https:\u002F\u002Fgtmetrix.com\u002F\"\u003EGTmetrix\u003C\u002Fa\u003E, the dashboard screen took \u003Cstrong\u003E2.9 seconds\u003C\u002Fstrong\u003E to load, Check the below image for frame by frame loading.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--18w70Ipx--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fdfgai6a0xk1w7gfbvz10.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--18w70Ipx--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fdfgai6a0xk1w7gfbvz10.png\" alt=\"frames\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EThe dashboard component is the initial page for this app, so when we hit the App URL \u003Cstrong\u003E405.1KB\u003C\u002Fstrong\u003E file will be loaded along with the header and sidebar.\u003C\u002Fp\u003E\n\n\u003Cp\u003EInitially, the User will view only the \u003Cstrong\u003ESales\u003C\u002Fstrong\u003E tab, But our sample app dashboard component has multiple tabs. So the browser is downloading other tabs code also, it is delaying the first paint for the user. To decrease the initial load time, we need to make some changes to the dashboard component as below\u003C\u002Fp\u003E\n\n\n\u003Cdiv class=\"ltag_gist-liquid-tag\"\u003E\n  \u003Cscript id=\"gist-ltag\" src=\"https:\u002F\u002Fgist.github.com\u002FNilanth\u002Ff4236862a5748873bc9e53fec9689239.js\"\u003E\u003C\u002Fscript\u003E\n\u003C\u002Fdiv\u003E\n\n\n\u003Cp\u003EHere I have imported each tab component with lazy loading and wrapped the component with suspense. \u003C\u002Fp\u003E\n\n\u003Cblockquote\u003E\n\u003Cp\u003EHere I have added multiple suspense for better understanding, but you can use single suspense for all the components.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\n\u003Cp\u003EI have not done any changes to route level code-splitting. When we build the app, some extra files are added as we have lazy-loaded each tab in the dashboard component. Check the below image for build file separation.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--8cA6EaTl--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F268n08iakvetd2hd0b5k.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--8cA6EaTl--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F268n08iakvetd2hd0b5k.png\" alt=\"build-splitcoding\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003ENow let's test the app with GTmetrix again with the above changes. See the App performance in the below image\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--btIPAr9n--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fhi2z7p6rtx8gp1h31fox.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--btIPAr9n--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fhi2z7p6rtx8gp1h31fox.png\" alt=\"frames-code\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EAs you can see, Now our dashboard component is loaded in \u003Cstrong\u003E1 second\u003C\u002Fstrong\u003E, as \u003Cstrong\u003ESales\u003C\u002Fstrong\u003E tab code only loaded now. We have reduced almost \u003Cstrong\u003E2 seconds\u003C\u002Fstrong\u003E by making some changes. Let see the comparison of route-based and route, component-based code-splitting in the below images.\u003C\u002Fp\u003E\n\n\u003Cfigure\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--rtbgP-xh--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Frefnafbfm38huv20sajl.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--rtbgP-xh--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Frefnafbfm38huv20sajl.png\" alt=\"route-based-frames\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cfigcaption\u003ERoute Based Code Splitting\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\n\n\n\n\u003Cfigure\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--IoWYsBzW--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fk2agdjoxwnu2h98543s6.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--IoWYsBzW--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fk2agdjoxwnu2h98543s6.png\" alt=\"component-based-frames\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cfigcaption\u003ERoute and Component Based Code Splitting\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\n\n\n\n\u003Cp\u003EAs you see, this is a huge improvement in the app initial load. Now we have reduced the React app initial load time by 70% with a few tweaks by using code splitting effectively in the dashboard component.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"reference\" href=\"#reference\"\u003E\n  \u003C\u002Fa\u003E\n  Reference\n\u003C\u002Fh2\u003E\n\n\u003Col\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Freactjs.org\u002Fdocs\u002Fcode-splitting.html#code-splitting\"\u003ECode Splitting\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgtmetrix.com\u002Fblog\u002Ffirst-contentful-paint-explained\u002F\"\u003EFirst Contentful Paint\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"conclusion\" href=\"#conclusion\"\u003E\n  \u003C\u002Fa\u003E\n  Conclusion\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EStructuring components in an optimized way and using React APIs effectively will increase the performance of large-scale apps.\u003C\u002Fp\u003E\n\n\u003Cp\u003EThank you for reading.\u003C\u002Fp\u003E\n\n\u003Cp\u003EGet more updates on \u003Ca href=\"https:\u002F\u002Ftwitter.com\u002FNilanth\"\u003ETwitter\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"more-blogs\" href=\"#more-blogs\"\u003E\n  \u003C\u002Fa\u003E\n  More Blogs\n\u003C\u002Fh2\u003E\n\n\u003Col\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdev.to\u002Fnilanth\u002Fbuild-a-portfolio-using-next-js-tailwind-and-vercel-4dd8\"\u003EBuild a Portfolio Using Next.js, Tailwind, and Vercel with Dark Mode Support\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdev.to\u002Fnilanth\u002Fno-more-import-in-react-2mbo\"\u003ENo More ..\u002F..\u002F..\u002F Import in React\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdev.to\u002Fnilanth\u002F10-react-packages-with-1k-ui-components-2bf3\"\u003E10 React Packages with 1K UI Components\n\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdev.to\u002Fnilanth\u002Fredux-toolkit-the-standard-way-to-write-redux-2g32\"\u003ERedux Toolkit - The Standard Way to Write Redux\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdev.to\u002Fnilanth\u002F5-packages-to-optimize-and-speed-up-your-react-app-during-development-4h5f\"\u003E5 Packages to Optimize and Speed Up Your React App During Development\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdev.to\u002Fnilanth\u002Fhow-to-use-axios-in-an-optimized-and-scalable-way-with-react-518n\"\u003EHow To Use Axios in an Optimized and Scalable Way With React\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdev.to\u002Fnilanth\u002F15-custom-hooks-to-make-your-react-component-lightweight-17cd\"\u003E15 Custom Hooks to Make your React Component Lightweight\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdev.to\u002Fnilanth\u002F10-ways-to-host-your-react-app-for-free-27ga\"\u003E10 Ways to Host Your React App For Free\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdev.to\u002Fnilanth\u002Fhow-to-secure-jwt-in-a-single-page-application-cko\"\u003EHow to Secure JWT in a Single-Page Application\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\n",body_markdown:"Steps to decrease your React app initial loading time using code splitting.\n\nWe build large-scale apps using React. When building these apps, the major issue we face is app performance. When the app grows larger and larger, the performance might deteriorate. Particularly the initial loading time of the app will be affected more. Initial app loading needs to be fast without showing a blank screen for few seconds to the user. As taking more time to load will create a bad impression for the user.\n\nThe major cause for this issue is adding too many components into a single bundle file, so the loading of that bundle file might take more time. To avoid this kind of issue, we need to structure our components in an optimized way. To solve this react itself has a native solution, which is code-splitting and lazy loading. Which allows splitting bundle files into a smaller size.\n\nThe best place to introduce code splitting is in routes. Route-based code splitting solve half of the issues. But most of the apps are utilizing only 50% of the advantages of code splitting.\n\nAre we structuring the components properly when using code splitting? We can see why and how to fix it using some code samples. For that, we are going to use a sample React app with some UI components.\n\nIn the below screenshot, we can see a dashboard component, which has multiple tabs. Each tab has multiple components.\n\n![dashboard component](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fm86yxfplki8f6m4y85ps.png)\n\nThe Dashboard component uses route-based code splitting as the below code.\n\n{% gist\nhttps:\u002F\u002Fgist.github.com\u002FNilanth\u002Fafd17cb0cb15b014efb99048f44553b0\n%}\n\nThe Dashboard component contains some sub-components like Sales, Profit, Chart, Tiles and Trends like the below code\n\n{% gist\nhttps:\u002F\u002Fgist.github.com\u002FNilanth\u002F5ed60b31397d81103e1252d71230d396\n%}\n\nWe have split the code into routes. so when the app is bundled, we get a separate build file for each route as below\n\n![build-files](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Filf5k7rggx1l1zv2zccb.png)\n\nFrom the above image, the file with a size **405.1 KB** is the dashboard component and other files are for the Header, sidebar, other components and CSS.\n\nI have hosted the app in [Netlify](https:\u002F\u002Fwww.netlify.com\u002F) to test the performance. As if we test the app locally we cannot find the difference. When I tested the hosted app with [GTmetrix](https:\u002F\u002Fgtmetrix.com\u002F), the dashboard screen took **2.9 seconds** to load, Check the below image for frame by frame loading.\n\n![frames](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fdfgai6a0xk1w7gfbvz10.png)\n\nThe dashboard component is the initial page for this app, so when we hit the App URL **405.1KB** file will be loaded along with the header and sidebar.\n\nInitially, the User will view only the **Sales** tab, But our sample app dashboard component has multiple tabs. So the browser is downloading other tabs code also, it is delaying the first paint for the user. To decrease the initial load time, we need to make some changes to the dashboard component as below\n\n{% gist\nhttps:\u002F\u002Fgist.github.com\u002FNilanth\u002Ff4236862a5748873bc9e53fec9689239\n%}\n\nHere I have imported each tab component with lazy loading and wrapped the component with suspense. \n\n\u003E Here I have added multiple suspense for better understanding, but you can use single suspense for all the components.\n\nI have not done any changes to route level code-splitting. When we build the app, some extra files are added as we have lazy-loaded each tab in the dashboard component. Check the below image for build file separation.\n\n![build-splitcoding](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F268n08iakvetd2hd0b5k.png)\n\nNow let's test the app with GTmetrix again with the above changes. See the App performance in the below image\n\n![frames-code](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fhi2z7p6rtx8gp1h31fox.png)\n\nAs you can see, Now our dashboard component is loaded in **1 second**, as **Sales** tab code only loaded now. We have reduced almost **2 seconds** by making some changes. Let see the comparison of route-based and route, component-based code-splitting in the below images.\n\n![route-based-frames](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Frefnafbfm38huv20sajl.png)\n\u003Cfigcaption\u003ERoute Based Code Splitting\u003C\u002Ffigcaption\u003E\n\n![component-based-frames](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fk2agdjoxwnu2h98543s6.png)\n\u003Cfigcaption\u003ERoute and Component Based Code Splitting\u003C\u002Ffigcaption\u003E\n\n\nAs you see, this is a huge improvement in the app initial load. Now we have reduced the React app initial load time by 70% with a few tweaks by using code splitting effectively in the dashboard component.\n\n## Reference\n\n1. [Code Splitting](https:\u002F\u002Freactjs.org\u002Fdocs\u002Fcode-splitting.html#code-splitting)\n2. [First Contentful Paint](https:\u002F\u002Fgtmetrix.com\u002Fblog\u002Ffirst-contentful-paint-explained\u002F)\n\n## Conclusion\n\nStructuring components in an optimized way and using React APIs effectively will increase the performance of large-scale apps.\n\nThank you for reading.\n\nGet more updates on [Twitter](https:\u002F\u002Ftwitter.com\u002FNilanth).\n\n## More Blogs\n1. [Build a Portfolio Using Next.js, Tailwind, and Vercel with Dark Mode Support](https:\u002F\u002Fdev.to\u002Fnilanth\u002Fbuild-a-portfolio-using-next-js-tailwind-and-vercel-4dd8)\n2. [No More ..\u002F..\u002F..\u002F Import in React](https:\u002F\u002Fdev.to\u002Fnilanth\u002Fno-more-import-in-react-2mbo)\n3. [10 React Packages with 1K UI Components\n](https:\u002F\u002Fdev.to\u002Fnilanth\u002F10-react-packages-with-1k-ui-components-2bf3)\n4. [Redux Toolkit - The Standard Way to Write Redux](https:\u002F\u002Fdev.to\u002Fnilanth\u002Fredux-toolkit-the-standard-way-to-write-redux-2g32)\n5. [5 Packages to Optimize and Speed Up Your React App During Development](https:\u002F\u002Fdev.to\u002Fnilanth\u002F5-packages-to-optimize-and-speed-up-your-react-app-during-development-4h5f)\n6. [How To Use Axios in an Optimized and Scalable Way With React](https:\u002F\u002Fdev.to\u002Fnilanth\u002Fhow-to-use-axios-in-an-optimized-and-scalable-way-with-react-518n)\n7. [15 Custom Hooks to Make your React Component Lightweight](https:\u002F\u002Fdev.to\u002Fnilanth\u002F15-custom-hooks-to-make-your-react-component-lightweight-17cd)\n8. [10 Ways to Host Your React App For Free](https:\u002F\u002Fdev.to\u002Fnilanth\u002F10-ways-to-host-your-react-app-for-free-27ga)\n9. [How to Secure JWT in a Single-Page Application](https:\u002F\u002Fdev.to\u002Fnilanth\u002Fhow-to-secure-jwt-in-a-single-page-application-cko)\n\n\n",user:{name:b,username:"nilanth",twitter_username:b,github_username:b,website_url:"https:\u002F\u002Fnilanth.vercel.app",profile_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--DdlBQrP9--\u002Fc_fill,f_auto,fl_progressive,h_640,q_auto,w_640\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F561035\u002Ff0dd96a3-bc20-4bb3-8717-03125438c6ab.jpeg",profile_image_90:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--EO_hPk_v--\u002Fc_fill,f_auto,fl_progressive,h_90,q_auto,w_90\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F561035\u002Ff0dd96a3-bc20-4bb3-8717-03125438c6ab.jpeg"}}},serverRendered:true,routePath:"\u002Farticles\u002Fnilanth\u002F823456",config:{_app:{basePath:"\u002F",assetsPath:"\u002F_nuxt\u002F",cdnURL:a}}}}(null,"Nilanth",1100,"2021-09-14T14:30:59Z"));