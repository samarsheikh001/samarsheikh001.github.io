__NUXT_JSONP__("/articles/gitpaulo/762144", (function(a,b,c,d,e){a.type_of="article";a.id=762144;a.title="Journey of a web page üõ£Ô∏è - How browsers work";a.description="This article covers the processes that happen in-between a user entering a web address in a browser...";a.readable_publish_date="Jul 19";a.slug="journey-of-a-web-page-how-browsers-work-10co";a.path="\u002Fgitpaulo\u002Fjourney-of-a-web-page-how-browsers-work-10co";a.url=b;a.comments_count=14;a.public_reactions_count=c;a.collection_id=d;a.published_timestamp=e;a.positive_reactions_count=c;a.cover_image="https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--ER-8xbPW--\u002Fc_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Ftwo8mb4q6x156kt4vceh.png";a.social_image="https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--YgcPAwuw--\u002Fc_imagga_scale,f_auto,fl_progressive,h_500,q_auto,w_1000\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Ftwo8mb4q6x156kt4vceh.png";a.canonical_url=b;a.created_at="2021-07-17T18:53:05Z";a.edited_at="2021-07-22T15:20:33Z";a.crossposted_at=d;a.published_at=e;a.last_comment_at="2021-10-13T12:47:45Z";a.reading_time_minutes=22;a.tag_list="architecture, html, css, javascript";a.tags=["architecture","html","css","javascript"];a.body_html="\u003Cp\u003EThis article covers the processes that happen in-between a user entering a web address in a browser and a web page showing up as a result.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"overview\" href=\"#overview\"\u003E\n  \u003C\u002Fa\u003E\n  Overview\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EIf you're like me‚Äîif you like to understand the tools you work with‚ÄîI hope this article helps you learn something you did not know before. Let's get started!\u003C\u002Fp\u003E\n\n\u003Cp\u003EThere are a handful of steps that occur between the time a user requests a web page and the time it displays in their browser. I've divided these steps into the following sections:\u003C\u002Fp\u003E\n\n\u003Col\u003E\n\u003Cli\u003E\n\u003Ca href=\"#navigation\"\u003E\u003Cstrong\u003ENavigation\u003C\u002Fstrong\u003E\u003C\u002Fa\u003E\n\n\u003Cul\u003E\n\u003Cli\u003EResolving the web address (DNS Lookup)\u003C\u002Fli\u003E\n\u003Cli\u003EEstablishing a connection to the server (TCP 3-way handshake)\u003C\u002Fli\u003E\n\u003Cli\u003EEstablishing a security protocol (TLS negotiation)\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Ca href=\"#fetching\"\u003E\u003Cstrong\u003EFetching\u003C\u002Fstrong\u003E\u003C\u002Fa\u003E\n\n\u003Cul\u003E\n\u003Cli\u003EHTTP request\u003C\u002Fli\u003E\n\u003Cli\u003EHTTP response\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Ca href=\"#parsing\"\u003E\u003Cstrong\u003EParsing\u003C\u002Fstrong\u003E\u003C\u002Fa\u003E\n\n\u003Cul\u003E\n\u003Cli\u003EBuilding the DOM tree\u003C\u002Fli\u003E\n\u003Cli\u003EBuilding the CSSOM tree\u003C\u002Fli\u003E\n\u003Cli\u003ECombining the trees into the render tree\u003C\u002Fli\u003E\n\u003Cli\u003EPreload Scanner\u003C\u002Fli\u003E\n\u003Cli\u003EJavaScript Compilation\u003C\u002Fli\u003E\n\u003Cli\u003EBuilding the Accessibility Tree\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Ca href=\"#rendering\"\u003E\u003Cstrong\u003ERendering\u003C\u002Fstrong\u003E\u003C\u002Fa\u003E\n\n\u003Cul\u003E\n\u003Cli\u003ECritical Rendering Path\u003C\u002Fli\u003E\n\u003Cli\u003ELayout\u003C\u002Fli\u003E\n\u003Cli\u003EPaint\u003C\u002Fli\u003E\n\u003Cli\u003ECompositing\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Ca href=\"#finalising\"\u003E\u003Cstrong\u003EFinalising\u003C\u002Fstrong\u003E\u003C\u002Fa\u003E\n\n\u003Cul\u003E\n\u003Cli\u003EJavaScript Occupied.\u003C\u002Fli\u003E\n\u003Cli\u003EUser can now browse the page!\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\n\u003Cp\u003EUse this section to jump to any particular section of interest. However, if you're new to some of these concepts‚Äîstay here. It is time for a quick background lesson.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"background\" href=\"#background\"\u003E\n  \u003C\u002Fa\u003E\n  Background\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EThis section contains a quick and general overview of the core background concepts that are required to understand the later parts of the article. You may skip this section if you're already familiar with them!\u003C\u002Fp\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"networking-models\" href=\"#networking-models\"\u003E\n  \u003C\u002Fa\u003E\n  Networking models\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003EModels exist to explain how data is transmitted through a network. In particular, there exists a network model so widely known that even those that do not partake in \u003Cem\u003Ehackerman\u003C\u002Fem\u003E things might've heard of! We call it the Open Systems Interconnected (OSI) model. Here it goes:\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--ACXWrtYB--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fsx08iepkwc18o55nwx9s.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--ACXWrtYB--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fsx08iepkwc18o55nwx9s.png\" alt=\"The OSI Model\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"https:\u002F\u002Fcommunity.fs.com\u002Fblog\u002Ftcpip-vs-osi-whats-the-difference-between-the-two-models.html\" title=\"foo\"\u003E\u003Cfigcaption\u003EThe OSI Model\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fwww.iso.org\u002Fics\u002F35.100\u002Fx\u002F\"\u003EThe Open Systems Interconnection (OSI) model\u003C\u002Fa\u003E describes seven layers that computer systems use to communicate over a network. Each upper layer is one level of abstraction higher than the previous, all the way up to the application (browser) layer which we will be talking about.\u003C\u002Fp\u003E\n\n\u003Cp\u003EIt‚Äôs important to note that the OSI model is a ‚Äúconceptual model‚Äù for how applications communicate over a network. It is not a protocol. Do not get the two confused. Protocols are strict sets of rules that may live within these layers.\u003C\u002Fp\u003E\n\n\u003Cp\u003EAn older and very similar model, and more relevant to the article, is the \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FInternet_protocol_suite\"\u003ETCP\u002FIP model\u003C\u002Fa\u003E. This model is used for both modelling current Internet architecture and providing a set of rules that are followed by all forms of transmission over the network.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--JT8svLRj--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fd4qicoy7basi6gd4joxr.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--JT8svLRj--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fd4qicoy7basi6gd4joxr.png\" alt=\"\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"https:\u002F\u002Fcommunity.fs.com\u002Fblog\u002Ftcpip-vs-osi-whats-the-difference-between-the-two-models.html\" title=\"OSI vs TCP\u002FIP\"\u003E\u003Cfigcaption\u003EOSI vs TCP\u002FIP\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EI will be referring to this model and its associated protocols throughout the article.\u003C\u002Fp\u003E\n\n\u003Cp\u003EAs hinted at before, any data sent from an application to another will have to travel up and down through these layers a few numbers of times (depending on how many middle men there are). Of course, this happens incredibly fast nowadays, however, it still does happen and understanding the overview of the process is something that every developer should know. The following is an image representation of this process between a server and a client application:\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--u7wLINLi--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F24o98vnamwefnr850216.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--u7wLINLi--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F24o98vnamwefnr850216.png\" alt=\"\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"https:\u002F\u002Fcommunity.fs.com\u002Fblog\u002Ftcpip-vs-osi-whats-the-difference-between-the-two-models.html\" title=\"TCP\u002FIP data travel\"\u003E\u003Cfigcaption\u003ETCP\u002FIP model data path between applications\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003ETake our example, a user requesting to browse a page using a browser: the request is first sent to the application layer, where it is processed from layer to layer down with each layer performing its designated functions. The data is then transmitted over the physical layer of the network until the destination server or another device receives it. At this point the data is passed up through the layers again, each layer performing its assigned operations until the data is used by the web server software. This process is repeated again for the response of the server. This is how machines communicate.\u003C\u002Fp\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"highlevel-abstraction-of-a-browser\" href=\"#highlevel-abstraction-of-a-browser\"\u003E\n  \u003C\u002Fa\u003E\n  High-level abstraction of a browser\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003EThe later sections of the article will be covering how a typical browser displays the content of a page on screen. A high-level understanding of the browser is important when reading those sections. I will be referencing some of the following browser components:\u003C\u002Fp\u003E\n\n\u003Col\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EThe user interface:\u003C\u002Fstrong\u003E this includes the address bar, back\u002Fforward button, bookmarking menu, etc. Every part of the browser display except the window where you see the requested page.\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EThe browser engine:\u003C\u002Fstrong\u003E marshals actions between the UI and the rendering engine.\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EThe rendering engine:\u003C\u002Fstrong\u003E responsible for displaying requested content. For example, if the requested content is HTML, the rendering engine parses HTML and CSS, and displays the parsed content on the screen.\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cstrong\u003ENetworking:\u003C\u002Fstrong\u003E for network calls such as HTTP requests, using different implementations for different platforms behind a platform-independent interface.\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EUI backend:\u003C\u002Fstrong\u003E used for drawing basic widgets like combo boxes and windows. This backend exposes a generic interface that is not platform-specific. Underneath it uses operating system user interface methods.\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EJavaScript interpreter:\u003C\u002Fstrong\u003E Used to parse and execute JavaScript code.\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EData storage:\u003C\u002Fstrong\u003E This is a persistence layer. The browser may need to save all sorts of data locally, such as cookies. Browsers also support storage mechanisms such as localStorage, IndexedDB, WebSQL and FileSystem.\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--cONYVUsU--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fivei7zfohim9n6l83bbk.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--cONYVUsU--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fivei7zfohim9n6l83bbk.png\" alt=\"\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"https:\u002F\u002Fwww.html5rocks.com\u002Fen\u002Ftutorials\u002Finternals\u002Fhowbrowserswork\u002F\" title=\"Browser Components\"\u003E\u003Cfigcaption\u003EBrowser Components\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EIt is important to note that browsers such as Chrome have a multi-process approach for performance and security reasons. This means that they run instances of some of these components, such as the rendering engine, for each tab (each tab is a separate process). You can find proof of this by checking chrome's processes in a task manager.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--n3eKu4Nw--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fwv6sub7wk7fxyi25j1yh.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--n3eKu4Nw--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fwv6sub7wk7fxyi25j1yh.png\" alt=\"\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#\" title=\"Task manager chrome\"\u003E\u003Cfigcaption\u003EScreenshot of Chrome's Task Manager\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EAs you can observe from the screenshot above, each tab has a process priority and CPU\u002FNetwork\u002FGPU statistics implying that they work like normal processes. That is because they do! You can further confirm this by listing your OS's processes and you will surely find them there.\u003C\u002Fp\u003E\n\n\u003Cp\u003ETo conclude this background section, it is important to note that what you just read so far in is a \u003Cstrong\u003Every\u003C\u002Fstrong\u003E high-level generalisation and abstraction of how networks and browsers actually work. Not all networks strictly abide by the OSI\u002FTCP IP models and the main browsers in use today are all different in their own ways but share a common base of concepts that allows us to abstract them to what you've just read. \u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003EFor browsers, as an exmaple, they all follow (to some degree) the specifications maintained by the \u003Ca href=\"https:\u002F\u002Fwww.w3.org\u002F\"\u003EW3C (World Wide Web Consortium) organization\u003C\u002Fa\u003E, which is the standards organization for the web. However, their rendering engines are different, Internet Explorer uses Trident, Firefox uses Gecko, Safari uses WebKit. Chrome, Edge and Opera use Blink, a fork of WebKit.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"journey-of-a-page\" href=\"#journey-of-a-page\"\u003E\n  \u003C\u002Fa\u003E\n  Journey of a page\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EYou open up a browser and type in \u003Ca href=\"http:\u002F\u002Fwww.google.com\"\u003Ewww.google.com\u003C\u002Fa\u003E. This is what happens.\u003C\u002Fp\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"navigation\" href=\"#navigation\"\u003E\n  \u003C\u002Fa\u003E\n  Navigation\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003EThe first step is navigating to the correct place. Navigating to a web page is finding where the assets for that page are located. To us, web pages are simply domain names, but to computers they resolve into IP addresses.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs---Zv8v2iT--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F3l0quvd7dcsg97hbfmfu.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs---Zv8v2iT--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F3l0quvd7dcsg97hbfmfu.png\" alt=\"\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#\" title=\"Domain &lt;-&gt; IP\"\u003E\u003Cfigcaption\u003E  IP\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EIf you navigate to \u003Ca href=\"http:\u002F\u002Fwww.google.com\"\u003Ewww.google.com\u003C\u002Fa\u003E, the page resources will be located on a server with an IP address such as 93.184.216.34 (of sorts). If you‚Äôve never visited this site, a Domain Name System (DNS) lookup must happen.\u003C\u002Fp\u003E\n\n\u003Ch5\u003E\n  \u003Ca name=\"round-trip-time\" href=\"#round-trip-time\"\u003E\n  \u003C\u002Fa\u003E\n  Round Trip Time\n\u003C\u002Fh5\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FRound-trip_delay\"\u003ERound-trip time (RTT)\u003C\u002Fa\u003E is the duration, measured in milliseconds, from when a browser sends a request to when it receives a response from a server. It's a key performance metric for web applications and one of the main factors, along with \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FGlossary\u002Ftime_to_first_byte\"\u003ETime to First Byte (TTFB)\u003C\u002Fa\u003E, when measuring page load time and network latency.\u003C\u002Fp\u003E\n\n\u003Cp\u003EI will be annotating each network process with their corresponding RTT.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"resolving-a-web-address-the-dns-process-o-rtt\" href=\"#resolving-a-web-address-the-dns-process-o-rtt\"\u003E\n  \u003C\u002Fa\u003E\n  Resolving a web address - The DNS Process (O RTT)\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EAn overview of the DNS process for \u003Ccode\u003Ewww.google.com\u003C\u002Fcode\u003E is as follows:\u003C\u002Fp\u003E\n\n\u003Col\u003E\n\u003Cli\u003ECheck browser &amp; OS cache, return if IP found.\u003C\u002Fli\u003E\n\u003Cli\u003EBrowser sends out a request asking for a DNS resolver. \n\n\u003Col\u003E\n\u003Cli\u003EDNS resolver checks its cache, return if IP is found.\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\n\n\u003C\u002Fli\u003E\n\u003Cli\u003EDNS resolver sends out a request asking root nameservers.\u003C\u002Fli\u003E\n\u003Cli\u003EA root nameserver responds to the DNS resolver with an IP address to a TLD nameserver (in this case the TLD for extensions of \u003Ccode\u003E.com\u003C\u002Fcode\u003E).\u003C\u002Fli\u003E\n\u003Cli\u003EDNS resolver sends out another request, now to the TLD nameserver, asking if they know what the IP is.\u003C\u002Fli\u003E\n\u003Cli\u003ETLD nameserver responds back to the DNS resolver with an IP of the authoritative nameserver.\u003C\u002Fli\u003E\n\u003Cli\u003EDNS resolver sends out the final request to the authoritative nameserver asking for the IP.\u003C\u002Fli\u003E\n\u003Cli\u003EThe authoritative nameserver will scan zones files to find the domainname:ipaddress mapping and will return whether it exists or not to the DNS resolver.\u003C\u002Fli\u003E\n\u003Cli\u003EFinally, the DNS resolver will now respond back to the browser with the IP of the server the browser is trying to communicate.\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--l9SEiwNB--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fhglrqe8nj9us42fuxs8d.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--l9SEiwNB--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fhglrqe8nj9us42fuxs8d.png\" alt=\"\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"https:\u002F\u002Fyoutu.be\u002FvrxwXXytEuI\" title=\"TITLE\"\u003E\u003Cfigcaption\u003EVisualisation of the DNS process\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003ENote that this process is usually incredibly fast and rarely follows through in its entirety because of all the layers of caching. It was designed to be fast!\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"establishing-a-connection-to-the-server-tcp-handshake-1-rtt\" href=\"#establishing-a-connection-to-the-server-tcp-handshake-1-rtt\"\u003E\n  \u003C\u002Fa\u003E\n  Establishing a connection to the server - TCP Handshake (1 RTT)\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003ENow that the IP address is known, the browser sets up a connection to the server via a \u003Ca href=\"https:\u002F\u002Fwww.sciencedirect.com\u002Ftopics\u002Fcomputer-science\u002Fthree-way-handshake\"\u003ETCP three-way handshake\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FTransmission_Control_Protocol\"\u003ETCP\u003C\u002Fa\u003E uses a three-way handshake to establish a reliable connection. The connection is full-duplex, and both sides synchronize (SYN) and acknowledge (ACK) each other. The exchange of these four flags is performed in three steps‚ÄîSYN, SYN-ACK, and ACK‚Äîas shown in\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--KhenfJDf--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fdn8y466ruwdfllwwtaig.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--KhenfJDf--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fdn8y466ruwdfllwwtaig.png\" alt=\"\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"https:\u002F\u002Fwww.sciencedirect.com\u002Ftopics\u002Fcomputer-science\u002Fthree-way-handshake\" title=\"TCP Handskae\"\u003E\u003Cfigcaption\u003ETCP 3-way handshake\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Col\u003E\n\u003Cli\u003EThe client chooses an initial sequence number, set in the first SYN packet. \u003C\u002Fli\u003E\n\u003Cli\u003EThe server also chooses its own initial sequence number. \u003C\u002Fli\u003E\n\u003Cli\u003EEach side acknowledges the other's sequence number by incrementing it; this is the acknowledgement number.\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\n\u003Cp\u003EOnce a connection is established, ACKs typically follow for each segment. The connection will eventually end with an RST (reset or tear down the connection) or FIN (gracefully end the connection).\u003C\u002Fp\u003E\n\n\u003Cp\u003EThis mechanism is designed so that two entities attempting to communicate, in this case, the browser and web server, can negotiate the parameters of the network TCP socket connection before transmitting data, in our case, it will be over HTTPS‚Äîthe secure version of \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FHTTP\"\u003EHTTP\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\n\u003Cp\u003EHTTPS is HTTP with encryption. The only difference between the two protocols is that HTTPS uses \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FTransport_Layer_Security\"\u003ETLS (SSL)\u003C\u002Fa\u003E to encrypt normal HTTP requests and responses. As a result, HTTPS provides a solid layer of security over HTTP. A website that uses HTTP has \u003Ccode\u003Ehttp:\u002F\u002F\u003C\u002Fcode\u003E in its URL, while a website that uses HTTPS has \u003Ccode\u003Ehttps:\u002F\u002F\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"establishing-a-security-protocol-tls-negotiation-2-rtt\" href=\"#establishing-a-security-protocol-tls-negotiation-2-rtt\"\u003E\n  \u003C\u002Fa\u003E\n  Establishing a security protocol - TLS Negotiation (~2 RTT)\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EFor secure connections established over HTTPS, another \"handshake\" is required. This handshake, or rather the TLS negotiation, determines which cypher will be used to encrypt the communication, verifies the server, and establishes that a secure connection is in place before beginning the actual transfer of data.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--8I5bXx9W--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fmuxmc254vu339latlf61.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--8I5bXx9W--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fmuxmc254vu339latlf61.png\" alt=\"\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"https:\u002F\u002Fblog.cloudflare.com\u002Fkeyless-ssl-the-nitty-gritty-technical-details\u002F\" title=\"TSL Hanshake\"\u003E\u003Cfigcaption\u003EModern day TLS establishing\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EWhile making the connection secure adds time to the page load, a secure connection is worth the latency expense, as the data transmitted between the browser and the web server cannot normally be decrypted by a third party. TLS has come a long way and version 1.3 upwards has reduced the Round Trip Time (RTT) from 4 all the way to 2 or even 1 depending on the situation.\u003C\u002Fp\u003E\n\n\u003Cp\u003EAssuming DNS is instantaneous and adding in the HTTP fetch RTT (next section), this leaves 4 round trips before the browser can start showing the page. If you‚Äôre visiting a site you‚Äôve recently connected to, the TLS handshake phase can be shortened from 2 round trips to 1 with \u003Ca href=\"https:\u002F\u002Fblog.cloudflare.com\u002Ftls-session-resumption-full-speed-and-secure\u002F\"\u003ETLS session resumption\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003ENew Connection: 4 RTT + DNS\u003C\u002Fli\u003E\n\u003Cli\u003EResumed Connection: 3 RTT + DNS\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"fetching\" href=\"#fetching\"\u003E\n  \u003C\u002Fa\u003E\n  Fetching\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003ENow that we have a TCP connection setup and the TLS exchange has been completed, the browser can now begin to fetch the page's resources. It starts by fetching the markup document for the page. It does this by using the \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FHTTP\"\u003EHTTP protocol\u003C\u002Fa\u003E. HTTP requests are sent via TCP\u002FIP and in our case encrypted with Transport Layer Security (TLS)‚Äîsince google uses HTTPS.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"http-request\" href=\"#http-request\"\u003E\n  \u003C\u002Fa\u003E\n  HTTP Request\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003ETo fetch a page an \u003Ca href=\"https:\u002F\u002Fwww.restapitutorial.com\u002Flessons\u002Fidempotency.html\"\u003Eidempotent\u003C\u002Fa\u003E (not changing the server state) request is made. We use the HTTP GET request.\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Ccode\u003EGET\u003C\u002Fcode\u003E‚ÄîRequests information from a given server using a \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FUniform_Resource_Identifier\"\u003EUniform Resource Identifier (URI)\u003C\u002Fa\u003E. Specification \u003Ca href=\"https:\u002F\u002Fdatatracker.ietf.org\u002Fdoc\u002Fhtml\u002Frfc7231#section-4.3.1\"\u003Ecorrect implementations\u003C\u002Fa\u003E of  the GET method only retrieve data and do not cause changes in the source state. No matter how many times you request the same resource, you will never cause a change in state.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003EThere are many other types of HTTP methods:\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--1eqiXYxj--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fegy39l7tc3e4pm965lnq.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--1eqiXYxj--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fegy39l7tc3e4pm965lnq.png\" alt=\"\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"https:\u002F\u002Fdatatracker.ietf.org\u002Fdoc\u002Fhtml\u002Frfc7231#section-8.1.3\" title=\"HTTP method types\"\u003E\u003Cfigcaption\u003EHTTP Methods as per sepecification\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EFor fetching our page we are only interested in \u003Ccode\u003EGET\u003C\u002Fcode\u003E.\u003Cbr\u003E\n\u003C\u002Fp\u003E\n\n\u003Cdiv class=\"highlight js-code-highlight\"\u003E\n\u003Cpre class=\"highlight plaintext\"\u003E\u003Ccode\u003EGET \u002F HTTP\u002F2\nHost: www.google.com\nUser-Agent: Mozilla\u002F5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko\u002F20100101 Firefox\u002F89.0\nAccept: text\u002Fhtml,application\u002Fxhtml+xml,application\u002Fxml;q=0.9,image\u002Fwebp,*\u002F*;q=0.8\nAccept-Language: en-GB,en;q=0.5\nAccept-Encoding: gzip, deflate, br\nConnection: keep-alive\nUpgrade-Insecure-Requests: 1\nCache-Control: max-age=0\nTE: Trailers\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cdiv class=\"highlight__panel js-actions-panel\"\u003E\n\u003Cdiv class=\"highlight__panel-action js-fullscreen-code-action\"\u003E\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"\u003E\u003Ctitle\u003EEnter fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"\u003E\u003Ctitle\u003EExit fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\n\n\n\u003Ch4\u003E\n  \u003Ca name=\"http-response\" href=\"#http-response\"\u003E\n  \u003C\u002Fa\u003E\n  HTTP Response\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EOnce the webserver receives the request. It will parse the request and try to fulfil it. We assume the request is valid and the files are available. It will reply with a HTTP response, attaching the relevant headers and the contents of the requested HTML document to the body of the that response structure.\u003Cbr\u003E\n\u003C\u002Fp\u003E\n\n\u003Cdiv class=\"highlight js-code-highlight\"\u003E\n\u003Cpre class=\"highlight plaintext\"\u003E\u003Ccode\u003EHTTP\u002F2 200 OK\ndate: Sun, 18 Jul 2021 00:26:11 GMT\nexpires: -1\ncache-control: private, max-age=0\ncontent-type: text\u002Fhtml; charset=UTF-8\nstrict-transport-security: max-age=31536000\ncontent-encoding: br\nserver: gws\ncontent-length: 37418\nx-xss-protection: 0\nx-frame-options: SAMEORIGIN\ndomain=www.google.com\npriority=high\nX-Firefox-Spdy: h2\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cdiv class=\"highlight__panel js-actions-panel\"\u003E\n\u003Cdiv class=\"highlight__panel-action js-fullscreen-code-action\"\u003E\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"\u003E\u003Ctitle\u003EEnter fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"\u003E\u003Ctitle\u003EExit fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\n\n\n\u003Cp\u003E*the source code of the HTML document will be in the body of the response.\u003C\u002Fp\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"parsing\" href=\"#parsing\"\u003E\n  \u003C\u002Fa\u003E\n  Parsing\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003EOnce the browser receives the response, it can begin parsing the information received. Parsing is the step the browser takes to turn the data it receives over the network into the DOM and CSSOM, which is used by the renderer to paint a page to the screen.\u003C\u002Fp\u003E\n\n\u003Cp\u003EThe \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FDocument_Object_Model\"\u003EDocument Object Model (DOM)\u003C\u002Fa\u003E is an internal representation of the objects that comprise the structure and content of the markup (HTML in this case) document the browser just received. It represents the page so that programs can change the document structure, style, and content. \u003C\u002Fp\u003E\n\n\u003Cp\u003EThe DOM represents the document as nodes and objects. That way, programming languages can connect to the page. There are many different types of nodes in a DOM tree. An example part of the specification for the \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FNode\"\u003EDOM Node Interface\u003C\u002Fa\u003E looks as follows:\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003ENode.ELEMENT_NODE\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003ENode.ATTRIBUTE_NODE\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003ENode.TEXT_NODE\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003ENode.CDATA_SECTION_NODE\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003ENode.PROCESSING_INSTRUCTION_NODE\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003ENode.COMMENT_NODE\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003ENode.DOCUMENT_NODE\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003ENode.DOCUMENT_TYPE_NODE\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003ENode.DOCUMENT_FRAGMENT_NODE\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003ENode.NOTATION_NODE\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003EThese node types cover all possible nodes in the document. Such representations help programming languages connect to the page so that they can manipulate it.\u003C\u002Fp\u003E\n\n\u003Cp\u003ETo conclude our parsing preface, we need to talk about the CSSOM. \u003C\u002Fp\u003E\n\n\u003Cp\u003EThe \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FCSS_Object_Model\"\u003ECSS Object Model (CSSOM)\u003C\u002Fa\u003E is a set of APIs allowing the manipulation of CSS from JavaScript. It is much like the DOM, but for the CSS rather than the HTML. It allows users to read and modify CSS style dynamically. It is represented very similarly to the DOM, as a tree, and it will be used along with the DOM to form a render tree so that the browser can begin its rendering process. Let's find out how by going through the entire process.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"building-the-dom-tree\" href=\"#building-the-dom-tree\"\u003E\n  \u003C\u002Fa\u003E\n  Building the DOM tree\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EThe first step is processing the HTML markup and building the DOM tree. HTML parsing involves tokenization and tree construction. \u003C\u002Fp\u003E\n\n\u003Cp\u003EHTML may come as a surprise in the world of parsing as it cannot be parsed through conventional means as it cannot be defined by a \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FContext-free_grammar\"\u003EContext Free Grammar (CFG)\u003C\u002Fa\u003E. Instead, there is a formal format for defining HTML which is called the \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FDocument_type_definition\"\u003EDocument Type Definition (DTD)\u003C\u002Fa\u003E. I will not be going too much into detail about how this is done but the main reasons for this are:\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003EThe forgiving nature of the language.\u003C\u002Fli\u003E\n\u003Cli\u003EThe fact that browsers have traditional error tolerance to support well known cases of invalid HTML.\u003C\u002Fli\u003E\n\u003Cli\u003EThe parsing process is reentrant. For other languages, the source doesn't change during parsing, but in HTML, dynamic code (such as script elements containing document.write() calls) can add extra tokens, so the parsing process actually modifies the input.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003EUnable to use the regular parsing techniques, browsers create custom parsers for parsing HTML.\u003C\u002Fp\u003E\n\n\u003Cp\u003EThe parsing algorithm is described in detail by the \u003Ca href=\"https:\u002F\u002Fhtml.spec.whatwg.org\u002Fmultipage\u002Fparsing.html\"\u003EHTML5 specification\u003C\u002Fa\u003E. As previously mentioned, the algorithm consists of two stages: tokenization and tree construction.\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cstrong\u003ETokenization\u003C\u002Fstrong\u003E is the lexical analysis, parsing the input into tokens. Among HTML tokens are start tags, end tags, attribute names and attribute values.\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cstrong\u003ETree construction\u003C\u002Fstrong\u003E is essentially creating a tree based of the parsed tokens and what we will be focusing on‚ÄîThe DOM tree.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003EThe DOM tree describes the content of the document. The \u003Ccode\u003E&lt;html&gt;\u003C\u002Fcode\u003E element is the first tag and root node of the document tree. The tree reflects the relationships and hierarchies between different tags. Tags nested within other tags are child nodes. The greater the number of DOM nodes, the longer it takes to construct the DOM tree. Below you can find a visual representation of the DOM tree‚ÄîThe output of the parser:\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--o22o5uQD--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fk2ovvtmkybu182f1ak2b.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--o22o5uQD--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fk2ovvtmkybu182f1ak2b.png\" alt=\"\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#\" title=\"DOM tree\"\u003E\u003Cfigcaption\u003EPart of the DOM Tree\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EWhen the parser finds non-blocking resources, such as an image, the browser will request those resources and continue parsing. Parsing can continue when a CSS file is encountered, but \u003Ccode\u003E&lt;script&gt;\u003C\u002Fcode\u003E tags‚Äîparticularly those without an async or defer attribute‚Äîblock rendering, and pause the parsing of HTML. Though the browser's preload scanner hastens this process, excessive scripts can still be a significant bottleneck.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"building-the-cssom-tree\" href=\"#building-the-cssom-tree\"\u003E\n  \u003C\u002Fa\u003E\n  Building the CSSOM tree\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EThe second step is processing CSS and building the CSSOM tree. In a similar fashion to the DOM parsing phase, the browser goes through each rule set in the CSS, creating a tree of nodes with parent, child, and sibling relationships based on the CSS selectors.\u003C\u002Fp\u003E\n\n\u003Cp\u003EIn regards to parsing, well, unlike HTML, CSS is a context free grammar and can be parsed using regular CFG parsing techniques. In fact the \u003Ca href=\"https:\u002F\u002Fwww.w3.org\u002FTR\u002FCSS21\u002Fgrammar.html\"\u003ECSS specification defines CSS lexical and syntax grammar\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\n\u003Cp\u003EAs with HTML, the browser needs to convert the received CSS rules into something it can work with. From there, it repeats the HTML-to-object process, but for the CSS.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"combining-the-trees-into-the-render-tree\" href=\"#combining-the-trees-into-the-render-tree\"\u003E\n  \u003C\u002Fa\u003E\n  Combining the trees into the render tree\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EThe CSSOM and DOM trees are combined into a render tree, which is then used to compute the layout of each visible element and serves as an input to the paint process that renders the pixels to screen.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--EC1yfdjR--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fz6lpm4e05fws0naziz4p.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--EC1yfdjR--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fz6lpm4e05fws0naziz4p.png\" alt=\"\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"HERE%20LINK\" title=\"DOM + CSSOM\"\u003E\u003Cfigcaption\u003ECombining the CSSOM + DOM trees to make the render tree\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003ETo construct the render tree, the browser roughly does the following:\u003C\u002Fp\u003E\n\n\u003Col\u003E\n\u003Cli\u003EStarting at the root of the DOM tree, traverse each visible node.\n\n\u003Cul\u003E\n\u003Cli\u003ESome nodes are not visible (for example, script tags, meta tags, and so on), and are omitted since they are not reflected in the rendered output.\u003C\u002Fli\u003E\n\u003Cli\u003ESome nodes are hidden via CSS and are also omitted from the render tree; for example, the span node‚Äîin the example above‚Äîis missing from the render tree because we have an explicit rule that sets the \"display: none\" property on it.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003EFor each visible node, find the appropriate matching CSSOM rules and apply them.\u003C\u002Fli\u003E\n\u003Cli\u003EEmit visible nodes with content and their computed styles. \u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\n\u003Cp\u003EThe final output is a render that contains both the content and style information of all the visible content on the screen. With the render tree in place, we can proceed to the \"layout\" stage.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"preload-scanner\" href=\"#preload-scanner\"\u003E\n  \u003C\u002Fa\u003E\n  Preload Scanner\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EWhile the browser's main thread is busing building the DOM tree it has a helper worker scan through the content available. This helper is the \u003Ca href=\"https:\u002F\u002Fariya.io\u002F2013\u002F04\u002Fcss-preload-scanner-in-webkit\"\u003Epreload scanner\u003C\u002Fa\u003E and will prepare high priority fetch request for resources like CSS, JavaScript, and web fonts. This is an optimization added over the parsing stage as it would take far too long to make these requests as the parser finds references to them.\u003Cbr\u003E\n\u003C\u002Fp\u003E\n\n\u003Cdiv class=\"highlight js-code-highlight\"\u003E\n\u003Cpre class=\"highlight html\"\u003E\u003Ccode\u003E\u003Cspan class=\"nt\"\u003E&lt;link\u003C\u002Fspan\u003E \u003Cspan class=\"na\"\u003Erel=\u003C\u002Fspan\u003E\u003Cspan class=\"s\"\u003E\"stylesheet\"\u003C\u002Fspan\u003E \u003Cspan class=\"na\"\u003Esrc=\u003C\u002Fspan\u003E\u003Cspan class=\"s\"\u003E\"styles.css\"\u003C\u002Fspan\u003E\u003Cspan class=\"nt\"\u003E\u002F&gt;\u003C\u002Fspan\u003E\n\u003Cspan class=\"nt\"\u003E&lt;script \u003C\u002Fspan\u003E\u003Cspan class=\"na\"\u003Esrc=\u003C\u002Fspan\u003E\u003Cspan class=\"s\"\u003E\"myscript.js\"\u003C\u002Fspan\u003E \u003Cspan class=\"na\"\u003Easync\u003C\u002Fspan\u003E\u003Cspan class=\"nt\"\u003E&gt;&lt;\u002Fscript&gt;\u003C\u002Fspan\u003E\n\u003Cspan class=\"nt\"\u003E&lt;img\u003C\u002Fspan\u003E \u003Cspan class=\"na\"\u003Esrc=\u003C\u002Fspan\u003E\u003Cspan class=\"s\"\u003E\"myimage.jpg\"\u003C\u002Fspan\u003E \u003Cspan class=\"na\"\u003Ealt=\u003C\u002Fspan\u003E\u003Cspan class=\"s\"\u003E\"image description\"\u003C\u002Fspan\u003E\u003Cspan class=\"nt\"\u003E\u002F&gt;\u003C\u002Fspan\u003E\n\u003Cspan class=\"nt\"\u003E&lt;script \u003C\u002Fspan\u003E\u003Cspan class=\"na\"\u003Esrc=\u003C\u002Fspan\u003E\u003Cspan class=\"s\"\u003E\"anotherscript.js\"\u003C\u002Fspan\u003E \u003Cspan class=\"na\"\u003Easync\u003C\u002Fspan\u003E\u003Cspan class=\"nt\"\u003E&gt;&lt;\u002Fscript&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cdiv class=\"highlight__panel js-actions-panel\"\u003E\n\u003Cdiv class=\"highlight__panel-action js-fullscreen-code-action\"\u003E\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"\u003E\u003Ctitle\u003EEnter fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"\u003E\u003Ctitle\u003EExit fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\n\n\n\u003Cp\u003ETaking the example above, the preload scanner will try to find the scripts and images, and start downloading them. There are ways to communicate to the preload scanner via the html‚Äîthe attributes: \u003Ccode\u003Easync\u003C\u002Fcode\u003E and \u003Ccode\u003Edefer\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Ccode\u003Easync\u003C\u002Fcode\u003E: When present, it specifies that the script will be executed asynchronously as soon as it is available.\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Ccode\u003Edefer\u003C\u002Fcode\u003E: When present, it specifies that the script is executed when the page has finished parsing.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003EWaiting to obtain CSS doesn't block HTML parsing or downloading, but it does block JavaScript, because JavaScript is often used to query CSS properties‚Äô impact on elements.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"javascript-compilation\" href=\"#javascript-compilation\"\u003E\n  \u003C\u002Fa\u003E\n  JavaScript Compilation\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EWhile the CSS is being parsed and the CSSOM created, other assets, including JavaScript files, are downloading (thanks to the preload scanner). JavaScript is interpreted, compiled, parsed and executed. \u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--LL_sktK---\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F0pdfl3y8t9d7vm2qaxlg.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--LL_sktK---\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F0pdfl3y8t9d7vm2qaxlg.png\" alt=\"\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"https:\u002F\u002Fv8.dev\u002Fblog\u002Fbackground-compilation\" title=\"TITLE\"\u003E\u003Cfigcaption\u003EOverview of the JS compilation process\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EThe scripts are parsed into \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FAbstract_syntax_tree\"\u003Eabstract syntax trees\u003C\u002Fa\u003E. Like in the above diagram (from V8's engine blog), some browser engines take the Abstract Syntax Tree and pass it into an interpreter, outputting bytecode which is executed on the main thread. This is known as JavaScript compilation.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"building-the-accessibility-tree\" href=\"#building-the-accessibility-tree\"\u003E\n  \u003C\u002Fa\u003E\n  Building the Accessibility Tree\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EThe browser also builds an accessibility tree that assistive devices use to parse and interpret content. The \u003Ca href=\"https:\u002F\u002Fwicg.github.io\u002Faom\u002Fexplainer.html\"\u003Eaccessibility object model (AOM)\u003C\u002Fa\u003E is like a semantic version of the DOM. The browser updates the accessibility tree when the DOM is updated. The accessibility tree is not modifiable by assistive technologies themselves.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--QoKHXBl2--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fa4e181v8hq7vmuvdegh5.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--QoKHXBl2--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fa4e181v8hq7vmuvdegh5.png\" alt=\"\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#\" title=\"AOM\"\u003E\u003Cfigcaption\u003EBuild and use process of the AOM\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EUntil the AOM is built, the content is not accessible to screen readers.\u003C\u002Fp\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"rendering\" href=\"#rendering\"\u003E\n  \u003C\u002Fa\u003E\n  Rendering\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003ENow that the information has been parsed the browser can begin to display it. To achieve this the browser will now use the render tree to produce a visual representation of the document. Rendering steps include layout, paint and, in some cases, compositing.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"critical-rendering-path\" href=\"#critical-rendering-path\"\u003E\n  \u003C\u002Fa\u003E\n  Critical Rendering Path\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003ENow is a good time to introduce the notion of the \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FPerformance\u002FCritical_rendering_path\"\u003ECritical Rendering Path\u003C\u002Fa\u003E. The best way to visualise it is with a diagram:\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--Khk7ZCIC--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F081c6qn9jf63g3038yt5.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--Khk7ZCIC--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F081c6qn9jf63g3038yt5.png\" alt=\"\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"https:\u002F\u002Fguillermo.at\u002Fbrowser-critical-render-path\" title=\"CRP\"\u003E\u003Cfigcaption\u003EThe Critical Rendering Path\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EOptimizing the critical rendering path improves the time to first render. It is important to ensure reflows and repaints can happen at the \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FFrame_Timing_API\"\u003Egoal of 60 frames per second\u003C\u002Fa\u003E (for performant user interactions).\u003C\u002Fp\u003E\n\n\u003Cp\u003EWe wont be going into detail on how to optimise the CRP but the general gist relies on improving page load speed by prioritizing which resources get loaded, controlling the order in which they are loaded, and reducing the file sizes of those resources.\u003C\u002Fp\u003E\n\n\u003Cp\u003ENow let's move on to the rendering stages.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"layout\" href=\"#layout\"\u003E\n  \u003C\u002Fa\u003E\n  Layout\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003ELayout is the first rendering stage, where the geometry and positioning of the render tree nodes are determined. Once the render tree is built, the layout commences. \u003C\u002Fp\u003E\n\n\u003Cp\u003ELayout is a recursive process. It begins at the root renderer, which corresponds to the \u003Ccode\u003E&lt;html&gt;\u003C\u002Fcode\u003E element of the HTML document. Layout continues recursively through some or all of the frame hierarchy, computing geometric information for each renderer that requires it. \u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--lsnGXqy4--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F5t8ph12snekwblpjyf89.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--lsnGXqy4--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F5t8ph12snekwblpjyf89.png\" alt=\"\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#\" title=\"Layout\"\u003E\u003Cfigcaption\u003ELayout stage\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EAt the end of the layout stage, a tree similar to the one above is generated with what we call blocks\u002FCoxes as nodes. Blocks\u002FBoxes hold the geometric information of DOM objects and nodes.\u003C\u002Fp\u003E\n\n\u003Ch5\u003E\n  \u003Ca name=\"dirty-bit-system\" href=\"#dirty-bit-system\"\u003E\n  \u003C\u002Fa\u003E\n  Dirty bit system\n\u003C\u002Fh5\u003E\n\n\u003Cp\u003EIn order not to do a full layout for every small change, browsers use a \"dirty bit\" system. A renderer that is changed or added marks itself and its children as \"dirty\": needing layout.\u003C\u002Fp\u003E\n\n\u003Cp\u003EThere are two flags: \u003Cbr\u003E\n    - \u003Cstrong\u003Edirty:\u003C\u002Fstrong\u003E node needs a layout.\u003Cbr\u003E\n    - \u003Cstrong\u003Echildren are dirty:\u003C\u002Fstrong\u003E node has at least one child that needs a layout.\u003C\u002Fp\u003E\n\n\u003Ch5\u003E\n  \u003Ca name=\"layout-algorithm\" href=\"#layout-algorithm\"\u003E\n  \u003C\u002Fa\u003E\n  Layout Algorithm\n\u003C\u002Fh5\u003E\n\n\u003Cp\u003EUsing the dirty bit system browsers can now perform an algorithm to generate the layout. A high level abstraction of that algorithm is as folows:\u003C\u002Fp\u003E\n\n\u003Col\u003E\n\u003Cli\u003EParent node determines its own width.\u003C\u002Fli\u003E\n\u003Cli\u003EParent goes over children and:\n\n\u003Col\u003E\n\u003Cli\u003ECalculate child render's size\u003C\u002Fli\u003E\n\u003Cli\u003ECalls child layout if they have a dirty descendant\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\n\n\u003C\u002Fli\u003E\n\u003Cli\u003EParent uses children's accumulative heights and the heights of margins and padding to set its own height‚Äìthis will be used by the parent renderer's parent.\u003C\u002Fli\u003E\n\u003Cli\u003ESets its dirty bit to false.\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\n\u003Cp\u003EAn added important concept is that of \u003Cstrong\u003Ereflow\u003C\u002Fstrong\u003E. As previously mentioned, the first time the size and position of nodes are determined is called \u003Cstrong\u003Elayout\u003C\u002Fstrong\u003E. Subsequent recalculations of node size and locations are called \u003Cstrong\u003Ereflows\u003C\u002Fstrong\u003E. As an example, suppose the initial layout occurs before the image is returned. Since we didn't declare the size of our image, there will be a reflow once the image size is known!\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"paint\" href=\"#paint\"\u003E\n  \u003C\u002Fa\u003E\n  Paint\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EThe third and last stage of rendering. In this painting phase, the browser converts each box calculated in the layout phase to actual pixels on the screen. Painting involves drawing every visual part of an element to the screen, including text, colours, borders, shadows, and replaced elements like buttons and images. The browser needs to do this super quickly.\u003C\u002Fp\u003E\n\n\u003Ch5\u003E\n  \u003Ca name=\"painting-order\" href=\"#painting-order\"\u003E\n  \u003C\u002Fa\u003E\n  Painting order\n\u003C\u002Fh5\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fwww.w3.org\u002FTR\u002FCSS21\u002Fzindex.html\"\u003ECSS2 defines the order of the painting process\u003C\u002Fa\u003E. This is actually the order in which the elements are stacked in the stacking contexts. This order affects painting since the stacks are painted from back to front. The stacking order of a block renderer is:\u003C\u002Fp\u003E\n\n\u003Col\u003E\n\u003Cli\u003Ebackground colour\u003C\u002Fli\u003E\n\u003Cli\u003Ebackground image\u003C\u002Fli\u003E\n\u003Cli\u003Eborder\u003C\u002Fli\u003E\n\u003Cli\u003Echildren\u003C\u002Fli\u003E\n\u003Cli\u003Eoutline\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\n\u003Ch5\u003E\n  \u003Ca name=\"paint-layers\" href=\"#paint-layers\"\u003E\n  \u003C\u002Fa\u003E\n  Paint Layers\n\u003C\u002Fh5\u003E\n\n\u003Cp\u003EPainting can break the elements in the layout tree into layers. Promoting content into layers on the GPU (instead of the main thread on the CPU) improves paint and repaint performance. There are specific properties and elements that instantiate a layer, including \u003Ccode\u003E&lt;video&gt;\u003C\u002Fcode\u003E and \u003Ccode\u003E&lt;canvas&gt;\u003C\u002Fcode\u003E, and any element which has the CSS properties of opacity, a 3D transform, will-change, and a few others. These nodes will be painted onto their own layer, along with their descendants, unless a descendant necessitates its own layer for one (or more) of the above reasons.\u003C\u002Fp\u003E\n\n\u003Cp\u003ELayers do improve performance but are expensive when it comes to memory management, so should not be overused as part of web performance optimization strategies.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"compositing\" href=\"#compositing\"\u003E\n  \u003C\u002Fa\u003E\n  Compositing\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EWhen sections of the document are drawn in different layers, overlapping each other, compositing is necessary to ensure they are drawn to the screen in the right order and the content is rendered correctly.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--1DqsUvMc--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fr33bwf2r09f27t73az2n.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--1DqsUvMc--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fr33bwf2r09f27t73az2n.png\" alt=\"\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#\" title=\"Compositing\"\u003E\u003Cfigcaption\u003ECompositing stage\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EAs the page continues to load assets, reflows can happen (\u003Ca href=\"#overview-of-layout-process\"\u003Erecall our example image that arrived late\u003C\u002Fa\u003E).  A reflow sparks a repaint and a re-composite. Had we defined the size of our image, no-reflow would have been necessary, and only the layer that needed to be repainted would be repainted, and composited if necessary. But we didn't include the image size! When the image is obtained from the server, the rendering process goes back to the layout steps and restarts from there.\u003C\u002Fp\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"finalising\" href=\"#finalising\"\u003E\n  \u003C\u002Fa\u003E\n  Finalising\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003EOnce the main thread is done painting the page, you would think we would be \"all set.\" That isn't necessarily the case. If the load includes JavaScript, which was correctly deferred, and only executed after the onload event fires, the main thread might be busy, and not available for scrolling, touch, and other interactions.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"javascript-occupied\" href=\"#javascript-occupied\"\u003E\n  \u003C\u002Fa\u003E\n  JavaScript Occupied\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fweb.dev\u002Finteractive\u002F\"\u003ETime to Interactive (TTI)\u003C\u002Fa\u003E is the measurement of how long it took from that first request which led to the DNS lookup and SSL connection to when the page is interactive‚Äîinteractive being the point in time after the \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FGlossary\u002FFirst_contentful_paint\"\u003EFirst Contentful Paint\u003C\u002Fa\u003E when the page responds to user interactions within 50ms. If the main thread is occupied parsing, compiling, and executing JavaScript, it is not available and therefore not able to respond to user interactions in a timely (\u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FPerformance\u002FHow_long_is_too_long\"\u003Eless than 50ms\u003C\u002Fa\u003E) fashion.\u003C\u002Fp\u003E\n\n\u003Cp\u003EIn our example, maybe the image loaded quickly, but perhaps the anotherscript.js file was 2MB and our user's network connection was slow.  In this case, the user would see the page super quickly, but wouldn't be able to scroll without jank until the script was downloaded, parsed and executed. That is not a good user experience. Avoid occupying the main thread, as demonstrated in this WebPageTest example:\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--1V0GkrV---\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fxbkoby5bedm789lskzyb.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--1V0GkrV---\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fxbkoby5bedm789lskzyb.png\" alt=\"\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003Ca href=\"#\" title=\"TITLE\"\u003E\u003Cfigcaption\u003EExample - JavaScript hogging main thread\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EIn this example, the DOM content load process took over 1.5 seconds, and the main thread was fully occupied that entire time, unresponsive to click events or screen taps.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"the-user-can-now-browse-the-page\" href=\"#the-user-can-now-browse-the-page\"\u003E\n  \u003C\u002Fa\u003E\n  The user can now browse the page! üéâ\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EYes, after all these stages the user can now both see and interact with the page!\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"summary\" href=\"#summary\"\u003E\n  \u003C\u002Fa\u003E\n  Summary\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EFor a simple page to be displayed in our browser window it may need to go through:\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003EDNS Lookup: To find out the ip of the web address.\u003C\u002Fli\u003E\n\u003Cli\u003ETCP Handshake: To set up TCP\u002FIP communication between the client and server for the susbsequent steps.\u003C\u002Fli\u003E\n\u003Cli\u003ETLS Handshake: To safeguard the information that will be sent via encryption.\u003C\u002Fli\u003E\n\u003Cli\u003EHTTP communication: To establish a method of communication that browsers can understand.\u003C\u002Fli\u003E\n\u003Cli\u003EBrowser Parsing: To parse the HTTP's response‚Äîthe document of the page to be displayed.\u003C\u002Fli\u003E\n\u003Cli\u003EBrowser Rendering: To render the document on the browsers window.\u003C\u002Fli\u003E\n\u003Cli\u003EJavascript Occupied: To wait for JS to compile and execute as it may hog the main thread.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003EIt is incredible the number of things that happen for this seemingly simple task to be accomplished. Truly an impressive journey for our little page :)\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"there-is-more\" href=\"#there-is-more\"\u003E\n  \u003C\u002Fa\u003E\n  There is more...\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EIn a real-world scenario, our little page may have to tackle even more obstacles before reaching its destination things such as: \u003Ca href=\"https:\u002F\u002Fwww.nginx.com\u002Fresources\u002Fglossary\u002Fload-balancing\u002F\"\u003Eload balancers, proxies\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fwww.nginx.com\u002Fresources\u002Fglossary\u002Fwhat-is-a-waf\u002F\"\u003Emultiple layers of firewalls\u003C\u002Fa\u003E, etc... \u003C\u002Fp\u003E\n\n\u003Cp\u003EThese topics are beasts of their own and if you're curious about how they work I recommend looking them up! Perhaps i'll write something for them in the future.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EThank you for reading,\u003Cbr\u003E\nPaulo üòé\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"reference\" href=\"#reference\"\u003E\n  \u003C\u002Fa\u003E\n  Reference\n\u003C\u002Fh2\u003E\n\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FPerformance\u002FHow_browsers_work#overview\"\u003Ehttps:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FPerformance\u002FHow_browsers_work#overview\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.html5rocks.com\u002Fen\u002Ftutorials\u002Finternals\u002Fhowbrowserswork\"\u003Ehttps:\u002F\u002Fwww.html5rocks.com\u002Fen\u002Ftutorials\u002Finternals\u002Fhowbrowserswork\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fdevelopers.google.com\u002Fweb\u002Ffundamentals\u002F\"\u003Ehttps:\u002F\u002Fdevelopers.google.com\u002Fweb\u002Ffundamentals\u002F\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fblog.cloudflare.com\u002Fintroducing-0-rtt\u002F\"\u003Ehttps:\u002F\u002Fblog.cloudflare.com\u002Fintroducing-0-rtt\u002F\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fblog.cloudflare.com\u002Fkeyless-ssl-the-nitty-gritty-technical-details\u002F\"\u003Ehttps:\u002F\u002Fblog.cloudflare.com\u002Fkeyless-ssl-the-nitty-gritty-technical-details\u002F\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fcommunity.fs.com\u002Fblog\u002Ftcpip-vs-osi-whats-the-difference-between-the-two-models.html\"\u003Ehttps:\u002F\u002Fcommunity.fs.com\u002Fblog\u002Ftcpip-vs-osi-whats-the-difference-between-the-two-models.html\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.sciencedirect.com\u002Ftopics\u002Fcomputer-science\u002Fthree-way-handshake\"\u003Ehttps:\u002F\u002Fwww.sciencedirect.com\u002Ftopics\u002Fcomputer-science\u002Fthree-way-handshake\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fv8.dev\u002Fblog\u002Fbackground-compilation\"\u003Ehttps:\u002F\u002Fv8.dev\u002Fblog\u002Fbackground-compilation\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.smashingmagazine.com\u002F2016\u002F12\u002Fgpu-animation-doing-it-right\u002F\"\u003Ehttps:\u002F\u002Fwww.smashingmagazine.com\u002F2016\u002F12\u002Fgpu-animation-doing-it-right\u002F\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n";a.body_markdown="This article covers the processes that happen in-between a user entering a web address in a browser and a web page showing up as a result.\n\n## Overview\nIf you're like me‚Äîif you like to understand the tools you work with‚ÄîI hope this article helps you learn something you did not know before. Let's get started!\n\nThere are a handful of steps that occur between the time a user requests a web page and the time it displays in their browser. I've divided these steps into the following sections:\n1. [**Navigation**](#navigation)\n    - Resolving the web address (DNS Lookup)\n    - Establishing a connection to the server (TCP 3-way handshake)\n    - Establishing a security protocol (TLS negotiation)\n2. [**Fetching**](#fetching)\n    - HTTP request\n    - HTTP response\n3. [**Parsing**](#parsing)\n    - Building the DOM tree\n    - Building the CSSOM tree\n    - Combining the trees into the render tree\n    - Preload Scanner\n    - JavaScript Compilation\n    - Building the Accessibility Tree\n4. [**Rendering**](#rendering)\n    - Critical Rendering Path\n    - Layout\n    - Paint\n    - Compositing\n5. [**Finalising**](#finalising)\n    - JavaScript Occupied.\n    - User can now browse the page!\n\nUse this section to jump to any particular section of interest. However, if you're new to some of these concepts‚Äîstay here. It is time for a quick background lesson.\n\n## Background\nThis section contains a quick and general overview of the core background concepts that are required to understand the later parts of the article. You may skip this section if you're already familiar with them!\n\n### Networking models\nModels exist to explain how data is transmitted through a network. In particular, there exists a network model so widely known that even those that do not partake in *hackerman* things might've heard of! We call it the Open Systems Interconnected (OSI) model. Here it goes:\n\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fsx08iepkwc18o55nwx9s.png\" alt=\"The OSI Model\"\u003E\u003Ca href=\"https:\u002F\u002Fcommunity.fs.com\u002Fblog\u002Ftcpip-vs-osi-whats-the-difference-between-the-two-models.html\" title=\"foo\"\u003E\u003Cfigcaption\u003EThe OSI Model\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Ffigure\u003E\n \n[The Open Systems Interconnection (OSI) model](https:\u002F\u002Fwww.iso.org\u002Fics\u002F35.100\u002Fx\u002F) describes seven layers that computer systems use to communicate over a network. Each upper layer is one level of abstraction higher than the previous, all the way up to the application (browser) layer which we will be talking about.\n\nIt‚Äôs important to note that the OSI model is a ‚Äúconceptual model‚Äù for how applications communicate over a network. It is not a protocol. Do not get the two confused. Protocols are strict sets of rules that may live within these layers.\n\nAn older and very similar model, and more relevant to the article, is the [TCP\u002FIP model](https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FInternet_protocol_suite). This model is used for both modelling current Internet architecture and providing a set of rules that are followed by all forms of transmission over the network.\n\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fd4qicoy7basi6gd4joxr.png\" alt=\"\"\u003E\u003Ca href=\"https:\u002F\u002Fcommunity.fs.com\u002Fblog\u002Ftcpip-vs-osi-whats-the-difference-between-the-two-models.html\" title=\"OSI vs TCP\u002FIP\"\u003E\u003Cfigcaption\u003EOSI vs TCP\u002FIP\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Ffigure\u003E\n \nI will be referring to this model and its associated protocols throughout the article.\n\nAs hinted at before, any data sent from an application to another will have to travel up and down through these layers a few numbers of times (depending on how many middle men there are). Of course, this happens incredibly fast nowadays, however, it still does happen and understanding the overview of the process is something that every developer should know. The following is an image representation of this process between a server and a client application:\n\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F24o98vnamwefnr850216.png\" alt=\"\"\u003E\u003Ca href=\"https:\u002F\u002Fcommunity.fs.com\u002Fblog\u002Ftcpip-vs-osi-whats-the-difference-between-the-two-models.html\" title=\"TCP\u002FIP data travel\"\u003E\u003Cfigcaption\u003ETCP\u002FIP model data path between applications\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Ffigure\u003E\n\nTake our example, a user requesting to browse a page using a browser: the request is first sent to the application layer, where it is processed from layer to layer down with each layer performing its designated functions. The data is then transmitted over the physical layer of the network until the destination server or another device receives it. At this point the data is passed up through the layers again, each layer performing its assigned operations until the data is used by the web server software. This process is repeated again for the response of the server. This is how machines communicate.\n\n### High-level abstraction of a browser\nThe later sections of the article will be covering how a typical browser displays the content of a page on screen. A high-level understanding of the browser is important when reading those sections. I will be referencing some of the following browser components:\n\n1. **The user interface:** this includes the address bar, back\u002Fforward button, bookmarking menu, etc. Every part of the browser display except the window where you see the requested page.\n2. **The browser engine:** marshals actions between the UI and the rendering engine.\n3. **The rendering engine:** responsible for displaying requested content. For example, if the requested content is HTML, the rendering engine parses HTML and CSS, and displays the parsed content on the screen.\n4. **Networking:** for network calls such as HTTP requests, using different implementations for different platforms behind a platform-independent interface.\n5. **UI backend:** used for drawing basic widgets like combo boxes and windows. This backend exposes a generic interface that is not platform-specific. Underneath it uses operating system user interface methods.\n6. **JavaScript interpreter:** Used to parse and execute JavaScript code.\n7. **Data storage:** This is a persistence layer. The browser may need to save all sorts of data locally, such as cookies. Browsers also support storage mechanisms such as localStorage, IndexedDB, WebSQL and FileSystem.\n\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fivei7zfohim9n6l83bbk.png\" alt=\"\"\u003E\u003Ca href=\"https:\u002F\u002Fwww.html5rocks.com\u002Fen\u002Ftutorials\u002Finternals\u002Fhowbrowserswork\u002F\" title=\"Browser Components\"\u003E\u003Cfigcaption\u003EBrowser Components\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Ffigure\u003E\n\nIt is important to note that browsers such as Chrome have a multi-process approach for performance and security reasons. This means that they run instances of some of these components, such as the rendering engine, for each tab (each tab is a separate process). You can find proof of this by checking chrome's processes in a task manager.\n\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fwv6sub7wk7fxyi25j1yh.png\" alt=\"\"\u003E\u003Ca href=\"#\" title=\"Task manager chrome\"\u003E\u003Cfigcaption\u003EScreenshot of Chrome's Task Manager\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Ffigure\u003E\n\nAs you can observe from the screenshot above, each tab has a process priority and CPU\u002FNetwork\u002FGPU statistics implying that they work like normal processes. That is because they do! You can further confirm this by listing your OS's processes and you will surely find them there.\n\nTo conclude this background section, it is important to note that what you just read so far in is a **very** high-level generalisation and abstraction of how networks and browsers actually work. Not all networks strictly abide by the OSI\u002FTCP IP models and the main browsers in use today are all different in their own ways but share a common base of concepts that allows us to abstract them to what you've just read. \n- For browsers, as an exmaple, they all follow (to some degree) the specifications maintained by the [W3C (World Wide Web Consortium) organization](https:\u002F\u002Fwww.w3.org\u002F), which is the standards organization for the web. However, their rendering engines are different, Internet Explorer uses Trident, Firefox uses Gecko, Safari uses WebKit. Chrome, Edge and Opera use Blink, a fork of WebKit.\n\n## Journey of a page\nYou open up a browser and type in www.google.com. This is what happens.\n\n### Navigation\nThe first step is navigating to the correct place. Navigating to a web page is finding where the assets for that page are located. To us, web pages are simply domain names, but to computers they resolve into IP addresses.\n\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F3l0quvd7dcsg97hbfmfu.png\" alt=\"\"\u003E\u003Ca href=\"#\" title=\"Domain \u003C-\u003E IP\"\u003E\u003Cfigcaption\u003E \u003C-\u003E IP\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Ffigure\u003E\n \nIf you navigate to www.google.com, the page resources will be located on a server with an IP address such as 93.184.216.34 (of sorts). If you‚Äôve never visited this site, a Domain Name System (DNS) lookup must happen.\n\n##### Round Trip Time\n[Round-trip time (RTT)](https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FRound-trip_delay) is the duration, measured in milliseconds, from when a browser sends a request to when it receives a response from a server. It's a key performance metric for web applications and one of the main factors, along with [Time to First Byte (TTFB)](https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FGlossary\u002Ftime_to_first_byte), when measuring page load time and network latency.\n\nI will be annotating each network process with their corresponding RTT.\n\n#### Resolving a web address - The DNS Process (O RTT)\nAn overview of the DNS process for `www.google.com` is as follows:\n1. Check browser & OS cache, return if IP found.\n2. Browser sends out a request asking for a DNS resolver. \n    1. DNS resolver checks its cache, return if IP is found.\n3. DNS resolver sends out a request asking root nameservers.\n5. A root nameserver responds to the DNS resolver with an IP address to a TLD nameserver (in this case the TLD for extensions of `.com`).\n6. DNS resolver sends out another request, now to the TLD nameserver, asking if they know what the IP is.\n7. TLD nameserver responds back to the DNS resolver with an IP of the authoritative nameserver.\n8. DNS resolver sends out the final request to the authoritative nameserver asking for the IP.\n9. The authoritative nameserver will scan zones files to find the domainname:ipaddress mapping and will return whether it exists or not to the DNS resolver.\n10. Finally, the DNS resolver will now respond back to the browser with the IP of the server the browser is trying to communicate.\n\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fhglrqe8nj9us42fuxs8d.png\" alt=\"\"\u003E\u003Ca href=\"https:\u002F\u002Fyoutu.be\u002FvrxwXXytEuI\" title=\"TITLE\"\u003E\u003Cfigcaption\u003EVisualisation of the DNS process\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Ffigure\u003E\n\nNote that this process is usually incredibly fast and rarely follows through in its entirety because of all the layers of caching. It was designed to be fast!\n\n#### Establishing a connection to the server - TCP Handshake (1 RTT)\nNow that the IP address is known, the browser sets up a connection to the server via a [TCP three-way handshake](https:\u002F\u002Fwww.sciencedirect.com\u002Ftopics\u002Fcomputer-science\u002Fthree-way-handshake).\n\n[TCP](https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FTransmission_Control_Protocol) uses a three-way handshake to establish a reliable connection. The connection is full-duplex, and both sides synchronize (SYN) and acknowledge (ACK) each other. The exchange of these four flags is performed in three steps‚ÄîSYN, SYN-ACK, and ACK‚Äîas shown in\n\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fdn8y466ruwdfllwwtaig.png\" alt=\"\"\u003E\u003Ca href=\"https:\u002F\u002Fwww.sciencedirect.com\u002Ftopics\u002Fcomputer-science\u002Fthree-way-handshake\" title=\"TCP Handskae\"\u003E\u003Cfigcaption\u003ETCP 3-way handshake\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Ffigure\u003E\n\n1. The client chooses an initial sequence number, set in the first SYN packet. \n2. The server also chooses its own initial sequence number. \n3. Each side acknowledges the other's sequence number by incrementing it; this is the acknowledgement number.\n\nOnce a connection is established, ACKs typically follow for each segment. The connection will eventually end with an RST (reset or tear down the connection) or FIN (gracefully end the connection).\n \nThis mechanism is designed so that two entities attempting to communicate, in this case, the browser and web server, can negotiate the parameters of the network TCP socket connection before transmitting data, in our case, it will be over HTTPS‚Äîthe secure version of [HTTP](https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FHTTP).\n\nHTTPS is HTTP with encryption. The only difference between the two protocols is that HTTPS uses [TLS (SSL)](https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FTransport_Layer_Security) to encrypt normal HTTP requests and responses. As a result, HTTPS provides a solid layer of security over HTTP. A website that uses HTTP has `http:\u002F\u002F` in its URL, while a website that uses HTTPS has `https:\u002F\u002F`.\n\n#### Establishing a security protocol - TLS Negotiation (~2 RTT)\nFor secure connections established over HTTPS, another \"handshake\" is required. This handshake, or rather the TLS negotiation, determines which cypher will be used to encrypt the communication, verifies the server, and establishes that a secure connection is in place before beginning the actual transfer of data.\n\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fmuxmc254vu339latlf61.png\" alt=\"\"\u003E\u003Ca href=\"https:\u002F\u002Fblog.cloudflare.com\u002Fkeyless-ssl-the-nitty-gritty-technical-details\u002F\" title=\"TSL Hanshake\"\u003E\u003Cfigcaption\u003EModern day TLS establishing\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Ffigure\u003E\n \nWhile making the connection secure adds time to the page load, a secure connection is worth the latency expense, as the data transmitted between the browser and the web server cannot normally be decrypted by a third party. TLS has come a long way and version 1.3 upwards has reduced the Round Trip Time (RTT) from 4 all the way to 2 or even 1 depending on the situation.\n\nAssuming DNS is instantaneous and adding in the HTTP fetch RTT (next section), this leaves 4 round trips before the browser can start showing the page. If you‚Äôre visiting a site you‚Äôve recently connected to, the TLS handshake phase can be shortened from 2 round trips to 1 with [TLS session resumption](https:\u002F\u002Fblog.cloudflare.com\u002Ftls-session-resumption-full-speed-and-secure\u002F).\n\n- New Connection: 4 RTT + DNS\n- Resumed Connection: 3 RTT + DNS\n\n### Fetching\nNow that we have a TCP connection setup and the TLS exchange has been completed, the browser can now begin to fetch the page's resources. It starts by fetching the markup document for the page. It does this by using the [HTTP protocol](https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FHTTP). HTTP requests are sent via TCP\u002FIP and in our case encrypted with Transport Layer Security (TLS)‚Äîsince google uses HTTPS.\n\n#### HTTP Request\nTo fetch a page an [idempotent](https:\u002F\u002Fwww.restapitutorial.com\u002Flessons\u002Fidempotency.html) (not changing the server state) request is made. We use the HTTP GET request.\n\n* `GET`‚ÄîRequests information from a given server using a [Uniform Resource Identifier (URI)](https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FUniform_Resource_Identifier). Specification [correct implementations](https:\u002F\u002Fdatatracker.ietf.org\u002Fdoc\u002Fhtml\u002Frfc7231#section-4.3.1) of  the GET method only retrieve data and do not cause changes in the source state. No matter how many times you request the same resource, you will never cause a change in state.\n\nThere are many other types of HTTP methods:\n\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fegy39l7tc3e4pm965lnq.png\" alt=\"\"\u003E\u003Ca href=\"https:\u002F\u002Fdatatracker.ietf.org\u002Fdoc\u002Fhtml\u002Frfc7231#section-8.1.3\" title=\"HTTP method types\"\u003E\u003Cfigcaption\u003EHTTP Methods as per sepecification\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Ffigure\u003E\n \nFor fetching our page we are only interested in `GET`.\n\n```\nGET \u002F HTTP\u002F2\nHost: www.google.com\nUser-Agent: Mozilla\u002F5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko\u002F20100101 Firefox\u002F89.0\nAccept: text\u002Fhtml,application\u002Fxhtml+xml,application\u002Fxml;q=0.9,image\u002Fwebp,*\u002F*;q=0.8\nAccept-Language: en-GB,en;q=0.5\nAccept-Encoding: gzip, deflate, br\nConnection: keep-alive\nUpgrade-Insecure-Requests: 1\nCache-Control: max-age=0\nTE: Trailers\n```\n\n#### HTTP Response\nOnce the webserver receives the request. It will parse the request and try to fulfil it. We assume the request is valid and the files are available. It will reply with a HTTP response, attaching the relevant headers and the contents of the requested HTML document to the body of the that response structure.\n\n```\nHTTP\u002F2 200 OK\ndate: Sun, 18 Jul 2021 00:26:11 GMT\nexpires: -1\ncache-control: private, max-age=0\ncontent-type: text\u002Fhtml; charset=UTF-8\nstrict-transport-security: max-age=31536000\ncontent-encoding: br\nserver: gws\ncontent-length: 37418\nx-xss-protection: 0\nx-frame-options: SAMEORIGIN\ndomain=www.google.com\npriority=high\nX-Firefox-Spdy: h2\n```\n*the source code of the HTML document will be in the body of the response.\n\n### Parsing\nOnce the browser receives the response, it can begin parsing the information received. Parsing is the step the browser takes to turn the data it receives over the network into the DOM and CSSOM, which is used by the renderer to paint a page to the screen.\n\nThe [Document Object Model (DOM)](https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FDocument_Object_Model) is an internal representation of the objects that comprise the structure and content of the markup (HTML in this case) document the browser just received. It represents the page so that programs can change the document structure, style, and content. \n\nThe DOM represents the document as nodes and objects. That way, programming languages can connect to the page. There are many different types of nodes in a DOM tree. An example part of the specification for the [DOM Node Interface](https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FNode) looks as follows:\n\n- `Node.ELEMENT_NODE`\n- `Node.ATTRIBUTE_NODE`\n- `Node.TEXT_NODE`\n- `Node.CDATA_SECTION_NODE`\n- `Node.PROCESSING_INSTRUCTION_NODE`\n- `Node.COMMENT_NODE`\n- `Node.DOCUMENT_NODE`\n- `Node.DOCUMENT_TYPE_NODE`\n- `Node.DOCUMENT_FRAGMENT_NODE`\n- `Node.NOTATION_NODE`\n\nThese node types cover all possible nodes in the document. Such representations help programming languages connect to the page so that they can manipulate it.\n\nTo conclude our parsing preface, we need to talk about the CSSOM. \n\nThe [CSS Object Model (CSSOM)](https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FCSS_Object_Model) is a set of APIs allowing the manipulation of CSS from JavaScript. It is much like the DOM, but for the CSS rather than the HTML. It allows users to read and modify CSS style dynamically. It is represented very similarly to the DOM, as a tree, and it will be used along with the DOM to form a render tree so that the browser can begin its rendering process. Let's find out how by going through the entire process.\n\n#### Building the DOM tree\n\nThe first step is processing the HTML markup and building the DOM tree. HTML parsing involves tokenization and tree construction. \n\nHTML may come as a surprise in the world of parsing as it cannot be parsed through conventional means as it cannot be defined by a [Context Free Grammar (CFG)](https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FContext-free_grammar). Instead, there is a formal format for defining HTML which is called the [Document Type Definition (DTD)](https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FDocument_type_definition). I will not be going too much into detail about how this is done but the main reasons for this are:\n\n- The forgiving nature of the language.\n- The fact that browsers have traditional error tolerance to support well known cases of invalid HTML.\n- The parsing process is reentrant. For other languages, the source doesn't change during parsing, but in HTML, dynamic code (such as script elements containing document.write() calls) can add extra tokens, so the parsing process actually modifies the input.\n\nUnable to use the regular parsing techniques, browsers create custom parsers for parsing HTML.\n\nThe parsing algorithm is described in detail by the [HTML5 specification](https:\u002F\u002Fhtml.spec.whatwg.org\u002Fmultipage\u002Fparsing.html). As previously mentioned, the algorithm consists of two stages: tokenization and tree construction.\n\n - **Tokenization** is the lexical analysis, parsing the input into tokens. Among HTML tokens are start tags, end tags, attribute names and attribute values.\n - **Tree construction** is essentially creating a tree based of the parsed tokens and what we will be focusing on‚ÄîThe DOM tree.\n\nThe DOM tree describes the content of the document. The `\u003Chtml\u003E` element is the first tag and root node of the document tree. The tree reflects the relationships and hierarchies between different tags. Tags nested within other tags are child nodes. The greater the number of DOM nodes, the longer it takes to construct the DOM tree. Below you can find a visual representation of the DOM tree‚ÄîThe output of the parser:\n\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fk2ovvtmkybu182f1ak2b.png\" alt=\"\"\u003E\u003Ca href=\"#\" title=\"DOM tree\"\u003E\u003Cfigcaption\u003EPart of the DOM Tree\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Ffigure\u003E\n\nWhen the parser finds non-blocking resources, such as an image, the browser will request those resources and continue parsing. Parsing can continue when a CSS file is encountered, but `\u003Cscript\u003E` tags‚Äîparticularly those without an async or defer attribute‚Äîblock rendering, and pause the parsing of HTML. Though the browser's preload scanner hastens this process, excessive scripts can still be a significant bottleneck.\n\n#### Building the CSSOM tree\n\nThe second step is processing CSS and building the CSSOM tree. In a similar fashion to the DOM parsing phase, the browser goes through each rule set in the CSS, creating a tree of nodes with parent, child, and sibling relationships based on the CSS selectors.\n\nIn regards to parsing, well, unlike HTML, CSS is a context free grammar and can be parsed using regular CFG parsing techniques. In fact the [CSS specification defines CSS lexical and syntax grammar](https:\u002F\u002Fwww.w3.org\u002FTR\u002FCSS21\u002Fgrammar.html).\n\nAs with HTML, the browser needs to convert the received CSS rules into something it can work with. From there, it repeats the HTML-to-object process, but for the CSS.\n\n#### Combining the trees into the render tree\n\nThe CSSOM and DOM trees are combined into a render tree, which is then used to compute the layout of each visible element and serves as an input to the paint process that renders the pixels to screen.\n\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fz6lpm4e05fws0naziz4p.png\" alt=\"\"\u003E\u003Ca href=\"HERE LINK\" title=\"DOM + CSSOM\"\u003E\u003Cfigcaption\u003ECombining the CSSOM + DOM trees to make the render tree\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Ffigure\u003E\n\nTo construct the render tree, the browser roughly does the following:\n\n1. Starting at the root of the DOM tree, traverse each visible node.\n    - Some nodes are not visible (for example, script tags, meta tags, and so on), and are omitted since they are not reflected in the rendered output.\n    - Some nodes are hidden via CSS and are also omitted from the render tree; for example, the span node‚Äîin the example above‚Äîis missing from the render tree because we have an explicit rule that sets the \"display: none\" property on it.\n2. For each visible node, find the appropriate matching CSSOM rules and apply them.\n3. Emit visible nodes with content and their computed styles. \n\nThe final output is a render that contains both the content and style information of all the visible content on the screen. With the render tree in place, we can proceed to the \"layout\" stage.\n\n#### Preload Scanner\nWhile the browser's main thread is busing building the DOM tree it has a helper worker scan through the content available. This helper is the [preload scanner](https:\u002F\u002Fariya.io\u002F2013\u002F04\u002Fcss-preload-scanner-in-webkit) and will prepare high priority fetch request for resources like CSS, JavaScript, and web fonts. This is an optimization added over the parsing stage as it would take far too long to make these requests as the parser finds references to them.\n\n```html\n\u003Clink rel=\"stylesheet\" src=\"styles.css\"\u002F\u003E\n\u003Cscript src=\"myscript.js\" async\u003E\u003C\u002Fscript\u003E\n\u003Cimg src=\"myimage.jpg\" alt=\"image description\"\u002F\u003E\n\u003Cscript src=\"anotherscript.js\" async\u003E\u003C\u002Fscript\u003E\n```\n\nTaking the example above, the preload scanner will try to find the scripts and images, and start downloading them. There are ways to communicate to the preload scanner via the html‚Äîthe attributes: `async` and `defer`.\n\n- `async`: When present, it specifies that the script will be executed asynchronously as soon as it is available.\n- `defer`: When present, it specifies that the script is executed when the page has finished parsing.\n\nWaiting to obtain CSS doesn't block HTML parsing or downloading, but it does block JavaScript, because JavaScript is often used to query CSS properties‚Äô impact on elements.\n\n#### JavaScript Compilation\nWhile the CSS is being parsed and the CSSOM created, other assets, including JavaScript files, are downloading (thanks to the preload scanner). JavaScript is interpreted, compiled, parsed and executed. \n\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F0pdfl3y8t9d7vm2qaxlg.png\" alt=\"\"\u003E\u003Ca href=\"https:\u002F\u002Fv8.dev\u002Fblog\u002Fbackground-compilation\" title=\"TITLE\"\u003E\u003Cfigcaption\u003EOverview of the JS compilation process\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Ffigure\u003E\n\nThe scripts are parsed into [abstract syntax trees](https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FAbstract_syntax_tree). Like in the above diagram (from V8's engine blog), some browser engines take the Abstract Syntax Tree and pass it into an interpreter, outputting bytecode which is executed on the main thread. This is known as JavaScript compilation.\n\n#### Building the Accessibility Tree\nThe browser also builds an accessibility tree that assistive devices use to parse and interpret content. The [accessibility object model (AOM)](https:\u002F\u002Fwicg.github.io\u002Faom\u002Fexplainer.html) is like a semantic version of the DOM. The browser updates the accessibility tree when the DOM is updated. The accessibility tree is not modifiable by assistive technologies themselves.\n\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fa4e181v8hq7vmuvdegh5.png\" alt=\"\"\u003E\u003Ca href=\"#\" title=\"AOM\"\u003E\u003Cfigcaption\u003EBuild and use process of the AOM\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Ffigure\u003E\n\nUntil the AOM is built, the content is not accessible to screen readers.\n\n### Rendering\nNow that the information has been parsed the browser can begin to display it. To achieve this the browser will now use the render tree to produce a visual representation of the document. Rendering steps include layout, paint and, in some cases, compositing.\n\n#### Critical Rendering Path\nNow is a good time to introduce the notion of the [Critical Rendering Path](https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FPerformance\u002FCritical_rendering_path). The best way to visualise it is with a diagram:\n\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F081c6qn9jf63g3038yt5.png\" alt=\"\"\u003E\u003Ca href=\"https:\u002F\u002Fguillermo.at\u002Fbrowser-critical-render-path\" title=\"CRP\"\u003E\u003Cfigcaption\u003EThe Critical Rendering Path\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Ffigure\u003E\n\nOptimizing the critical rendering path improves the time to first render. It is important to ensure reflows and repaints can happen at the [goal of 60 frames per second](https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FFrame_Timing_API) (for performant user interactions).\n\nWe wont be going into detail on how to optimise the CRP but the general gist relies on improving page load speed by prioritizing which resources get loaded, controlling the order in which they are loaded, and reducing the file sizes of those resources.\n\nNow let's move on to the rendering stages.\n\n#### Layout\nLayout is the first rendering stage, where the geometry and positioning of the render tree nodes are determined. Once the render tree is built, the layout commences. \n\nLayout is a recursive process. It begins at the root renderer, which corresponds to the `\u003Chtml\u003E` element of the HTML document. Layout continues recursively through some or all of the frame hierarchy, computing geometric information for each renderer that requires it. \n\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F5t8ph12snekwblpjyf89.png\" alt=\"\"\u003E\u003Ca href=\"#\" title=\"Layout\"\u003E\u003Cfigcaption\u003ELayout stage\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Ffigure\u003E\n\nAt the end of the layout stage, a tree similar to the one above is generated with what we call blocks\u002FCoxes as nodes. Blocks\u002FBoxes hold the geometric information of DOM objects and nodes.\n\n##### Dirty bit system\nIn order not to do a full layout for every small change, browsers use a \"dirty bit\" system. A renderer that is changed or added marks itself and its children as \"dirty\": needing layout.\n\nThere are two flags: \n    - **dirty:** node needs a layout.\n    - **children are dirty:** node has at least one child that needs a layout.\n\n##### Layout Algorithm\nUsing the dirty bit system browsers can now perform an algorithm to generate the layout. A high level abstraction of that algorithm is as folows:\n\n1. Parent node determines its own width.\n2. Parent goes over children and:\n    1. Calculate child render's size\n    2. Calls child layout if they have a dirty descendant\n3. Parent uses children's accumulative heights and the heights of margins and padding to set its own height‚Äìthis will be used by the parent renderer's parent.\n4. Sets its dirty bit to false.\n\nAn added important concept is that of **reflow**. As previously mentioned, the first time the size and position of nodes are determined is called **layout**. Subsequent recalculations of node size and locations are called **reflows**. As an example, suppose the initial layout occurs before the image is returned. Since we didn't declare the size of our image, there will be a reflow once the image size is known!\n\n#### Paint\nThe third and last stage of rendering. In this painting phase, the browser converts each box calculated in the layout phase to actual pixels on the screen. Painting involves drawing every visual part of an element to the screen, including text, colours, borders, shadows, and replaced elements like buttons and images. The browser needs to do this super quickly.\n\n##### Painting order\n[CSS2 defines the order of the painting process](https:\u002F\u002Fwww.w3.org\u002FTR\u002FCSS21\u002Fzindex.html). This is actually the order in which the elements are stacked in the stacking contexts. This order affects painting since the stacks are painted from back to front. The stacking order of a block renderer is:\n\n1. background colour\n2. background image\n3. border\n4. children\n5. outline\n\n##### Paint Layers\nPainting can break the elements in the layout tree into layers. Promoting content into layers on the GPU (instead of the main thread on the CPU) improves paint and repaint performance. There are specific properties and elements that instantiate a layer, including `\u003Cvideo\u003E` and `\u003Ccanvas\u003E`, and any element which has the CSS properties of opacity, a 3D transform, will-change, and a few others. These nodes will be painted onto their own layer, along with their descendants, unless a descendant necessitates its own layer for one (or more) of the above reasons.\n\nLayers do improve performance but are expensive when it comes to memory management, so should not be overused as part of web performance optimization strategies.\n\n#### Compositing\nWhen sections of the document are drawn in different layers, overlapping each other, compositing is necessary to ensure they are drawn to the screen in the right order and the content is rendered correctly.\n\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fr33bwf2r09f27t73az2n.png\" alt=\"\"\u003E\u003Ca href=\"#\" title=\"Compositing\"\u003E\u003Cfigcaption\u003ECompositing stage\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Ffigure\u003E\n\nAs the page continues to load assets, reflows can happen ([recall our example image that arrived late](#overview-of-layout-process)).  A reflow sparks a repaint and a re-composite. Had we defined the size of our image, no-reflow would have been necessary, and only the layer that needed to be repainted would be repainted, and composited if necessary. But we didn't include the image size! When the image is obtained from the server, the rendering process goes back to the layout steps and restarts from there.\n\n### Finalising\nOnce the main thread is done painting the page, you would think we would be \"all set.\" That isn't necessarily the case. If the load includes JavaScript, which was correctly deferred, and only executed after the onload event fires, the main thread might be busy, and not available for scrolling, touch, and other interactions.\n\n#### JavaScript Occupied\n[Time to Interactive (TTI)](https:\u002F\u002Fweb.dev\u002Finteractive\u002F) is the measurement of how long it took from that first request which led to the DNS lookup and SSL connection to when the page is interactive‚Äîinteractive being the point in time after the [First Contentful Paint](https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FGlossary\u002FFirst_contentful_paint) when the page responds to user interactions within 50ms. If the main thread is occupied parsing, compiling, and executing JavaScript, it is not available and therefore not able to respond to user interactions in a timely ([less than 50ms](https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FPerformance\u002FHow_long_is_too_long)) fashion.\n\nIn our example, maybe the image loaded quickly, but perhaps the anotherscript.js file was 2MB and our user's network connection was slow.  In this case, the user would see the page super quickly, but wouldn't be able to scroll without jank until the script was downloaded, parsed and executed. That is not a good user experience. Avoid occupying the main thread, as demonstrated in this WebPageTest example:\n\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fxbkoby5bedm789lskzyb.png\" alt=\"\"\u003E\u003Ca href=\"#\" title=\"TITLE\"\u003E\u003Cfigcaption\u003EExample - JavaScript hogging main thread\u003C\u002Ffigcaption\u003E\u003C\u002Fa\u003E\u003C\u002Ffigure\u003E\n\nIn this example, the DOM content load process took over 1.5 seconds, and the main thread was fully occupied that entire time, unresponsive to click events or screen taps.\n\n#### The user can now browse the page! üéâ\n\nYes, after all these stages the user can now both see and interact with the page!\n\n## Summary\nFor a simple page to be displayed in our browser window it may need to go through:\n- DNS Lookup: To find out the ip of the web address.\n- TCP Handshake: To set up TCP\u002FIP communication between the client and server for the susbsequent steps.\n- TLS Handshake: To safeguard the information that will be sent via encryption.\n- HTTP communication: To establish a method of communication that browsers can understand.\n- Browser Parsing: To parse the HTTP's response‚Äîthe document of the page to be displayed.\n- Browser Rendering: To render the document on the browsers window.\n- Javascript Occupied: To wait for JS to compile and execute as it may hog the main thread.\n\nIt is incredible the number of things that happen for this seemingly simple task to be accomplished. Truly an impressive journey for our little page :)\n\n#### There is more...\nIn a real-world scenario, our little page may have to tackle even more obstacles before reaching its destination things such as: [load balancers, proxies](https:\u002F\u002Fwww.nginx.com\u002Fresources\u002Fglossary\u002Fload-balancing\u002F), [multiple layers of firewalls](https:\u002F\u002Fwww.nginx.com\u002Fresources\u002Fglossary\u002Fwhat-is-a-waf\u002F), etc... \n\nThese topics are beasts of their own and if you're curious about how they work I recommend looking them up! Perhaps i'll write something for them in the future.\n\n**Thank you for reading,\nPaulo üòé**\n\n## Reference\n- https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FPerformance\u002FHow_browsers_work#overview\n- https:\u002F\u002Fwww.html5rocks.com\u002Fen\u002Ftutorials\u002Finternals\u002Fhowbrowserswork\n- https:\u002F\u002Fdevelopers.google.com\u002Fweb\u002Ffundamentals\u002F\n- https:\u002F\u002Fblog.cloudflare.com\u002Fintroducing-0-rtt\u002F\n- https:\u002F\u002Fblog.cloudflare.com\u002Fkeyless-ssl-the-nitty-gritty-technical-details\u002F\n- https:\u002F\u002Fcommunity.fs.com\u002Fblog\u002Ftcpip-vs-osi-whats-the-difference-between-the-two-models.html\n- https:\u002F\u002Fwww.sciencedirect.com\u002Ftopics\u002Fcomputer-science\u002Fthree-way-handshake\n- https:\u002F\u002Fv8.dev\u002Fblog\u002Fbackground-compilation\n- https:\u002F\u002Fwww.smashingmagazine.com\u002F2016\u002F12\u002Fgpu-animation-doing-it-right\u002F\n";a.user={name:"Paulo Santos",username:"gitpaulo",twitter_username:"TweetGitPaulo",github_username:"GitPaulo",website_url:"https:\u002F\u002Fwww.codegrepper.com\u002Fapp\u002Fprofile.php?id=125208",profile_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--jc4Wf9uP--\u002Fc_fill,f_auto,fl_progressive,h_640,q_auto,w_640\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F666129\u002Fb62e3a33-974b-4d19-b568-5d820c809703.png",profile_image_90:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--dicE4Xlw--\u002Fc_fill,f_auto,fl_progressive,h_90,q_auto,w_90\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F666129\u002Fb62e3a33-974b-4d19-b568-5d820c809703.png"};return {data:[{}],fetch:{"data-v-25febe66:0":{article:a}},mutations:[["SET_CURRENT_ARTICLE",a]]}}({},"https:\u002F\u002Fdev.to\u002Fgitpaulo\u002Fjourney-of-a-web-page-how-browsers-work-10co",1268,null,"2021-07-19T09:04:55Z")));