window.__NUXT__=(function(a,b,c,d,e){return {staticAssetsBase:"\u002F_nuxt\u002Fstatic\u002F1634322943",layout:"default",error:a,state:{currentArticle:{type_of:"article",id:542997,title:"In my own words: What is BabelJS?",description:"When I started learning about building static websites using HTML, CSS and Javascript back in 2012, e...",readable_publish_date:"Dec 16 '20",slug:"in-my-own-words-what-is-babeljs-1c6e",path:"\u002Fmichaelsyap\u002Fin-my-own-words-what-is-babeljs-1c6e",url:c,comments_count:4,public_reactions_count:d,collection_id:a,published_timestamp:e,positive_reactions_count:d,cover_image:a,social_image:"https:\u002F\u002Fdev.to\u002Fsocial_previews\u002Farticle\u002F542997.png",canonical_url:c,created_at:"2020-12-15T09:26:49Z",edited_at:"2020-12-16T14:24:19Z",crossposted_at:a,published_at:e,last_comment_at:"2020-12-18T09:44:28Z",reading_time_minutes:5,tag_list:"javascript, babel",tags:["javascript","babel"],body_html:"\u003Cp\u003EWhen I started learning about building static websites using HTML, CSS and Javascript back in 2012, everything was so simple and straightforward. Open up your text editor, create HTML, CSS and JavaScript files, and, voila,  you now have a working static website. \u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"problem\" href=\"#problem\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  Problem\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EWhile front-end development seem to be very straightforward during those times, there was a major problem that web developers deal with when they work with JavaScript. Browser vendors were inconsistent in implementing \u003Ca href=\"http:\u002F\u002Fwww.ecma-international.org\u002Fecma-262\u002F10.0\u002Findex.html\"\u003EECMAScript\u003C\u002Fa\u003E\u003Csup\u003E1\u003C\u002Fsup\u003E specifications. With this problem, it was a great challenge to write JavaScript code (including web APIs like \u003Ca href=\"https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FDocument_Object_Model\"\u003EDOM\u003C\u002Fa\u003E) and making it sure that it works across major browser vendors(including Internet explorer ðŸ’¢). \u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"solutions\" href=\"#solutions\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  Solutions\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EThankfully, there were many talented developers who found ways to come up with creative solutions  to make the lives of other developers easier. \u003C\u002Fp\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"polyfill\" href=\"#polyfill\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  Polyfill\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003EOne of the earliest solutions to address inconsistent Javascript implementation or lack of latest ECMAScript syntax was through the implementation of a \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FPolyfill_(programming)\"\u003EPolyfill\u003C\u002Fa\u003E. A Polyfill is a code that extends APIs that are available in browsers in such a away that it enables developers to either have a consistent API that addresses cross-browser compatibility issues or to take advantage of new language features that are not yet available on old browsers.\u003C\u002Fp\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"javascript-libraries-jquery\" href=\"#javascript-libraries-jquery\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  Javascript Libraries: jQuery\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003EAnother one of those solutions was \u003Ca href=\"https:\u002F\u002Fjquery.com\u002F\"\u003EjQuery\u003C\u002Fa\u003E. jQuery was the most popular front-end library during that time (and still wildly popular today). It was a lifesaver for so many developers. It is a library(helper functions including polyfills) that that provided a simple API that takes care of intricacies of cross-browser javascript compatibility. \u003C\u002Fp\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"compilers\" href=\"#compilers\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  Compilers\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003EFast forward to 2014, HTML5 was born. Following that, JavaScript got a much anticipated update with the release of  ES6 (ECMAScript 6) in 2015. These updates has taken the world of front-end development by storm. Many developers who used to hate Javascript, started to change their minds because of the new features that were pretty good for them to ignore. People were starting to drop jQuery because it was starting to become redundant given that some developers who cares too much about their website loading performance and saw it as an additional bloat on their website. It has also become \u003Ca href=\"http:\u002F\u002Fyoumightnotneedjquery.com\u002F\"\u003Ea redundancy\u003C\u002Fa\u003E because the features it offers were now integrated natively on new HTML5 web APIs. Yet, the problem of inconsistent browser support for ES6 still exists and the desire of so many developers to leverage the new features of JavaScript was constantly increasing.\u003C\u002Fp\u003E\n\n\u003Cp\u003ETo solve these issues, Javascript compilers were made to address these issues at that time. Today, I'm going to discuss one of those JavaScript compilers which is widely used even today.\u003C\u002Fp\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"babeljs\" href=\"#babeljs\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  BabelJS\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003EFor developers who are new in Javascript development, you may already have either followed a \u003Ca href=\"https:\u002F\u002Freactjs.org\u002F\"\u003EReactJS\u003C\u002Fa\u003E tutorial or you may have used project boilerplate templates like \u003Ca href=\"https:\u002F\u002Fcreate-react-app.dev\u002F\"\u003ECRA\u003C\u002Fa\u003E(Create React App). I assume you may have seen the \u003Ccode\u003Ebabel\u003C\u002Fcode\u003E key in your \u003Ccode\u003Epackage.json\u003C\u002Fcode\u003E or source code files such as \u003Ccode\u003E.babelrc\u003C\u002Fcode\u003E and \u003Ccode\u003Ebabel.config.json\u003C\u002Fcode\u003E. All of these are ways to provide configuration options to  a wonderful tool which is called \u003Ca href=\"https:\u002F\u002Fbabeljs.io\u002F\"\u003EBabelJS\u003C\u002Fa\u003E. \u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fbabeljs.io\u002F\"\u003EBabelJS\u003C\u002Fa\u003E is a toolkit that enables developers to use ES2015+ language features (including bleeding edge ECMAScript release candidate features) on their Javascript code and produce a source code that is compatible with target environments(ie. older browsers and previous NodeJS versions) who do not provide the latest ECMAScript support.  \u003C\u002Fp\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"how-does-babeljs-help-developers\" href=\"#how-does-babeljs-help-developers\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  How does BabelJS help developers\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003EFrom how I understood upon reading the documentation of BabelJS, here are the two major ways it    helps developers to support target environments:\u003C\u002Fp\u003E\n\n\u003Col\u003E\n\u003Cli\u003E\n\u003Cstrong\u003ESource code transformation\u003C\u002Fstrong\u003E - This feature transforms your ES2015+ source code into older versions of Javascript(like ES5, etc.) which is supported by target environments.\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EPolyfill injection\u003C\u002Fstrong\u003E - Babel makes it easier for developers to integrate polyfill into their source code as it knows which polyfill must be injected depending on the developer's target environments.\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\n\u003Cp\u003EKnowing these things which sums up what BabelJS does, I would like to add these basic things that I took note of, which in my opinion, are helpful for new developers to know about BabelJS as they look into their Babel configuration files.\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cstrong\u003E\u003Ca href=\"https:\u002F\u002Fbabeljs.io\u002Fdocs\u002Fen\u002Fplugins\"\u003EPlugins\u003C\u002Fa\u003E\u003C\u002Fstrong\u003E - On your babel configuration file(\u003Ccode\u003E.babelrc\u003C\u002Fcode\u003E or \u003Ccode\u003Ebabel.config.json\u003C\u002Fcode\u003E), you may see the  \u003Ccode\u003Eplugins\u003C\u002Fcode\u003E key. Babel makes it possible to do source code transformation through plugins.\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cstrong\u003E\u003Ca href=\"https:\u002F\u002Fbabeljs.io\u002Fdocs\u002Fen\u002Fpresets\"\u003EPresets\u003C\u002Fa\u003E\u003C\u002Fstrong\u003E - On your babel configuration file, you may actually see first the \u003Ccode\u003Epresets\u003C\u002Fcode\u003E key. Presets are simply an opinionated collection of \u003Ccode\u003Eplugins\u003C\u002Fcode\u003E which tries to achieve a specific goal to support a type of JavaScript implementation (ie. ReactJS, VueJS, etc.). Some of the common presets that you will see are \u003Ccode\u003E@babel\u002Fpreset-env\u003C\u002Fcode\u003E and \u003Ccode\u003E@babel\u002Fpreset-react\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cstrong\u003E\u003Ca href=\"https:\u002F\u002Fbabeljs.io\u002Fdocs\u002Fen\u002Fbabel-preset-typescript\"\u003E@babel\u002Fpreset-env\u003C\u002Fa\u003E -\u003C\u002Fstrong\u003E this is a preset that enables you to write the latest Javascript syntax out of the box. I would just like to add that I have seen this snippet for quite some time already and I always ignored what's the purpose of this in a babel config file. ðŸ˜‚\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cstrong\u003ETip -\u003C\u002Fstrong\u003E In the past I was so confused as to why my babel config wasn't working on my code which caused my project to not work in a certain browser. I discovered that there can be multiple babel configurations that may override your configuration. Thankfully, I solved it before through google search ðŸ˜‚. Now, I know a better solution. I discovered that \u003Ca href=\"https:\u002F\u002Fbabeljs.io\u002Fdocs\u002Fen\u002Fconfiguration#print-effective-configs\"\u003Eit is possible to see which babel config is used on certain source code files .\u003C\u002Fa\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"conclusion\" href=\"#conclusion\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  Conclusion\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003ENow that we know how BabelJS makes our lives easier by allowing us to use JavaScript's newest features while not having to deal with incompatibility issues when targeting specific environments, it is safe to say that BabelJS has indeed solved the problems that we've mentioned earlier. No wonder why JavaScript is still the  \u003Ca href=\"https:\u002F\u002Finsights.stackoverflow.com\u002Fsurvey\u002F2020#most-popular-technologies\"\u003Emost popular technology used by developers\u003C\u002Fa\u003E. I personally think that BabelJS is a major contributor that pushed JavaScript forward to where it is today and will continue to be in the coming years.\u003C\u002Fp\u003E\n\n\u003Cp\u003EAs I reflect on this post, I can say that new front-end developers today are blessed for not having to deal with the pains of manually supporting old browsers like we used to in the past. At the same time, I think that while we can enjoy today these new language features in Javascript that is made possible by tools like Babel, it is also important that we take time to understand how Babel fits into the big picture among the other tools that sums up the tool chain of a modern Javascript development environment (ie. Webpack, CSS preprocessors, etc.). If new developers don't intentionally understand the tools that make up of the whole JavaScript development toolchain that they use today, they will definitely encounter difficulties in facing the new challenge of experiencing bugs, not only caused by their source code but also caused by the suite of Javascript development tools they use during development and during building production. This is why so many are experiencing what they call \u003Ca href=\"https:\u002F\u002Fauth0.com\u002Fblog\u002Fhow-to-manage-javascript-fatigue\u002F\"\u003EJavaScript fatigue\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\n\u003Cp\u003EThank you for spending the time reading this post. I hope that you learned something today!\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Cstrong\u003E\u003Cem\u003EHi! This article is originally post on \u003Ca href=\"https:\u002F\u002Fwww.michaelsyap.com\u002F\"\u003Emy website\u003C\u002Fa\u003E. If you have any suggestions, corrections, or constructive feedback about this post, please let \u003Ca href=\"https:\u002F\u002Fwww.michaelsyap.com\u002Fpages\u002Fcontact\"\u003Eme know\u003C\u002Fa\u003E. I would greatly appreciate it!ðŸ’¯\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\n",body_markdown:"When I started learning about building static websites using HTML, CSS and Javascript back in 2012, everything was so simple and straightforward. Open up your text editor, create HTML, CSS and JavaScript files, and, voila,  you now have a working static website. \n\n## Problem\n\nWhile front-end development seem to be very straightforward during those times, there was a major problem that web developers deal with when they work with JavaScript. Browser vendors were inconsistent in implementing [ECMAScript](http:\u002F\u002Fwww.ecma-international.org\u002Fecma-262\u002F10.0\u002Findex.html)\u003Csup\u003E1\u003C\u002Fsup\u003E specifications. With this problem, it was a great challenge to write JavaScript code (including web APIs like [DOM](https:\u002F\u002Fdeveloper.mozilla.org\u002Fen-US\u002Fdocs\u002FWeb\u002FAPI\u002FDocument_Object_Model)) and making it sure that it works across major browser vendors(including Internet explorer ðŸ’¢). \n\n## Solutions\n\nThankfully, there were many talented developers who found ways to come up with creative solutions  to make the lives of other developers easier. \n\n### Polyfill\n\nOne of the earliest solutions to address inconsistent Javascript implementation or lack of latest ECMAScript syntax was through the implementation of a [Polyfill](https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FPolyfill_(programming)). A Polyfill is a code that extends APIs that are available in browsers in such a away that it enables developers to either have a consistent API that addresses cross-browser compatibility issues or to take advantage of new language features that are not yet available on old browsers.\n\n### Javascript Libraries: jQuery\n\nAnother one of those solutions was [jQuery](https:\u002F\u002Fjquery.com\u002F). jQuery was the most popular front-end library during that time (and still wildly popular today). It was a lifesaver for so many developers. It is a library(helper functions including polyfills) that that provided a simple API that takes care of intricacies of cross-browser javascript compatibility. \n\n### Compilers\n\nFast forward to 2014, HTML5 was born. Following that, JavaScript got a much anticipated update with the release of  ES6 (ECMAScript 6) in 2015. These updates has taken the world of front-end development by storm. Many developers who used to hate Javascript, started to change their minds because of the new features that were pretty good for them to ignore. People were starting to drop jQuery because it was starting to become redundant given that some developers who cares too much about their website loading performance and saw it as an additional bloat on their website. It has also become [a redundancy](http:\u002F\u002Fyoumightnotneedjquery.com\u002F) because the features it offers were now integrated natively on new HTML5 web APIs. Yet, the problem of inconsistent browser support for ES6 still exists and the desire of so many developers to leverage the new features of JavaScript was constantly increasing.\n\nTo solve these issues, Javascript compilers were made to address these issues at that time. Today, I'm going to discuss one of those JavaScript compilers which is widely used even today.\n### BabelJS\n\nFor developers who are new in Javascript development, you may already have either followed a [ReactJS](https:\u002F\u002Freactjs.org\u002F) tutorial or you may have used project boilerplate templates like [CRA](https:\u002F\u002Fcreate-react-app.dev\u002F)(Create React App). I assume you may have seen the `babel` key in your `package.json` or source code files such as `.babelrc` and `babel.config.json`. All of these are ways to provide configuration options to  a wonderful tool which is called [BabelJS](https:\u002F\u002Fbabeljs.io\u002F). \n\n[BabelJS](https:\u002F\u002Fbabeljs.io\u002F) is a toolkit that enables developers to use ES2015+ language features (including bleeding edge ECMAScript release candidate features) on their Javascript code and produce a source code that is compatible with target environments(ie. older browsers and previous NodeJS versions) who do not provide the latest ECMAScript support.  \n\n### How does BabelJS help developers\n\nFrom how I understood upon reading the documentation of BabelJS, here are the two major ways it    helps developers to support target environments:\n\n1. **Source code transformation** - This feature transforms your ES2015+ source code into older versions of Javascript(like ES5, etc.) which is supported by target environments.\n2. **Polyfill injection** - Babel makes it easier for developers to integrate polyfill into their source code as it knows which polyfill must be injected depending on the developer's target environments.\n\nKnowing these things which sums up what BabelJS does, I would like to add these basic things that I took note of, which in my opinion, are helpful for new developers to know about BabelJS as they look into their Babel configuration files.\n\n- **[Plugins](https:\u002F\u002Fbabeljs.io\u002Fdocs\u002Fen\u002Fplugins)** - On your babel configuration file(`.babelrc` or `babel.config.json`), you may see the  `plugins` key. Babel makes it possible to do source code transformation through plugins.\n- **[Presets](https:\u002F\u002Fbabeljs.io\u002Fdocs\u002Fen\u002Fpresets)** - On your babel configuration file, you may actually see first the `presets` key. Presets are simply an opinionated collection of `plugins` which tries to achieve a specific goal to support a type of JavaScript implementation (ie. ReactJS, VueJS, etc.). Some of the common presets that you will see are `@babel\u002Fpreset-env` and `@babel\u002Fpreset-react`.\n- **[@babel\u002Fpreset-env](https:\u002F\u002Fbabeljs.io\u002Fdocs\u002Fen\u002Fbabel-preset-typescript) -** this is a preset that enables you to write the latest Javascript syntax out of the box. I would just like to add that I have seen this snippet for quite some time already and I always ignored what's the purpose of this in a babel config file. ðŸ˜‚\n- **Tip -** In the past I was so confused as to why my babel config wasn't working on my code which caused my project to not work in a certain browser. I discovered that there can be multiple babel configurations that may override your configuration. Thankfully, I solved it before through google search ðŸ˜‚. Now, I know a better solution. I discovered that [it is possible to see which babel config is used on certain source code files .](https:\u002F\u002Fbabeljs.io\u002Fdocs\u002Fen\u002Fconfiguration#print-effective-configs)\n\n## Conclusion\n\nNow that we know how BabelJS makes our lives easier by allowing us to use JavaScript's newest features while not having to deal with incompatibility issues when targeting specific environments, it is safe to say that BabelJS has indeed solved the problems that we've mentioned earlier. No wonder why JavaScript is still the  [most popular technology used by developers](https:\u002F\u002Finsights.stackoverflow.com\u002Fsurvey\u002F2020#most-popular-technologies). I personally think that BabelJS is a major contributor that pushed JavaScript forward to where it is today and will continue to be in the coming years.\n\nAs I reflect on this post, I can say that new front-end developers today are blessed for not having to deal with the pains of manually supporting old browsers like we used to in the past. At the same time, I think that while we can enjoy today these new language features in Javascript that is made possible by tools like Babel, it is also important that we take time to understand how Babel fits into the big picture among the other tools that sums up the tool chain of a modern Javascript development environment (ie. Webpack, CSS preprocessors, etc.). If new developers don't intentionally understand the tools that make up of the whole JavaScript development toolchain that they use today, they will definitely encounter difficulties in facing the new challenge of experiencing bugs, not only caused by their source code but also caused by the suite of Javascript development tools they use during development and during building production. This is why so many are experiencing what they call [JavaScript fatigue](https:\u002F\u002Fauth0.com\u002Fblog\u002Fhow-to-manage-javascript-fatigue\u002F).\n\nThank you for spending the time reading this post. I hope that you learned something today!\n\n***Hi! This article is originally post on [my website](https:\u002F\u002Fwww.michaelsyap.com\u002F). If you have any suggestions, corrections, or constructive feedback about this post, please let [me know](https:\u002F\u002Fwww.michaelsyap.com\u002Fpages\u002Fcontact). I would greatly appreciate it!ðŸ’¯***\n",user:{name:"Michael Yap",username:b,twitter_username:b,github_username:b,website_url:"https:\u002F\u002Fwww.michaelsyap.com\u002F",profile_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--BDVITgCZ--\u002Fc_fill,f_auto,fl_progressive,h_640,q_auto,w_640\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F257761\u002F3853df3d-e663-4046-9cb7-9e4b72c01f5a.jpeg",profile_image_90:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--BneikJ9T--\u002Fc_fill,f_auto,fl_progressive,h_90,q_auto,w_90\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F257761\u002F3853df3d-e663-4046-9cb7-9e4b72c01f5a.jpeg"}}},serverRendered:true,routePath:"\u002Farticles\u002Fmichaelsyap\u002F542997",config:{_app:{basePath:"\u002F",assetsPath:"\u002F_nuxt\u002F",cdnURL:a}}}}(null,"michaelsyap","https:\u002F\u002Fdev.to\u002Fmichaelsyap\u002Fin-my-own-words-what-is-babeljs-1c6e",13,"2020-12-16T01:01:32Z"));