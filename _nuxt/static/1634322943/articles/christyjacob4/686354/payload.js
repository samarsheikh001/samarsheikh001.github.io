__NUXT_JSONP__("/articles/christyjacob4/686354", (function(a,b,c,d,e,f,g){c.type_of="article";c.id=686354;c.title="#30DaysofAppwrite : Appwriteâ€™s building blocks";c.description="Intro   Appwrite is an open-source, self-hosted Backend-as-a-Service that makes app developm...";c.readable_publish_date="May 3";c.slug="30daysofappwrite-appwrite-s-building-blocks-1936";c.path="\u002Fappwrite\u002F30daysofappwrite-appwrite-s-building-blocks-1936";c.url=d;c.comments_count=0;c.public_reactions_count=e;c.collection_id=a;c.published_timestamp=b;c.positive_reactions_count=e;c.cover_image="https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--DieyregT--\u002Fc_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fl3bozwuywt8n49udl0nk.png";c.social_image="https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--ff1nQuQF--\u002Fc_imagga_scale,f_auto,fl_progressive,h_500,q_auto,w_1000\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fl3bozwuywt8n49udl0nk.png";c.canonical_url=d;c.created_at="2021-05-03T13:36:32Z";c.edited_at="2021-05-06T18:38:31Z";c.crossposted_at=a;c.published_at=b;c.last_comment_at=b;c.reading_time_minutes=7;c.tag_list="webdev, javascript, flutter, 30daysofappwrite";c.tags=["webdev","javascript","flutter","30daysofappwrite"];c.body_html="\u003Ch1\u003E\n  \u003Ca name=\"intro\" href=\"#intro\"\u003E\n  \u003C\u002Fa\u003E\n  Intro\n\u003C\u002Fh1\u003E\n\n\u003Cp\u003EAppwrite is an open-source, self-hosted Backend-as-a-Service that makes app development \u003Cstrong\u003Eeasier\u003C\u002Fstrong\u003E with a suite of SDKs and APIs to accelerate app development. \u003Ca href=\"http:\u002F\u002F30days.appwrite.io\u002F\"\u003E#30DaysOfAppwrite\u003C\u002Fa\u003E is a month-long event focussed on giving developers a walkthrough of all of Appwrite's features, starting from the basics to more advanced features like cloud functions! Alongside we will also be building a full-featured Medium Clone to demonstrate how these concepts can be applied when building a real-world app. We also have some exciting prizes for developers who follow along with us!\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"microservices-of-appwrite\" href=\"#microservices-of-appwrite\"\u003E\n  \u003C\u002Fa\u003E\n  Microservices of Appwrite\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EWelcome to Day 3 ðŸ‘‹ \u003Cbr\u003E\nToday, we take a deep dive into Appwrite's technology stack and learn what goes on under the hood. We will cover \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fappwrite\u002Fappwrite\u002Fblob\u002Fmaster\u002Fdocker-compose.yml\"\u003EAppwrite's docker-compose file\u003C\u002Fa\u003E and go through all the containers that Appwrite uses. Appwrite was designed to work in a Cloud Native environment, and in keeping this spirit alive,  Appwrite is conveniently packaged as a set of docker containers (17 to be precise!). \u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--KI3zascd--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fpsaxs740zuvty1lp34t7.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--KI3zascd--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fpsaxs740zuvty1lp34t7.png\" alt=\"Appwrite Architecture\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EThis is an overview of Appwrite's architecture, and we will talk about most of these components in the upcoming section. Each container in Appwrite handles a single microservice on its own. Since they've been containerized, each service can scale independently of any of the other microservices.\u003C\u002Fp\u003E\n\n\u003Cp\u003ECurrently, all of the Appwrite microservices communicate over the TCP protocol over \u003Ca href=\"https:\u002F\u002Fdocs.docker.com\u002Fnetwork\u002Fbridge\u002F\"\u003Ea private network\u003C\u002Fa\u003E. You should be aware not to expose any of the services to the public-facing network, besides the public port 80 and 443, which, by default, are used to expose the Appwrite HTTP API.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"appwrite\" href=\"#appwrite\"\u003E\n  \u003C\u002Fa\u003E\n  Appwrite\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EThis is the main \u003Ca href=\"https:\u002F\u002Fgist.github.com\u002Feldadfux\u002F977869ff6bdd7312adfd4e629ee15cc5#file-docker-compose-yml-L29\"\u003EAppwrite container\u003C\u002Fa\u003E and this is where all the fancy things happen! This container is built off a Dockerfile hosted \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fappwrite\u002Fappwrite\u002Fblob\u002Fmaster\u002FDockerfile\"\u003Ehere\u003C\u002Fa\u003E. The main Appwrite container implements the Appwrite API protocols, handles authentication, authorization, and rate-limiting. This microservice is completely stateless and can be easily replicated for scalability. \u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"traefik\" href=\"#traefik\"\u003E\n  \u003C\u002Fa\u003E\n  Traefik\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003ETraefik is a modern reverse proxy and load balancer written in Go that makes deploying microservices easy. Traefik integrates with your existing infrastructure components and configures itself automatically and dynamically. We use Traefik as the main entry point for the different Appwrite APIs. Traefik is also responsible for serving Appwrite's auto-generated SSL certificates. This microservice is completely stateless.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"redis\" href=\"#redis\"\u003E\n  \u003C\u002Fa\u003E\n  Redis\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EAppwrite uses Redis to serve three main functions. \u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cstrong\u003ECaching\u003C\u002Fstrong\u003E: Appwrite uses Redis in-memory cache to fetch database queries faster.\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EPub\u002FSub\u003C\u002Fstrong\u003E: Appwrite uses Redis with Resque as a pub\u002Fsub mechanism to transmit messages between the Appwrite API and the different workers. \u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cstrong\u003EScheduled tasks\u003C\u002Fstrong\u003E: Appwrite uses Redis to store and trigger future tasks using the schedule container.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"appwrites-workers\" href=\"#appwrites-workers\"\u003E\n  \u003C\u002Fa\u003E\n  Appwrite's Workers\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EThere are a lot of asynchronous tasks that need to happen in Appwrite - a good example is recording usage stats for the Appwrite API. \u003C\u002Fp\u003E\n\n\u003Cp\u003EWe use an internal pub\u002Fsub system - \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fresque\u002Fphp-resque\"\u003EResque\u003C\u002Fa\u003E - to accumulate all these tasks. The respective workers consume these tasks and perform the executions independently. We have eight message queues and eight workers paired with them.  \u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Ch4\u003E\n  \u003Ca name=\"audits-worker\" href=\"#audits-worker\"\u003E\n  \u003C\u002Fa\u003E\n  Audits worker\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EThe \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fappwrite\u002Fappwrite\u002Fblob\u002Fmaster\u002Fapp\u002Fworkers\u002Faudits.php\"\u003EAudits worker\u003C\u002Fa\u003E consumes messages from the \u003Ccode\u003Ev1-audits\u003C\u002Fcode\u003E queue. Appwrite has a defined set of system events that can be found \u003Ca href=\"https:\u002F\u002Fappwrite.io\u002Fdocs\u002Fwebhooks#events\"\u003Ehere\u003C\u002Fa\u003E. When these events occur, the Audits worker logs them into \u003Ccode\u003Emariadb\u003C\u002Fcode\u003E. The Audits worker makes use of the \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Futopia-php\u002Faudit\"\u003Eutopia-php\u002Faudit\u003C\u002Fa\u003E library.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Ch4\u003E\n  \u003Ca name=\"certificates-worker\" href=\"#certificates-worker\"\u003E\n  \u003C\u002Fa\u003E\n  Certificates Worker\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EThe \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fappwrite\u002Fappwrite\u002Fblob\u002Fmaster\u002Fapp\u002Fworkers\u002Fcertificates.php\"\u003ECertificates worker\u003C\u002Fa\u003E consumes messages from the \u003Ccode\u003Ev1-certificates\u003C\u002Fcode\u003E queue. The certificate worker uses \u003Ccode\u003Ecertbot\u003C\u002Fcode\u003E from Let's Encrypt to create and periodically renew SSL certificates. We will be covering SSL certificates and more about the certificates worker in our upcoming article. So stay tuned to learn more. \u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Ch4\u003E\n  \u003Ca name=\"deletes-worker\" href=\"#deletes-worker\"\u003E\n  \u003C\u002Fa\u003E\n  Deletes Worker\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EThe \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fappwrite\u002Fappwrite\u002Fblob\u002Fmaster\u002Fapp\u002Fworkers\u002Fdeletes.php\"\u003EDeletes worker\u003C\u002Fa\u003E consumes messages from the \u003Ccode\u003Ev1-deletes\u003C\u002Fcode\u003E queue. As the name suggests, it performs deletions in the Appwrite Database. Delete requests for Documents, Users, Projects, Functions, etc. are handled by the Deletes Worker. In the present state, the deletes worker is triggered on certain API requests, as well as by the Maintenance worker. \u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Ch4\u003E\n  \u003Ca name=\"functions-worker\" href=\"#functions-worker\"\u003E\n  \u003C\u002Fa\u003E\n  Functions Worker\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EThe \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fappwrite\u002Fappwrite\u002Fblob\u002Fmaster\u002Fapp\u002Fworkers\u002Ffunctions.php\"\u003EFunctions worker\u003C\u002Fa\u003E consumes messages from the \u003Ccode\u003Ev1-functions\u003C\u002Fcode\u003E queue and handles all of the tasks related to Appwrite's Cloud Functions. \u003Cbr\u003E\nCloud functions in Appwrite can be triggered in 3 ways:\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fappwrite.io\u002Fdocs\u002Fwebhooks#events\"\u003EAsynchronously using Events\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FCron\"\u003EUsing a CRON Schedule\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fappwrite.io\u002Fdocs\u002Fclient\u002Ffunctions?sdk=web#functionsCreateExecution\"\u003EUsing the Appwrite HTTP API\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003EThe Functions worker does all the heavy lifting required to get Cloud Functions up and running. From pulling Docker images for the respective environments on startup, to managing and running containers, and responding to errors, the functions worker takes care of it all! \u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Ch4\u003E\n  \u003Ca name=\"mails-worker\" href=\"#mails-worker\"\u003E\n  \u003C\u002Fa\u003E\n  Mails Worker\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EThe \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fappwrite\u002Fappwrite\u002Fblob\u002Fmaster\u002Fapp\u002Fworkers\u002Fmails.php\"\u003EMails worker\u003C\u002Fa\u003E consumes messages from the \u003Ccode\u003Ev1-mails\u003C\u002Fcode\u003E queue and is responsible for only one function: sending emails! It simply gathers information and uses \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FPHPMailer\u002FPHPMailer\"\u003EPHPMailer\u003C\u002Fa\u003E to send them.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Ch4\u003E\n  \u003Ca name=\"tasks-worker\" href=\"#tasks-worker\"\u003E\n  \u003C\u002Fa\u003E\n  Tasks Worker\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EThe \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fappwrite\u002Fappwrite\u002Fblob\u002Fmaster\u002Fapp\u002Fworkers\u002Ftasks.php\"\u003ETasks worker\u003C\u002Fa\u003E consumes messages from the \u003Ccode\u003Ev1-tasks\u003C\u002Fcode\u003E queue.\u003Cbr\u003E\nAppwrite's Tasks API allows you to schedule any repeating tasks your app might need to run in the background. Each task is created by defining a CRON schedule and a target HTTP endpoint.\u003Cbr\u003E\nEach task can define any HTTP endpoint with any HTTP method, headers, or basic HTTP authentication. Inside your Appwrite console, you can view all your tasks, their current statuses, previous and next runtime, and a response log to view the result of previous executions.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Ch4\u003E\n  \u003Ca name=\"usage-worker\" href=\"#usage-worker\"\u003E\n  \u003C\u002Fa\u003E\n  Usage Worker\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EThe \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fappwrite\u002Fappwrite\u002Fblob\u002Fmaster\u002Fapp\u002Fworkers\u002Fusage.php\"\u003EUsage worker\u003C\u002Fa\u003E consumes messages from the \u003Ccode\u003Ev1-usage\u003C\u002Fcode\u003E queue and makes use of \u003Ccode\u003Estatsd\u003C\u002Fcode\u003E to send messages to \u003Ccode\u003Etelegraf\u003C\u002Fcode\u003E over a UDP connection. The usage stats are then logged in \u003Ccode\u003EinfluxDB\u003C\u002Fcode\u003E, including function execution stats, the total number of requests, storage stats, etc.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Ch4\u003E\n  \u003Ca name=\"webhooks-worker\" href=\"#webhooks-worker\"\u003E\n  \u003C\u002Fa\u003E\n  Webhooks Worker\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EThe \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fappwrite\u002Fappwrite\u002Fblob\u002Fmaster\u002Fapp\u002Fworkers\u002Fwebhooks.php\"\u003EWebhooks worker\u003C\u002Fa\u003E consumes messages from the \u003Ccode\u003Ev1-webhooks\u003C\u002Fcode\u003E queue and triggers the webhooks that were registered in the Appwrite console. The worker checks for the event that occurred and fires the corresponding webhook by making a CURL request. Webhooks allow you to build or set up integrations that subscribe to certain \u003Ca href=\"https:\u002F\u002Fappwrite.io\u002Fdocs\u002Fwebhooks#events\"\u003Eevents\u003C\u002Fa\u003E on Appwrite. When one of those events is triggered, we send an HTTP POST payload to the webhook's configured URL. Webhooks can be used to purge the cache from CDN, calculate data or send a Slack notification. You're only limited by your imagination.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003EAdditionally, we have two more workers that delegate tasks to other workers. \u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Ch4\u003E\n  \u003Ca name=\"maintenance-worker\" href=\"#maintenance-worker\"\u003E\n  \u003C\u002Fa\u003E\n  Maintenance Worker\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EThe maintenance worker corresponds to the \u003Ccode\u003Eappwrite-maintenance\u003C\u002Fcode\u003E service in the docker-compose file. The Maintenance worker lies \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fappwrite\u002Fappwrite\u002Fblob\u002Fmaster\u002Fapp\u002Ftasks\u002Fmaintenance.php\"\u003Ehere\u003C\u002Fa\u003E and performs some housekeeping tasks so your Appwrite server does not blow up over time! In its current state, the maintenance worker delegates deletion tasks to \u003Ccode\u003Eappwrite-worker-deletes\u003C\u002Fcode\u003E which then performs the actual deletion. We use the Maintenance worker to schedule three kinds of deletions:\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003ECleaning up Abuse logs\u003C\u002Fli\u003E\n\u003Cli\u003ECleaning up Audit Logs\u003C\u002Fli\u003E\n\u003Cli\u003ECleaning up Execution Logs\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"schedules-worker\" href=\"#schedules-worker\"\u003E\n  \u003C\u002Fa\u003E\n  Schedules Worker\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EThe Schedules worker corresponds to the \u003Ccode\u003Eappwrite-schedule\u003C\u002Fcode\u003E service in the docker-compose file. The Schedules worker uses a \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fresque\u002Fresque\"\u003EResque Scheduler\u003C\u002Fa\u003E under the hood and handles the scheduling of CRON jobs across Appwrite. This includes CRON jobs from the Tasks API, Webhooks API, and the functions API. \u003C\u002Fp\u003E\n\n\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"mariadb\" href=\"#mariadb\"\u003E\n  \u003C\u002Fa\u003E\n  Mariadb\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EAppwrite uses MariaDB as the default database for project collections, documents, and all other metadata. Appwrite is agnostic to the database you use under the hood and support for more databases like \u003Ca href=\"https:\u002F\u002Fwww.postgresql.org\u002F\"\u003EPostgres\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fwww.cockroachlabs.com\u002F\"\u003ECockroachDB\u003C\u002Fa\u003E, \u003Ca href=\"https:\u002F\u002Fwww.mysql.com\u002F\"\u003EMySQL\u003C\u002Fa\u003E and \u003Ca href=\"https:\u002F\u002Fwww.mongodb.com\u002F2\"\u003EMongoDB\u003C\u002Fa\u003E is currently under active development! ðŸ˜Š\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"clamav\" href=\"#clamav\"\u003E\n  \u003C\u002Fa\u003E\n  ClamAV\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EClamAV is a TCP Anti-virus server responsible for scanning all user uploads to the Appwrite storage. The ClamAV microservice is optional and can be disabled using Appwrite environment variables. Starting with Appwrite version 0.8, this functionality is disabled by default to save memory on smaller setups. If you are having issues with excessive memory utilization, you can learn to disable it \u003Ca href=\"https:\u002F\u002Fdev.to\u002Fappwrite\u002Flearn-how-to-disable-clamav-in-your-appwrite-stack-and-reduce-memory-usage-2e37\"\u003Ehere\u003C\u002Fa\u003E \u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"influxdb\" href=\"#influxdb\"\u003E\n  \u003C\u002Fa\u003E\n  Influxdb\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EAppwrite uses InfluxDB for storing your projects' API usage metrics and stats. This is the engine used for generating your API usage graphs and handling time-series data. \u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"telegraf\" href=\"#telegraf\"\u003E\n  \u003C\u002Fa\u003E\n  Telegraf\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003ETelegraf is a plugin-driven server agent for collecting and sending metrics and events from multiple sources to multiple destinations. Telegraf kind of protects InfluxDB by aggregating the data before sending it to the database. Telegraf operates on the UDP protocol which makes data transfer blazing fast!\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"credits\" href=\"#credits\"\u003E\n  \u003C\u002Fa\u003E\n  Credits\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EWe hope you liked this write-up. You can follow \u003Ca href=\"https:\u002F\u002Ftwitter.com\u002Fsearch?q=%2330daysofappwrite\"\u003E#30DaysOfAppwrite\u003C\u002Fa\u003E on Social Media to keep up with all of our posts. The complete event timeline can be found \u003Ca href=\"http:\u002F\u002F30days.appwrite.io\"\u003Ehere\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fappwrite.io\u002Fdiscord\"\u003EDiscord Server\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Ca href=\"https:\u002F\u002Fappwrite.io\u002F\"\u003EAppwrite Homepage\u003C\u002Fa\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fappwrite\"\u003EAppwrite's Github\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003EFeel free to reach out to us on Discord if you would like to learn more about Appwrite, Aliens, or Unicorns ðŸ¦„. Stay tuned for tomorrow's article! Until then ðŸ‘‹\u003C\u002Fp\u003E\n\n";c.body_markdown="# Intro\nAppwrite is an open-source, self-hosted Backend-as-a-Service that makes app development **easier** with a suite of SDKs and APIs to accelerate app development. [#30DaysOfAppwrite](http:\u002F\u002F30days.appwrite.io\u002F) is a month-long event focussed on giving developers a walkthrough of all of Appwrite's features, starting from the basics to more advanced features like cloud functions! Alongside we will also be building a full-featured Medium Clone to demonstrate how these concepts can be applied when building a real-world app. We also have some exciting prizes for developers who follow along with us!\n\n## Microservices of Appwrite \n\nWelcome to Day 3 ðŸ‘‹ \nToday, we take a deep dive into Appwrite's technology stack and learn what goes on under the hood. We will cover [Appwrite's docker-compose file](https:\u002F\u002Fgithub.com\u002Fappwrite\u002Fappwrite\u002Fblob\u002Fmaster\u002Fdocker-compose.yml) and go through all the containers that Appwrite uses. Appwrite was designed to work in a Cloud Native environment, and in keeping this spirit alive,  Appwrite is conveniently packaged as a set of docker containers (17 to be precise!). \n\n![Appwrite Architecture](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fpsaxs740zuvty1lp34t7.png)\n\nThis is an overview of Appwrite's architecture, and we will talk about most of these components in the upcoming section. Each container in Appwrite handles a single microservice on its own. Since they've been containerized, each service can scale independently of any of the other microservices.\n\nCurrently, all of the Appwrite microservices communicate over the TCP protocol over [a private network](https:\u002F\u002Fdocs.docker.com\u002Fnetwork\u002Fbridge\u002F). You should be aware not to expose any of the services to the public-facing network, besides the public port 80 and 443, which, by default, are used to expose the Appwrite HTTP API.\n\n## Appwrite\nThis is the main [Appwrite container](https:\u002F\u002Fgist.github.com\u002Feldadfux\u002F977869ff6bdd7312adfd4e629ee15cc5#file-docker-compose-yml-L29) and this is where all the fancy things happen! This container is built off a Dockerfile hosted [here](https:\u002F\u002Fgithub.com\u002Fappwrite\u002Fappwrite\u002Fblob\u002Fmaster\u002FDockerfile). The main Appwrite container implements the Appwrite API protocols, handles authentication, authorization, and rate-limiting. This microservice is completely stateless and can be easily replicated for scalability. \n\n## Traefik \nTraefik is a modern reverse proxy and load balancer written in Go that makes deploying microservices easy. Traefik integrates with your existing infrastructure components and configures itself automatically and dynamically. We use Traefik as the main entry point for the different Appwrite APIs. Traefik is also responsible for serving Appwrite's auto-generated SSL certificates. This microservice is completely stateless.\n\n## Redis\nAppwrite uses Redis to serve three main functions. \n\n* **Caching**: Appwrite uses Redis in-memory cache to fetch database queries faster.  \n* **Pub\u002FSub**: Appwrite uses Redis with Resque as a pub\u002Fsub mechanism to transmit messages between the Appwrite API and the different workers. \n* **Scheduled tasks**: Appwrite uses Redis to store and trigger future tasks using the schedule container.\n\n## Appwrite's Workers  \nThere are a lot of asynchronous tasks that need to happen in Appwrite - a good example is recording usage stats for the Appwrite API. \n\nWe use an internal pub\u002Fsub system - [Resque](https:\u002F\u002Fgithub.com\u002Fresque\u002Fphp-resque) - to accumulate all these tasks. The respective workers consume these tasks and perform the executions independently. We have eight message queues and eight workers paired with them.  \n\n* #### Audits worker \nThe [Audits worker](https:\u002F\u002Fgithub.com\u002Fappwrite\u002Fappwrite\u002Fblob\u002Fmaster\u002Fapp\u002Fworkers\u002Faudits.php) consumes messages from the `v1-audits` queue. Appwrite has a defined set of system events that can be found [here](https:\u002F\u002Fappwrite.io\u002Fdocs\u002Fwebhooks#events). When these events occur, the Audits worker logs them into `mariadb`. The Audits worker makes use of the [utopia-php\u002Faudit](https:\u002F\u002Fgithub.com\u002Futopia-php\u002Faudit) library.\n\n* #### Certificates Worker\nThe [Certificates worker](https:\u002F\u002Fgithub.com\u002Fappwrite\u002Fappwrite\u002Fblob\u002Fmaster\u002Fapp\u002Fworkers\u002Fcertificates.php) consumes messages from the `v1-certificates` queue. The certificate worker uses `certbot` from Let's Encrypt to create and periodically renew SSL certificates. We will be covering SSL certificates and more about the certificates worker in our upcoming article. So stay tuned to learn more. \n\n* #### Deletes Worker\nThe [Deletes worker](https:\u002F\u002Fgithub.com\u002Fappwrite\u002Fappwrite\u002Fblob\u002Fmaster\u002Fapp\u002Fworkers\u002Fdeletes.php) consumes messages from the `v1-deletes` queue. As the name suggests, it performs deletions in the Appwrite Database. Delete requests for Documents, Users, Projects, Functions, etc. are handled by the Deletes Worker. In the present state, the deletes worker is triggered on certain API requests, as well as by the Maintenance worker. \n\n* #### Functions Worker\nThe [Functions worker](https:\u002F\u002Fgithub.com\u002Fappwrite\u002Fappwrite\u002Fblob\u002Fmaster\u002Fapp\u002Fworkers\u002Ffunctions.php) consumes messages from the `v1-functions` queue and handles all of the tasks related to Appwrite's Cloud Functions. \nCloud functions in Appwrite can be triggered in 3 ways:\n  * [Asynchronously using Events](https:\u002F\u002Fappwrite.io\u002Fdocs\u002Fwebhooks#events)\n  * [Using a CRON Schedule](https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FCron)\n  * [Using the Appwrite HTTP API](https:\u002F\u002Fappwrite.io\u002Fdocs\u002Fclient\u002Ffunctions?sdk=web#functionsCreateExecution)\n\nThe Functions worker does all the heavy lifting required to get Cloud Functions up and running. From pulling Docker images for the respective environments on startup, to managing and running containers, and responding to errors, the functions worker takes care of it all! \n\n* #### Mails Worker\nThe [Mails worker](https:\u002F\u002Fgithub.com\u002Fappwrite\u002Fappwrite\u002Fblob\u002Fmaster\u002Fapp\u002Fworkers\u002Fmails.php) consumes messages from the `v1-mails` queue and is responsible for only one function: sending emails! It simply gathers information and uses [PHPMailer](https:\u002F\u002Fgithub.com\u002FPHPMailer\u002FPHPMailer) to send them.\n\n\n* #### Tasks Worker\nThe [Tasks worker](https:\u002F\u002Fgithub.com\u002Fappwrite\u002Fappwrite\u002Fblob\u002Fmaster\u002Fapp\u002Fworkers\u002Ftasks.php) consumes messages from the `v1-tasks` queue.\nAppwrite's Tasks API allows you to schedule any repeating tasks your app might need to run in the background. Each task is created by defining a CRON schedule and a target HTTP endpoint.\nEach task can define any HTTP endpoint with any HTTP method, headers, or basic HTTP authentication. Inside your Appwrite console, you can view all your tasks, their current statuses, previous and next runtime, and a response log to view the result of previous executions.\n\n\n* #### Usage Worker\nThe [Usage worker](https:\u002F\u002Fgithub.com\u002Fappwrite\u002Fappwrite\u002Fblob\u002Fmaster\u002Fapp\u002Fworkers\u002Fusage.php) consumes messages from the `v1-usage` queue and makes use of `statsd` to send messages to `telegraf` over a UDP connection. The usage stats are then logged in `influxDB`, including function execution stats, the total number of requests, storage stats, etc.\n\n* #### Webhooks Worker\nThe [Webhooks worker](https:\u002F\u002Fgithub.com\u002Fappwrite\u002Fappwrite\u002Fblob\u002Fmaster\u002Fapp\u002Fworkers\u002Fwebhooks.php) consumes messages from the `v1-webhooks` queue and triggers the webhooks that were registered in the Appwrite console. The worker checks for the event that occurred and fires the corresponding webhook by making a CURL request. Webhooks allow you to build or set up integrations that subscribe to certain [events](https:\u002F\u002Fappwrite.io\u002Fdocs\u002Fwebhooks#events) on Appwrite. When one of those events is triggered, we send an HTTP POST payload to the webhook's configured URL. Webhooks can be used to purge the cache from CDN, calculate data or send a Slack notification. You're only limited by your imagination.\n\nAdditionally, we have two more workers that delegate tasks to other workers. \n* #### Maintenance Worker\nThe maintenance worker corresponds to the `appwrite-maintenance` service in the docker-compose file. The Maintenance worker lies [here](https:\u002F\u002Fgithub.com\u002Fappwrite\u002Fappwrite\u002Fblob\u002Fmaster\u002Fapp\u002Ftasks\u002Fmaintenance.php) and performs some housekeeping tasks so your Appwrite server does not blow up over time! In its current state, the maintenance worker delegates deletion tasks to `appwrite-worker-deletes` which then performs the actual deletion. We use the Maintenance worker to schedule three kinds of deletions:\n\n  * Cleaning up Abuse logs\n  * Cleaning up Audit Logs\n  * Cleaning up Execution Logs\n\n* #### Schedules Worker\nThe Schedules worker corresponds to the `appwrite-schedule` service in the docker-compose file. The Schedules worker uses a [Resque Scheduler](https:\u002F\u002Fgithub.com\u002Fresque\u002Fresque) under the hood and handles the scheduling of CRON jobs across Appwrite. This includes CRON jobs from the Tasks API, Webhooks API, and the functions API. \n\n## Mariadb\nAppwrite uses MariaDB as the default database for project collections, documents, and all other metadata. Appwrite is agnostic to the database you use under the hood and support for more databases like [Postgres](https:\u002F\u002Fwww.postgresql.org\u002F), [CockroachDB](https:\u002F\u002Fwww.cockroachlabs.com\u002F), [MySQL](https:\u002F\u002Fwww.mysql.com\u002F) and [MongoDB](https:\u002F\u002Fwww.mongodb.com\u002F2) is currently under active development! ðŸ˜Š\n\n## ClamAV\nClamAV is a TCP Anti-virus server responsible for scanning all user uploads to the Appwrite storage. The ClamAV microservice is optional and can be disabled using Appwrite environment variables. Starting with Appwrite version 0.8, this functionality is disabled by default to save memory on smaller setups. If you are having issues with excessive memory utilization, you can learn to disable it [here](https:\u002F\u002Fdev.to\u002Fappwrite\u002Flearn-how-to-disable-clamav-in-your-appwrite-stack-and-reduce-memory-usage-2e37) \n\n## Influxdb\nAppwrite uses InfluxDB for storing your projects' API usage metrics and stats. This is the engine used for generating your API usage graphs and handling time-series data. \n\n## Telegraf\nTelegraf is a plugin-driven server agent for collecting and sending metrics and events from multiple sources to multiple destinations. Telegraf kind of protects InfluxDB by aggregating the data before sending it to the database. Telegraf operates on the UDP protocol which makes data transfer blazing fast!\n\n## Credits \nWe hope you liked this write-up. You can follow [#30DaysOfAppwrite](https:\u002F\u002Ftwitter.com\u002Fsearch?q=%2330daysofappwrite) on Social Media to keep up with all of our posts. The complete event timeline can be found [here](http:\u002F\u002F30days.appwrite.io)\n\n* [Discord Server](https:\u002F\u002Fappwrite.io\u002Fdiscord)\n* [Appwrite Homepage](https:\u002F\u002Fappwrite.io\u002F)  \n* [Appwrite's Github](https:\u002F\u002Fgithub.com\u002Fappwrite)\n\nFeel free to reach out to us on Discord if you would like to learn more about Appwrite, Aliens, or Unicorns ðŸ¦„. Stay tuned for tomorrow's article! Until then ðŸ‘‹\n";c.user={name:"Christy Jacob",username:f,twitter_username:a,github_username:f,website_url:a,profile_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--xsn7j9ry--\u002Fc_fill,f_auto,fl_progressive,h_640,q_auto,w_640\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F119691\u002F5be2bcad-e1ee-4ef8-928b-d71f4e355af6.png",profile_image_90:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--IX4ROHsY--\u002Fc_fill,f_auto,fl_progressive,h_90,q_auto,w_90\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F119691\u002F5be2bcad-e1ee-4ef8-928b-d71f4e355af6.png"};c.organization={name:"Appwrite",username:g,slug:g,profile_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--MwfZh3wG--\u002Fc_fill,f_auto,fl_progressive,h_640,q_auto,w_640\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Forganization\u002Fprofile_image\u002F2225\u002Feb541cf9-84f4-4101-987c-c219cd4b34fc.png",profile_image_90:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--5xS_iZdD--\u002Fc_fill,f_auto,fl_progressive,h_90,q_auto,w_90\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Forganization\u002Fprofile_image\u002F2225\u002Feb541cf9-84f4-4101-987c-c219cd4b34fc.png"};return {data:[{}],fetch:{"data-v-25febe66:0":{article:c}},mutations:[["SET_CURRENT_ARTICLE",c]]}}(null,"2021-05-03T13:44:32Z",{},"https:\u002F\u002Fdev.to\u002Fappwrite\u002F30daysofappwrite-appwrite-s-building-blocks-1936",35,"christyjacob4","appwrite")));