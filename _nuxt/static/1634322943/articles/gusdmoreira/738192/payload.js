__NUXT_JSONP__("/articles/gusdmoreira/738192", (function(a,b,c,d,e,f){d.type_of="article";d.id=738192;d.title="Use SOLID Principles To Become Better Automation Tester";d.description="Are you using most recommended and fundamental SOLID principles in your automation?           Why You...";d.readable_publish_date="Jun 24";d.slug="use-solid-principles-to-become-better-automation-tester-3kg9";d.path="\u002Fgusdmoreira\u002Fuse-solid-principles-to-become-better-automation-tester-3kg9";d.url=e;d.comments_count=0;d.public_reactions_count=b;d.collection_id=a;d.published_timestamp=c;d.positive_reactions_count=b;d.cover_image=a;d.social_image="https:\u002F\u002Fdev.to\u002Fsocial_previews\u002Farticle\u002F738192.png";d.canonical_url=e;d.created_at="2021-06-24T19:13:43Z";d.edited_at=a;d.crossposted_at=a;d.published_at=c;d.last_comment_at=c;d.reading_time_minutes=b;d.tag_list="testing, solid, selenium";d.tags=["testing","solid","selenium"];d.body_html="\u003Cp\u003E\u003Cstrong\u003EAre you using most recommended and fundamental SOLID principles in your automation?\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"why-you-need-to-use-solid-principles\" href=\"#why-you-need-to-use-solid-principles\"\u003E\n  \u003C\u002Fa\u003E\n  Why You Need To Use SOLID Principles?\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003ELike any development work, automation also needs to be planned, designed, developed, maintained and extended over time. Your automation code or automation framework is an application which is testing your actual application. That’s why SOLID principles are highly recommend for your automation to make it easy to understand, use, maintain and extend over time. When SOLID principles are not applied, your automation might become fragile, hard to maintain and hard to extend very soon.\u003C\u002Fp\u003E\n\n\u003Cp\u003EEven if you are using different programming language like C#, Python or automation tool like HP UFT\u002FQTP for automation, you should definitely consider applying SOLID principles to make your automation tester life easy. Please note that we will be discussing about applying SOLID principles to web automation using Selenium &amp; Java. But, once you learn the concepts, you can easily apply them to any object-oriented development.\u003C\u002Fp\u003E\n\n\u003Cp\u003EIn this post, we will be exploring what SOLID principles stands for. We will be having one post for each principle with real life examples from web automation using Selenium &amp; Java.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"what-are-the-solid-principles\" href=\"#what-are-the-solid-principles\"\u003E\n  \u003C\u002Fa\u003E\n  What Are The SOLID Principles?\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003ESOLID principles are the first five object-oriented design principles by Robert C. Martin, popularly known as Uncle Bob.\u003C\u002Fp\u003E\n\n\u003Cp\u003ESOLID is an acronym where:\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003ES stands for Single Responsibility Principle (SRP)\u003C\u002Fli\u003E\n\u003Cli\u003EO stands for Open Closed Principle (OCP)\u003C\u002Fli\u003E\n\u003Cli\u003EL stands for Liskov Substitution Principle (LSP)\u003C\u002Fli\u003E\n\u003Cli\u003EI stands for Interface Segregation Principle (ISP)\u003C\u002Fli\u003E\n\u003Cli\u003ED stands for Dependency Inversion Principle (DIP)\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003ELet’s explore and understand each individual principle. Also, let’s find out how these SOLID principles make you better automation tester.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"single-responsibility-principle-srp-a-class-should-have-one-and-only-one-reason-to-change\" href=\"#single-responsibility-principle-srp-a-class-should-have-one-and-only-one-reason-to-change\"\u003E\n  \u003C\u002Fa\u003E\n  Single Responsibility Principle (SRP): A class should have one, and only one, reason to change\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EIn other words to achieve this, a class should only have a single responsibility and it should do that very well. Every class in your automation should only have a single responsibility and that all of its methods should be aligned with that responsibility.\u003C\u002Fp\u003E\n\n\u003Cp\u003ELet’s try to understand this principle by looking at an example from our daily life. When you are driving a car\u002Fbike, you want to fully concentrate on the single responsibility – driving. You don’t want to do or concentrate on other tasks like talking on a phone, eating.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Cem\u003EAutomation Examples:\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003EPage Object Framework implements SRP very well. We are going to have one class responsible for only one web page in the application. We shouldn’t have a very big class with many responsibilities like test methods, UI action methods, excel read\u002Fwrite methods.\u003C\u002Fli\u003E\n\u003Cli\u003EWe can have very specific helper classes like ExcelHelper, DatabaseHelper to work with a excel file or database to implement Data Driven Framework.\u003C\u002Fli\u003E\n\u003Cli\u003ESelenium API has browser specific driver classes like FirefoxDriver, ChromeDriver, InternetExplorerDriver. FirefoxDriver has single responsibility to drive the Firefox browser and it drives the Firefox browser very well.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003EWe should also have methods in classes that are very specific like \u003Ccode\u003EloginAs(username, password)\u003C\u002Fcode\u003E to login with given username and password, \u003Ccode\u003EtestSuccessfulLogin(username,password)\u003C\u002Fcode\u003E which tests only one thing that login should be successful with valid username\u002Fpassword.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"open-closed-principle-ocp-software-entities-classes-modules-functions-etc-should-be-open-for-extension-but-closed-for-modification\" href=\"#open-closed-principle-ocp-software-entities-classes-modules-functions-etc-should-be-open-for-extension-but-closed-for-modification\"\u003E\n  \u003C\u002Fa\u003E\n  Open Closed Principle (OCP): Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EYou should be able to easily add additional functionality for a class without changing its code. OCP says that a class should be open for extension and closed for modification. The “closed” part of the rule states that once a class has been developed and tested, the class code shouldn’t change except for any bug fixes. The “open” part of the rule states that you should be able to extend existing code in order to introduce new functionality. We are trying to add new functionality without modifying the existing code\u002Ffunctionality and by adding new classes\u002Fcode as required. This is very important to minimise the impact of changes and errors from existing code.\u003C\u002Fp\u003E\n\n\u003Cp\u003ELet’s try to understand this principle by looking at an example from our daily life. Let’s say you live in a 2 bedroom house and you are looking for a 3 bedroom house due to reasons like growing children. If you have free\u002Funused space available, it’s very easy to extend the house by building another bedroom. Also with this, you are minimise the impact of changes on the existing 2 bedroom house.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Cem\u003EAutomation Example:\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003ELet’s say that you are automating an online store application. You have Customer class to represent store customers and respective related customer actions. Now, your company has introduced VIP customer concept to reward loyal customers with discounts and free delivery. To implement VIP customer behaviour in your automation, OCP suggests that keep the Customer class same without modifying it and create a new VipCustomer class by inheriting from Customer class. Now in the VipCustomer class extend the behaviour as required.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"liskov-substitution-principle-lsp-subtypes-must-be-substitutable-for-their-base-types\" href=\"#liskov-substitution-principle-lsp-subtypes-must-be-substitutable-for-their-base-types\"\u003E\n  \u003C\u002Fa\u003E\n  Liskov Substitution Principle (LSP): Subtypes must be substitutable for their base types\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EWhen you pass subtype for a base type argument or when you assign\u002Finstantiate base type with subtype, the program\u002Fcode should work properly without changing its behaviour and shouldn’t break. This principle was introduced by and named after Barbara Liskov.\u003C\u002Fp\u003E\n\n\u003Cp\u003ELet’s try to understand this principle by looking at an example from our daily life. Let’s say that you have a wall clock at home or you have a wrist watch. They both need batteries to work. If you buy batteries as per the specifications from any brand like Panasonic, Sony, Duracell, you expect the wall clock or wrist watch to work properly without any issues when powered by those batteries.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Cem\u003EAutomation Example:\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EConsidering the above example of automating an online store application with Customer and VIP Customer categories, let’s say there is a method \u003Ccode\u003EcalculateDeliveryCharge(Customer customer, OrderInfo orderInfo)\u003C\u002Fcode\u003E which calculates delivery charge when customer and order information is passed. When we pass \u003Ccode\u003ECustomer\u003C\u002Fcode\u003E object to \u003Ccode\u003EcalculateDeliveryCharge()\u003C\u002Fcode\u003E method with order information, it should return delivery charge. Note that we are providing free delivery to VIP Customers. So, when we pass \u003Ccode\u003EVipCustomer\u003C\u002Fcode\u003E object for customer argument to \u003Ccode\u003EcalculateDeliveryCharge()\u003C\u002Fcode\u003E method with order information, the program\u002Fcode should work properly without changing its behaviour and shouldn’t throw any exceptions.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"interface-segregation-principle-isp-make-fine-grained-interfaces-that-are-client-specific\" href=\"#interface-segregation-principle-isp-make-fine-grained-interfaces-that-are-client-specific\"\u003E\n  \u003C\u002Fa\u003E\n  Interface Segregation Principle (ISP): Make fine grained interfaces that are client specific\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EIt’s good to have small role specific interfaces rather than one big general interface. ISP states that clients should never be forced to implement interfaces that they don’t use or clients should never be forced to depend on methods that they don’t use. When a class depends upon another class, the number of members visible from the another class to the dependent class should be minimised. When you apply the ISP, classes implement multiple smaller role specific interfaces and dependent classes depend on required role specific interfaces for the given task.\u003C\u002Fp\u003E\n\n\u003Cp\u003ELet’s try to understand this principle by looking at an example from our daily life. When you are travelling in a train and when ticket inspector wants to check your ticket, you will be showing only your ticket and not all your luggage. Similarly, ticket inspector wants to check your ticket only and not any other belongings of you. We should reveal\u002Fexpose only what’s required for the given task.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Cem\u003EAutomation Example:\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003ELet’s again take the example of automating an online store application. You have to test that an email is received by the customer after successful purchase. Let’s say that you have an EmailHelper class with a method \u003Ccode\u003EisEmailReceived()\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\n\u003Cp\u003EYour Customer class might have so many fields and methods like \u003Ccode\u003EfirstName, lastName, emailAddress, phoneNumber, deliveryAddress, billingAddress, getPurchaseHisotry(), getOrdersInProgress()\u003C\u002Fcode\u003E. But \u003Ccode\u003EisEmailReceived()\u003C\u002Fcode\u003E method only needs to know \u003Ccode\u003EfirstName, lastName, emailAddress\u003C\u002Fcode\u003E fields and doesn’t need to now all the other fields\u002Fmethods of Customer class.\u003C\u002Fp\u003E\n\n\u003Cp\u003EConsider implementation like \u003Ccode\u003EisEmailReceived(Customer customer, string subject, string body)\u003C\u002Fcode\u003E: We are exposing whole Customer class in \u003Ccode\u003EisEmailReceived()\u003C\u002Fcode\u003E method and then one can easily access\u002Fchange details like \u003Ccode\u003EphoneNumber, deliveryAddress, billingAddress\u003C\u002Fcode\u003E in \u003Ccode\u003EisEmailReceived()\u003C\u002Fcode\u003E method. We want to minimize the risk to Customer object by passing only details that are required to the clients\u002Fmethods. We can achieve this by below implementation by using an \u003Ccode\u003EEmailable\u003C\u002Fcode\u003E interface which represents a contact that can be emailed.\u003Cbr\u003E\n\u003C\u002Fp\u003E\n\n\u003Cdiv class=\"highlight js-code-highlight\"\u003E\n\u003Cpre class=\"highlight plaintext\"\u003E\u003Ccode\u003Einterface Emailable {\n    String getFirstName();\n    String getLastName();\n    String getEmailAddress();\n}\n\nclass Customer implements Emailable {\n    String firstName, lastName, emailAdddress;\n    String phoneNumber, deliveryAddress, billingAddress;\n\n    public String getFirstName() {\n        return firstName;\n    }\n\n    public String getLastName() {\n        return lastName;\n    }\n\n    public String getEmailAddress() {\n        return emailAdddress;\n    }\n}\n\nclass EmailHelper {\n    public boolean isEmailReceived(Emailable recipient, String subject, String body) {\n        \u002F\u002F Logic to check whether recipient recieved email or not\n\n        \u002F\u002F You can use recipient.getFirstName(), recipient.getLastName(), recipient.getEmailAddress() to get recipient details\n\n        \u002F\u002F When you pass Customer object to this method, only Emailable interface methos are available here and no other details are exposed from Customer Object\n\n        \u002F\u002F Customer object is safe from any changes\n\n        return false;\n    }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cdiv class=\"highlight__panel js-actions-panel\"\u003E\n\u003Cdiv class=\"highlight__panel-action js-fullscreen-code-action\"\u003E\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"\u003E\u003Ctitle\u003EEnter fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"\u003E\u003Ctitle\u003EExit fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\n\n\n\u003Cp\u003ENow, we can further reuse Emailable interface for other types like StoreManager, Supplier to whom your online store sends emails. With this approach, we can use \u003Ccode\u003EisEmailReceived()\u003C\u002Fcode\u003E method with any implementation that implements Emailable interface and respective input object for recipient argument is safe from any changes\u002Factions. I hope now you have understood the power of ISP.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Cem\u003EOther Automation Example:\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003ESelenium API has good examples of ISP. Selenium API has a number of very fine grained, role based client specific interfaces like WebDriver, WebElement, Alert. We should favour role based interfaces instead of generic interfaces.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"dependency-inversion-principle-dip-depend-on-abstractions-not-on-concretions\" href=\"#dependency-inversion-principle-dip-depend-on-abstractions-not-on-concretions\"\u003E\n  \u003C\u002Fa\u003E\n  Dependency Inversion Principle (DIP): Depend on abstractions, not on concretions\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EDIP states that Software entities (classes, modules, functions, etc.) should depend on abstractions (like interfaces) and not on concretions (like concrete class types). DIP promotes code to an interface approach. For example, in Selenium automation code, we code to a WebDriver interface variable “driver” whenever we want to work with web browser and the same code works for any browser type like FirefoxDriver, ChromeDriver, InternetExploerDriver which implements the WebDriver interface.\u003C\u002Fp\u003E\n\n\u003Cp\u003EDIP mainly suggests below 2 rules:\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003EHigh level modules should not depend upon low level modules. Both should depend upon abstractions.\u003C\u002Fli\u003E\n\u003Cli\u003EAbstractions should not depend upon details. Details should depend upon abstractions.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003ELet’s try to understand this principle by looking at an example from our daily life. When you go to a cash machine\u002FATM, the cash machine\u002FATM expects a valid debit\u002Fcredit card. The machine has a dependency on valid card abstraction and not on specific concrete type cards like only Visa, only Maestro or only issued by specific bank. The machine works for any valid card type implementation and we are providing the card to the machine from outside which provides so much flexibility and easiness to use the machine.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Cem\u003EAutomation Example:\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003ELook at below page object class for a Login Page.\u003Cbr\u003E\n\u003C\u002Fp\u003E\n\n\u003Cdiv class=\"highlight js-code-highlight\"\u003E\n\u003Cpre class=\"highlight plaintext\"\u003E\u003Ccode\u003Epublic class LoginPage {\n    private WebDriver driver;\n\n    public LoginPage(WebDriver driver) {\n        this.driver = driver;\n    }\n\n    public void loginAs(String username, String password) {\n        driver.findElement(By.id(\"username\")).sendKeys(username);\n        driver.findElement(By.id(\"password\")).sendKeys(password);\n        driver.findElement(By.name(\"login\")).click();\n    }\n}\n\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cdiv class=\"highlight__panel js-actions-panel\"\u003E\n\u003Cdiv class=\"highlight__panel-action js-fullscreen-code-action\"\u003E\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-on\"\u003E\u003Ctitle\u003EEnter fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n    \u003Csvg xmlns=\"http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg\" width=\"20px\" height=\"20px\" viewbox=\"0 0 24 24\" class=\"highlight-action crayons-icon highlight-action--fullscreen-off\"\u003E\u003Ctitle\u003EExit fullscreen mode\u003C\u002Ftitle\u003E\n    \u003Cpath d=\"M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z\"\u003E\u003C\u002Fpath\u003E\n\u003C\u002Fsvg\u003E\n\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\u003C\u002Fdiv\u003E\n\n\n\n\u003Cp\u003EWe can observe following with respect to DIP from above LoginPage class:\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003EIt is depending on the abstraction and all the code is written against WebDriver interface so that the code can work with any implementation like FirefoxDriver, ChromeDriver, InternetExploerDriver\u003C\u002Fli\u003E\n\u003Cli\u003EThe implementation for the WebDriver interface should be passed by the client through constructor LoginPage(WebDriver driver) when creating the LoginPage object.\u003C\u002Fli\u003E\n\u003Cli\u003ESo the code works for any implementation and we can pass the implementation when creating the object. This gives us lot of flexibility and it will be easy to maintain.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"get-ready-to-useapply-solid-principles-in-your-automation\" href=\"#get-ready-to-useapply-solid-principles-in-your-automation\"\u003E\n  \u003C\u002Fa\u003E\n  Get Ready To Use\u002FApply SOLID Principles In Your Automation…\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EI hope you have got good understanding of SOLID principles by now. If it seems complicated, don’t worry and things will be very clear in the next posts. Let’s look at each principle individually in the next posts to find out how these principles makes us better automation testers and makes our automation easy to understand, use, maintain and extend.\u003C\u002Fp\u003E\n\n";d.body_markdown="**Are you using most recommended and fundamental SOLID principles in your automation?**\n\n## Why You Need To Use SOLID Principles?\nLike any development work, automation also needs to be planned, designed, developed, maintained and extended over time. Your automation code or automation framework is an application which is testing your actual application. That’s why SOLID principles are highly recommend for your automation to make it easy to understand, use, maintain and extend over time. When SOLID principles are not applied, your automation might become fragile, hard to maintain and hard to extend very soon.\n\nEven if you are using different programming language like C#, Python or automation tool like HP UFT\u002FQTP for automation, you should definitely consider applying SOLID principles to make your automation tester life easy. Please note that we will be discussing about applying SOLID principles to web automation using Selenium & Java. But, once you learn the concepts, you can easily apply them to any object-oriented development.\n\nIn this post, we will be exploring what SOLID principles stands for. We will be having one post for each principle with real life examples from web automation using Selenium & Java.\n\n##What Are The SOLID Principles?\nSOLID principles are the first five object-oriented design principles by Robert C. Martin, popularly known as Uncle Bob.\n\nSOLID is an acronym where:\n\n* S stands for Single Responsibility Principle (SRP)\n* O stands for Open Closed Principle (OCP)\n* L stands for Liskov Substitution Principle (LSP)\n* I stands for Interface Segregation Principle (ISP)\n* D stands for Dependency Inversion Principle (DIP)\n\nLet’s explore and understand each individual principle. Also, let’s find out how these SOLID principles make you better automation tester.\n\n## Single Responsibility Principle (SRP): A class should have one, and only one, reason to change\n\nIn other words to achieve this, a class should only have a single responsibility and it should do that very well. Every class in your automation should only have a single responsibility and that all of its methods should be aligned with that responsibility.\n\nLet’s try to understand this principle by looking at an example from our daily life. When you are driving a car\u002Fbike, you want to fully concentrate on the single responsibility – driving. You don’t want to do or concentrate on other tasks like talking on a phone, eating.\n\n*Automation Examples:*\n\n* Page Object Framework implements SRP very well. We are going to have one class responsible for only one web page in the application. We shouldn’t have a very big class with many responsibilities like test methods, UI action methods, excel read\u002Fwrite methods.\n* We can have very specific helper classes like ExcelHelper, DatabaseHelper to work with a excel file or database to implement Data Driven Framework.\n* Selenium API has browser specific driver classes like FirefoxDriver, ChromeDriver, InternetExplorerDriver. FirefoxDriver has single responsibility to drive the Firefox browser and it drives the Firefox browser very well.\n\nWe should also have methods in classes that are very specific like `loginAs(username, password)` to login with given username and password, `testSuccessfulLogin(username,password)` which tests only one thing that login should be successful with valid username\u002Fpassword.\n\n## Open Closed Principle (OCP): Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification\nYou should be able to easily add additional functionality for a class without changing its code. OCP says that a class should be open for extension and closed for modification. The “closed” part of the rule states that once a class has been developed and tested, the class code shouldn’t change except for any bug fixes. The “open” part of the rule states that you should be able to extend existing code in order to introduce new functionality. We are trying to add new functionality without modifying the existing code\u002Ffunctionality and by adding new classes\u002Fcode as required. This is very important to minimise the impact of changes and errors from existing code.\n\nLet’s try to understand this principle by looking at an example from our daily life. Let’s say you live in a 2 bedroom house and you are looking for a 3 bedroom house due to reasons like growing children. If you have free\u002Funused space available, it’s very easy to extend the house by building another bedroom. Also with this, you are minimise the impact of changes on the existing 2 bedroom house.\n\n*Automation Example:*\n\nLet’s say that you are automating an online store application. You have Customer class to represent store customers and respective related customer actions. Now, your company has introduced VIP customer concept to reward loyal customers with discounts and free delivery. To implement VIP customer behaviour in your automation, OCP suggests that keep the Customer class same without modifying it and create a new VipCustomer class by inheriting from Customer class. Now in the VipCustomer class extend the behaviour as required.\n\n## Liskov Substitution Principle (LSP): Subtypes must be substitutable for their base types\nWhen you pass subtype for a base type argument or when you assign\u002Finstantiate base type with subtype, the program\u002Fcode should work properly without changing its behaviour and shouldn’t break. This principle was introduced by and named after Barbara Liskov.\n\nLet’s try to understand this principle by looking at an example from our daily life. Let’s say that you have a wall clock at home or you have a wrist watch. They both need batteries to work. If you buy batteries as per the specifications from any brand like Panasonic, Sony, Duracell, you expect the wall clock or wrist watch to work properly without any issues when powered by those batteries.\n\n*Automation Example:*\n\nConsidering the above example of automating an online store application with Customer and VIP Customer categories, let’s say there is a method `calculateDeliveryCharge(Customer customer, OrderInfo orderInfo)` which calculates delivery charge when customer and order information is passed. When we pass `Customer` object to `calculateDeliveryCharge()` method with order information, it should return delivery charge. Note that we are providing free delivery to VIP Customers. So, when we pass `VipCustomer` object for customer argument to `calculateDeliveryCharge()` method with order information, the program\u002Fcode should work properly without changing its behaviour and shouldn’t throw any exceptions.\n\n## Interface Segregation Principle (ISP): Make fine grained interfaces that are client specific\nIt’s good to have small role specific interfaces rather than one big general interface. ISP states that clients should never be forced to implement interfaces that they don’t use or clients should never be forced to depend on methods that they don’t use. When a class depends upon another class, the number of members visible from the another class to the dependent class should be minimised. When you apply the ISP, classes implement multiple smaller role specific interfaces and dependent classes depend on required role specific interfaces for the given task.\n\nLet’s try to understand this principle by looking at an example from our daily life. When you are travelling in a train and when ticket inspector wants to check your ticket, you will be showing only your ticket and not all your luggage. Similarly, ticket inspector wants to check your ticket only and not any other belongings of you. We should reveal\u002Fexpose only what’s required for the given task.\n\n*Automation Example:*\n\nLet’s again take the example of automating an online store application. You have to test that an email is received by the customer after successful purchase. Let’s say that you have an EmailHelper class with a method `isEmailReceived()`.\n\nYour Customer class might have so many fields and methods like `firstName, lastName, emailAddress, phoneNumber, deliveryAddress, billingAddress, getPurchaseHisotry(), getOrdersInProgress()`. But `isEmailReceived()` method only needs to know `firstName, lastName, emailAddress` fields and doesn’t need to now all the other fields\u002Fmethods of Customer class.\n\nConsider implementation like `isEmailReceived(Customer customer, string subject, string body)`: We are exposing whole Customer class in `isEmailReceived()` method and then one can easily access\u002Fchange details like `phoneNumber, deliveryAddress, billingAddress` in `isEmailReceived()` method. We want to minimize the risk to Customer object by passing only details that are required to the clients\u002Fmethods. We can achieve this by below implementation by using an `Emailable` interface which represents a contact that can be emailed.\n\n```\ninterface Emailable {\n    String getFirstName();\n    String getLastName();\n    String getEmailAddress();\n}\n\nclass Customer implements Emailable {\n    String firstName, lastName, emailAdddress;\n    String phoneNumber, deliveryAddress, billingAddress;\n\n    public String getFirstName() {\n        return firstName;\n    }\n\n    public String getLastName() {\n        return lastName;\n    }\n\n    public String getEmailAddress() {\n        return emailAdddress;\n    }\n}\n\nclass EmailHelper {\n    public boolean isEmailReceived(Emailable recipient, String subject, String body) {\n        \u002F\u002F Logic to check whether recipient recieved email or not\n\n        \u002F\u002F You can use recipient.getFirstName(), recipient.getLastName(), recipient.getEmailAddress() to get recipient details\n\n        \u002F\u002F When you pass Customer object to this method, only Emailable interface methos are available here and no other details are exposed from Customer Object\n\n        \u002F\u002F Customer object is safe from any changes\n\n        return false;\n    }\n}\n```\nNow, we can further reuse Emailable interface for other types like StoreManager, Supplier to whom your online store sends emails. With this approach, we can use `isEmailReceived()` method with any implementation that implements Emailable interface and respective input object for recipient argument is safe from any changes\u002Factions. I hope now you have understood the power of ISP.\n\n*Other Automation Example:*\n\nSelenium API has good examples of ISP. Selenium API has a number of very fine grained, role based client specific interfaces like WebDriver, WebElement, Alert. We should favour role based interfaces instead of generic interfaces.\n\n## Dependency Inversion Principle (DIP): Depend on abstractions, not on concretions\nDIP states that Software entities (classes, modules, functions, etc.) should depend on abstractions (like interfaces) and not on concretions (like concrete class types). DIP promotes code to an interface approach. For example, in Selenium automation code, we code to a WebDriver interface variable “driver” whenever we want to work with web browser and the same code works for any browser type like FirefoxDriver, ChromeDriver, InternetExploerDriver which implements the WebDriver interface.\n\nDIP mainly suggests below 2 rules:\n\n* High level modules should not depend upon low level modules. Both should depend upon abstractions.\n* Abstractions should not depend upon details. Details should depend upon abstractions.\n\nLet’s try to understand this principle by looking at an example from our daily life. When you go to a cash machine\u002FATM, the cash machine\u002FATM expects a valid debit\u002Fcredit card. The machine has a dependency on valid card abstraction and not on specific concrete type cards like only Visa, only Maestro or only issued by specific bank. The machine works for any valid card type implementation and we are providing the card to the machine from outside which provides so much flexibility and easiness to use the machine.\n\n*Automation Example:*\n\nLook at below page object class for a Login Page.\n\n```\npublic class LoginPage {\n    private WebDriver driver;\n\n    public LoginPage(WebDriver driver) {\n        this.driver = driver;\n    }\n\n    public void loginAs(String username, String password) {\n        driver.findElement(By.id(\"username\")).sendKeys(username);\n        driver.findElement(By.id(\"password\")).sendKeys(password);\n        driver.findElement(By.name(\"login\")).click();\n    }\n}\n\n```\n\nWe can observe following with respect to DIP from above LoginPage class:\n\n* It is depending on the abstraction and all the code is written against WebDriver interface so that the code can work with any implementation like FirefoxDriver, ChromeDriver, InternetExploerDriver\n* The implementation for the WebDriver interface should be passed by the client through constructor LoginPage(WebDriver driver) when creating the LoginPage object.\n* So the code works for any implementation and we can pass the implementation when creating the object. This gives us lot of flexibility and it will be easy to maintain.\n\n## Get Ready To Use\u002FApply SOLID Principles In Your Automation…\nI hope you have got good understanding of SOLID principles by now. If it seems complicated, don’t worry and things will be very clear in the next posts. Let’s look at each principle individually in the next posts to find out how these principles makes us better automation testers and makes our automation easy to understand, use, maintain and extend.";d.user={name:f,username:f,twitter_username:a,github_username:"Ampei",website_url:a,profile_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--cwbDRUrN--\u002Fc_fill,f_auto,fl_progressive,h_640,q_auto,w_640\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F322817\u002F8fccfe66-b150-4b5b-b148-db1f966d997d.jpg",profile_image_90:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--du_vL58d--\u002Fc_fill,f_auto,fl_progressive,h_90,q_auto,w_90\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F322817\u002F8fccfe66-b150-4b5b-b148-db1f966d997d.jpg"};return {data:[{}],fetch:{"data-v-25febe66:0":{article:d}},mutations:[["SET_CURRENT_ARTICLE",d]]}}(null,8,"2021-06-24T20:51:47Z",{},"https:\u002F\u002Fdev.to\u002Fgusdmoreira\u002Fuse-solid-principles-to-become-better-automation-tester-3kg9","gusdmoreira")));