window.__NUXT__=(function(a,b,c,d,e){return {staticAssetsBase:"\u002F_nuxt\u002Fstatic\u002F1634322943",layout:"default",error:a,state:{currentArticle:{type_of:"article",id:557274,title:"Architecture documentation authoring and dissemination",description:"writing and publishing your architecture documentation",readable_publish_date:"Jan 1",slug:"architecture-documentation-authoring-and-dissemination-53gg",path:"\u002Fsebastienandreo\u002Farchitecture-documentation-authoring-and-dissemination-53gg",url:c,comments_count:1,public_reactions_count:b,collection_id:a,published_timestamp:d,positive_reactions_count:b,cover_image:a,social_image:"https:\u002F\u002Fdev.to\u002Fsocial_previews\u002Farticle\u002F557274.png",canonical_url:c,created_at:"2020-12-31T12:13:48Z",edited_at:a,crossposted_at:a,published_at:d,last_comment_at:"2021-04-12T09:45:00Z",reading_time_minutes:b,tag_list:"architecture, jekyll, productivity",tags:["architecture","jekyll","productivity"],body_html:"\u003Cp\u003EThis article will present how I envisage software documentation from the development, and tooling side.\u003Cbr\u003E\nFirst of all, architecture documentation is a critical asset as soon as you are more than two or three in the team. As Nikolay described in \u003Ca href=\"https:\u002F\u002Fmedium.com\u002F@nvashanin\u002Fdocumentation-in-software-architecture-4f2e4159c4fc\"\u003Ehis article\u003C\u002Fa\u003E, the primary goals are knowledge sharing, communication, and analyses. But documenting the system's architecture is a difficult task. You always face the divergence between code and the documentation. Word\u002Fpdf documents or modelization files contain the documentation, making it challenging to find information and navigate between the artifacts.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--URZaSAAX--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fandreo.eu\u002Fassets\u002Fimages\u002F2020-12-28-arch-doc\u002Fpict1.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--URZaSAAX--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fandreo.eu\u002Fassets\u002Fimages\u002F2020-12-28-arch-doc\u002Fpict1.png\" alt=\"\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EFor sure we can argue that each tool addresses different stakeholder needs. A modeling tool might be the preferred tool for a software architect, the repository selected by a developer, and a pdf for a management level. But we have to be honest; maintaining all is a pain. While setting up the documentation with my team, I asked the group: \"what do we\u002Fthey \"feel\" about the architecture and the documentation? It came out that:\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003EArchitecture is mostly from developers for developers\u003C\u002Fli\u003E\n\u003Cli\u003EArchitecture is living; it changes iterations after iterations\u003C\u002Fli\u003E\n\u003Cli\u003ECode and architecture always diverge over time\u003C\u002Fli\u003E\n\u003Cli\u003EArchitecture is not a book you read from page one to the end\u003C\u002Fli\u003E\n\u003Cli\u003EArchitecture is not something to fulfill a process step, but it needs a process\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003EBased on those thoughts, the concept of content as code was quite promising. Indeed the same rules should apply for the documentation as for the code. If the architecture is from developers for developers, why not use the same tool landscape (e.g., Git, vscode, or any IDE). Architecture is a living object like code, and it is also a critical asset we can apply the same processes (e.g., Quality gates within a CI, Merge Requestâ€¦). Architecture and code always diverge over time; maybe putting them together might reduce the risk.\u003Cbr\u003E\nWe ended with a classical developer tool landscape for the authoring part: Gitlab or any other source control system, markdown for the content, and Git for versioning.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--n2odwjIG--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fandreo.eu\u002Fassets\u002Fimages\u002F2020-12-28-arch-doc\u002Fpict2.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--n2odwjIG--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fandreo.eu\u002Fassets\u002Fimages\u002F2020-12-28-arch-doc\u002Fpict2.png\" alt=\"\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EWith that solution, we were able to guarantee:\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003EThe versioning: the documentation evolves like the code following the same life cycle.\u003C\u002Fli\u003E\n\u003Cli\u003EThe quality, with merge requests like code\u003C\u002Fli\u003E\n\u003Cli\u003EThe traceability: with the ability to compare different versions as we are text-based.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003EThe authoring aspect is addressed, but the reader's side was still not implemented. The team mentioned that you do not read architecture documentation like a book, starting from page one to the end. We prefer to navigate from a piece of information to another, from a high level of abstraction to an implementation detail. Fundamentally the reader wants to navigate! Which system has in his heart the navigability? \u003Cstrong\u003EThe Web\u003C\u002Fstrong\u003E indeed! The documentation should be web-based. The web is navigable, links are the heart of the web, and with a single URL, you can dive into your documentation.\u003Cbr\u003E\n\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--ltwXDt-5--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fandreo.eu\u002Fassets\u002Fimages\u002F2020-12-28-arch-doc\u002Fpict3.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--ltwXDt-5--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fandreo.eu\u002Fassets\u002Fimages\u002F2020-12-28-arch-doc\u002Fpict3.png\" alt=\"\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EAs depicted in the previous picture, we extended our tool landscape to generate a static website with Jekyll and the full integration into our CI\u002FCD pipeline. Now the generated website is a kind of artifact like any dll or cloud deployment. It is synchronized with the code. It is readable to anyone who has the URL, and the unique tool needed by a reader is a web browser.\u003C\u002Fp\u003E\n\n\u003Cp\u003ETo conclude, in this article I presented how I tried with my team to address the authoring and dissemination of software architecture. Below some links to tools or concepts I used. In the next article, I will present how we handled the architecture diagrams.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"links\" href=\"#links\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  Links\n\u003C\u002Fh2\u003E\n\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.writethedocs.org\u002Fguide\u002Fdocs-as-code\u002F\"\u003EDocumentation as code \u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fjekyllrb.com\u002F\"\u003Ejekyll\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fgitlab.com\u002FSebastienAndreo\u002Fjekyll-ci\"\u003Emy CI image\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n",body_markdown:"---\ntitle: Architecture documentation authoring and dissemination\npublished: true\ndescription: writing and publishing your architecture documentation\ntags: architecture, jekyll, productivity\n\u002F\u002Fcover_image: https:\u002F\u002Fdirect_url_to_image.jpg\n---\n\nThis article will present how I envisage software documentation from the development, and tooling side.\nFirst of all, architecture documentation is a critical asset as soon as you are more than two or three in the team. As Nikolay described in [his article](https:\u002F\u002Fmedium.com\u002F@nvashanin\u002Fdocumentation-in-software-architecture-4f2e4159c4fc), the primary goals are knowledge sharing, communication, and analyses. But documenting the system's architecture is a difficult task. You always face the divergence between code and the documentation. Word\u002Fpdf documents or modelization files contain the documentation, making it challenging to find information and navigate between the artifacts.\n\n![](https:\u002F\u002Fandreo.eu\u002Fassets\u002Fimages\u002F2020-12-28-arch-doc\u002Fpict1.png)\n\nFor sure we can argue that each tool addresses different stakeholder needs. A modeling tool might be the preferred tool for a software architect, the repository selected by a developer, and a pdf for a management level. But we have to be honest; maintaining all is a pain. While setting up the documentation with my team, I asked the group: \"what do we\u002Fthey \"feel\" about the architecture and the documentation? It came out that:\n- Architecture is mostly from developers for developers\n- Architecture is living; it changes iterations after iterations\n- Code and architecture always diverge over time\n- Architecture is not a book you read from page one to the end\n- Architecture is not something to fulfill a process step, but it needs a process\n\nBased on those thoughts, the concept of content as code was quite promising. Indeed the same rules should apply for the documentation as for the code. If the architecture is from developers for developers, why not use the same tool landscape (e.g., Git, vscode, or any IDE). Architecture is a living object like code, and it is also a critical asset we can apply the same processes (e.g., Quality gates within a CI, Merge Requestâ€¦). Architecture and code always diverge over time; maybe putting them together might reduce the risk.\nWe ended with a classical developer tool landscape for the authoring part: Gitlab or any other source control system, markdown for the content, and Git for versioning.\n\n![](https:\u002F\u002Fandreo.eu\u002Fassets\u002Fimages\u002F2020-12-28-arch-doc\u002Fpict2.png)\n\nWith that solution, we were able to guarantee:\n- The versioning: the documentation evolves like the code following the same life cycle.\n- The quality, with merge requests like code\n- The traceability: with the ability to compare different versions as we are text-based.\n\nThe authoring aspect is addressed, but the reader's side was still not implemented. The team mentioned that you do not read architecture documentation like a book, starting from page one to the end. We prefer to navigate from a piece of information to another, from a high level of abstraction to an implementation detail. Fundamentally the reader wants to navigate! Which system has in his heart the navigability? **The Web** indeed! The documentation should be web-based. The web is navigable, links are the heart of the web, and with a single URL, you can dive into your documentation.\n![](https:\u002F\u002Fandreo.eu\u002Fassets\u002Fimages\u002F2020-12-28-arch-doc\u002Fpict3.png)\n\nAs depicted in the previous picture, we extended our tool landscape to generate a static website with Jekyll and the full integration into our CI\u002FCD pipeline. Now the generated website is a kind of artifact like any dll or cloud deployment. It is synchronized with the code. It is readable to anyone who has the URL, and the unique tool needed by a reader is a web browser.\n\nTo conclude, in this article I presented how I tried with my team to address the authoring and dissemination of software architecture. Below some links to tools or concepts I used. In the next article, I will present how we handled the architecture diagrams.\n\n## Links\n- [Documentation as code ](https:\u002F\u002Fwww.writethedocs.org\u002Fguide\u002Fdocs-as-code\u002F)\n- [jekyll](https:\u002F\u002Fjekyllrb.com\u002F)\n- [my CI image](https:\u002F\u002Fgitlab.com\u002FSebastienAndreo\u002Fjekyll-ci )\n",user:{name:"SÃ©bastien",username:"sebastienandreo",twitter_username:e,github_username:e,website_url:"https:\u002F\u002Fandreo.eu\u002F",profile_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--quGuSwdQ--\u002Fc_fill,f_auto,fl_progressive,h_640,q_auto,w_640\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F122282\u002F46fbf85a-49b9-466d-9d16-1b95b813e1f2.jpeg",profile_image_90:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--zZKt2cz6--\u002Fc_fill,f_auto,fl_progressive,h_90,q_auto,w_90\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F122282\u002F46fbf85a-49b9-466d-9d16-1b95b813e1f2.jpeg"}}},serverRendered:true,routePath:"\u002Farticles\u002Fsebastienandreo\u002F557274",config:{_app:{basePath:"\u002F",assetsPath:"\u002F_nuxt\u002F",cdnURL:a}}}}(null,3,"https:\u002F\u002Fdev.to\u002Fsebastienandreo\u002Farchitecture-documentation-authoring-and-dissemination-53gg","2021-01-01T13:07:58Z","SebastienAndreo"));