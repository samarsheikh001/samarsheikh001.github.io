window.__NUXT__=(function(a,b,c,d,e,f){return {staticAssetsBase:"\u002F_nuxt\u002Fstatic\u002F1634322943",layout:"default",error:a,state:{currentArticle:{type_of:"article",id:823241,title:"วิธีการติดตั้งและใช้งาน Flux (GitOps tool) บน Amazon EKS - Part 1",description:"Introduction   GitOps[1] เป็นการนำ tool, best practice และประโยชน์ต่างๆจาก Git และ...",readable_publish_date:"Sep 15",slug:"flux-gitops-tool-amazon-eks-part-1-4gla",path:"\u002Fawscommunity-asean\u002Fflux-gitops-tool-amazon-eks-part-1-4gla",url:c,comments_count:0,public_reactions_count:d,collection_id:a,published_timestamp:b,positive_reactions_count:d,cover_image:a,social_image:"https:\u002F\u002Fdev.to\u002Fsocial_previews\u002Farticle\u002F823241.png",canonical_url:c,created_at:"2021-09-14T05:31:07Z",edited_at:"2021-09-16T14:17:22Z",crossposted_at:a,published_at:b,last_comment_at:b,reading_time_minutes:3,tag_list:"flux, gitops, eks, awsthai",tags:["flux","gitops","eks","awsthai"],body_html:"\u003Ch3\u003E\n  \u003Ca name=\"introduction\" href=\"#introduction\"\u003E\n  \u003C\u002Fa\u003E\n  Introduction\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003EGitOps[1] เป็นการนำ tool, best practice และประโยชน์ต่างๆจาก Git และ Continuous Integration\u002FContinuous Delivery (CI\u002FCD) ที่มีการใช้งานกันเป็น standard ใน Software Development Life Cycle (SDLC) มาใช้ร่วมกับ Infrastructure as Code (IaC) ในทางฝั่งของ IT operation เพื่อจัดการกับ infrastructure ต่างๆ\u003C\u002Fp\u003E\n\n\u003Cp\u003EFlux[2] เป็นหนึ่งใน GitOps tool ที่ได้รับได้ความนิยมในปัจจุบัน เพื่อใช้การใช้จัดการ resource ต่างๆบน Kubernetes cluster โดย version ที่ใช้ในปัจจุบันคือ Flux v2 ซึ่งตัว Flux operator ใน cluster จะทำการ pull ตัว declarative (IaC) จาก Git repository และทำการ reconcile Kubernetes resource ต่างๆให้ตรงตามนั้น\u003C\u002Fp\u003E\n\n\u003Cp\u003Eใน blog post นี้เราจะมาดูการติดตั้งและใช้งาน Flux ในเบื้องต้นกัน\u003C\u002Fp\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"prerequisites\" href=\"#prerequisites\"\u003E\n  \u003C\u002Fa\u003E\n  Prerequisites\n\u003C\u002Fh3\u003E\n\n\u003Cul\u003E\n\u003Cli\u003Eทำการติดตั้ง \u003Ca href=\"https:\u002F\u002Feksctl.io\u002Fintroduction\u002F#installation\"\u003E\u003Ccode\u003Eeksctl\u003C\u002Fcode\u003E\u003C\u002Fa\u003E และ \u003Ca href=\"https:\u002F\u002Ffluxcd.io\u002Fdocs\u002Finstallation\u002F\"\u003E\u003Ccode\u003Eflux\u003C\u002Fcode\u003E\u003C\u002Fa\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003Eสร้าง \u003Ca href=\"https:\u002F\u002Fdocs.github.com\u002Fen\u002Fgithub\u002Fauthenticating-to-github\u002Fkeeping-your-account-and-data-secure\u002Fcreating-a-personal-access-token\"\u003E\u003Ccode\u003Epersonal access token\u003C\u002Fcode\u003E\u003C\u002Fa\u003E บน GitHub account\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"how-to-setup-flux-on-amazon-eks-cluster\" href=\"#how-to-setup-flux-on-amazon-eks-cluster\"\u003E\n  \u003C\u002Fa\u003E\n  How to setup Flux on Amazon EKS cluster\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003Eeksctl[3] เป็นหนึ่งใน standard tool ที่ใช้ในการสร้างและจัดการ EKS cluster และตั้งแต่ vesion \u003Ccode\u003E0.53.0\u003C\u002Fcode\u003E จะมี feature ในการติดตั้ง Flux รวมอยู่ด้วย\u003C\u002Fp\u003E\n\n\u003Cp\u003Eขั้นตอนในการสร้าง EKS cluster ใหม่และติดตั้ง Flux โดยอัตโนมัติ\u003C\u002Fp\u003E\n\n\u003Col\u003E\n\u003Cli\u003E\n\u003Cp\u003Eexport ค่าต่างๆที่จะต้องใช้ในขั้นตอนต่อๆไป\u003Cbr\u003E\n\u003C\u002Fp\u003E\n\u003Cpre class=\"highlight plaintext\"\u003E\u003Ccode\u003Eexport GITHUB_USERNAME=&lt;your GitHub username&gt;\nexport GITHUB_TOKEN=&lt;your GitHub personal access token&gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003Eสร้าง config file ด้วย code ด้านล่างนี้และเปลี่ยน \u003Ccode\u003E&lt;GitHub username&gt;\u003C\u002Fcode\u003E เป็นชื่อ GitHub username ของเรา\u003Cbr\u003E\n\u003C\u002Fp\u003E\n\u003Cpre class=\"highlight plaintext\"\u003E\u003Ccode\u003Ecat &lt;&lt; EOF &gt; eks-gitops-demo.yaml\napiVersion: eksctl.io\u002Fv1alpha5\nkind: ClusterConfig\n\nmetadata:\n  name: eks-gitops-demo\n  region: ap-southeast-1\n\nmanagedNodeGroups:\n  - name: ng-1\n    instanceType: m5.large\n    desiredCapacity: 1\n\ngitops:\n  flux:\n    gitProvider: github\n    flags:\n      owner: \"${GITHUB_USERNAME}\"\n      personal: \"true\"\n      private: \"true\"\n      repository: \"eks-gitops-demo\"\n      branch: \"master\"\n      namespace: \"flux-system\"\n      path: \"clusters\u002Feks-gitops-demo\"\nEOF\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Eทำการสร้าง EKS cluster โดยใช้คำสั่ง \u003Ccode\u003Eeksctl create cluster --config-file eks-gitops-demo.yaml\u003C\u002Fcode\u003E และรอจน cluster สร้างเสร็จ\u003C\u002Fp\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Eเราสามารถเช็ค resource ต่างๆที่เกี่ยวกับ Flux โดยใช้คำสั่ง \u003Ccode\u003Ekubectl --namespace flux-system get all\u003C\u002Fcode\u003E\u003Cbr\u003E\n\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--K_8YwZvr--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fs6jtbd9fsfcd1rwi4bwz.jpg\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--K_8YwZvr--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fs6jtbd9fsfcd1rwi4bwz.jpg\" alt=\"Alt Text\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Eและใน GitHub account ของเราจะมี repository ใหม่ที่ชื่อ \u003Ccode\u003Eeks-gitops-demo\u003C\u002Fcode\u003E ถูกสร้างขึ้นมาและมี commit ในส่วนของ Kubernetes manifest file ของ Flux component ต่างๆ\u003Cbr\u003E\n\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--Siz0kpKS--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fmhynb58ha1sold17px72.jpg\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--Siz0kpKS--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fmhynb58ha1sold17px72.jpg\" alt=\"Alt Text\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\n\u003Cp\u003Eถึงตรงนี้แสดงว่าขั้นตอนการสร้าง EKS cluster ใหม่ที่มีการติดตั้ง Flux มาด้วยเป็นอันเสร็จสมบูรณ์แล้ว\u003C\u002Fp\u003E\n\n\u003Cp\u003ENote. สำหรับกรณีที่เป็น EKS cluster เดิมหรือต้องการติดตั้ง Flux แยกทีหลัง\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003Eในกรณีที่ cluster ที่ถูกสร้างด้วย eksctl เราสามารถติดตั้ง Flux โดยการใช้คำสั่ง \u003Ca href=\"https:\u002F\u002Feksctl.io\u002Fusage\u002Fgitops-v2\u002F\"\u003E\u003Ccode\u003Eeksctl enable flux\u003C\u002Fcode\u003E\u003C\u002Fa\u003E ได้\u003C\u002Fli\u003E\n\u003Cli\u003Eในกรณีที่ไม่ได้ใช้ eksctl เราสามารถติดตั้ง Flux โดยการใช้ flux CLI และคำสั่ง \u003Ca href=\"https:\u002F\u002Ffluxcd.io\u002Fdocs\u002Finstallation\u002F\"\u003E\u003Ccode\u003Eflux bootstrap\u003C\u002Fcode\u003E\u003C\u002Fa\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"how-to-use-flux-basic-features\" href=\"#how-to-use-flux-basic-features\"\u003E\n  \u003C\u002Fa\u003E\n  How to use Flux basic features\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003Eต่อมาเราจะมาดูการใช้งาน Flux แบบเบื้องต้นกัน\u003C\u002Fp\u003E\n\n\u003Cp\u003Eตัวอย่างแรกจะเป็นการใช้ Kubernetes manifest file ตามปกติ\u003C\u002Fp\u003E\n\n\u003Col\u003E\n\u003Cli\u003E\n\u003Cp\u003Eเริ่มต้นจากการ clone GitHub repository ที่ Flux ได้สร้างขึ้นมา\u003Cbr\u003E\n\u003C\u002Fp\u003E\n\u003Cpre class=\"highlight plaintext\"\u003E\u003Ccode\u003Egit clone git@github.com:${GITHUB_USERNAME}\u002Feks-gitops-demo.git\ncd eks-gitops-demo\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003Eหลังจากนั้นเราจะสร้าง Kubernetes manifest file สำหรับ \u003Ccode\u003Enginx:1.14.2\u003C\u002Fcode\u003E deployment แล้วทำการ commit และ push ไปยัง GitHub\u003Cbr\u003E\n\u003C\u002Fp\u003E\n\u003Cpre class=\"highlight plaintext\"\u003E\u003Ccode\u003Emkdir -p clusters\u002Feks-gitops-demo\u002Fdefault\u002Fnginx\n\ncat &lt;&lt; EOF &gt; clusters\u002Feks-gitops-demo\u002Fdefault\u002Fnginx\u002Fdeployment.yaml\napiVersion: apps\u002Fv1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\n  labels:\n    app: nginx\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.14.2\n        ports:\n        - containerPort: 80\nEOF\n\ngit add clusters\u002Feks-gitops-demo\u002Fdefault\u002Fnginx\u002Fdeployment.yaml\ngit commit -m \"Add Nginx deployment\"\ngit push\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Eตามค่า default config Flux จะ pull ข้อมูลจาก GitHub ทุกๆ 10 นาทีและทำการ reconcile Kubernetes resource แต่เราสามารถใช้คำสั่ง \u003Ccode\u003Eflux reconcile source git flux-system\u003C\u002Fcode\u003E เพื่อทำการ pull โดยทันทีได้\u003Cbr\u003E\n\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--OfUosAny--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fwtob1udj0lzhomopaq3d.jpg\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--OfUosAny--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fwtob1udj0lzhomopaq3d.jpg\" alt=\"Alt Text\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Eหลังจากนั้นเราสามารถเช็คได้ว่า Flux ทำการ apply change ต่างๆและมีการสร้าง Kubernetes deployment ขึ้นมา โดยใช้คำสั่ง \u003Ccode\u003Ekubectl get deployment nginx-deployment\u003C\u002Fcode\u003E\u003Cbr\u003E\n\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--7Ab1Ho6f--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fxbusoxtmat7xu0bdq0ou.jpg\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--7Ab1Ho6f--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fxbusoxtmat7xu0bdq0ou.jpg\" alt=\"Alt Text\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003Eหลังจากนั้นลองทำการเปลี่ยนใน deployment manifest file \u003Ccode\u003Enginx:1.15.0\u003C\u002Fcode\u003E และทำการ commit และ push ไปยัง GitHub อีกครั้งนึง\u003Cbr\u003E\n\u003C\u002Fp\u003E\n\u003Cpre class=\"highlight plaintext\"\u003E\u003Ccode\u003Esed -i '' 's\u002F1.14.2\u002F1.15.0\u002F' clusters\u002Feks-gitops-demo\u002Fdefault\u002Fnginx\u002Fdeployment.yaml\n\ngit add clusters\u002Feks-gitops-demo\u002Fdefault\u002Fnginx\u002Fdeployment.yaml\ngit commit -m \"Change Nginx image to 1.15.0\"\ngit push\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Eหลังจาก Flux ทำการ reconcile เสร็จ จะเห็นได้ว่า deployment มีการเปลี่ยนไปใช้ \u003Ccode\u003Enginx:1.15.0\u003C\u002Fcode\u003E\u003Cbr\u003E\n\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--fHplhQZ2--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fra7rbztybg0rqm3mx8fc.jpg\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--fHplhQZ2--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fra7rbztybg0rqm3mx8fc.jpg\" alt=\"Alt Text\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\n\u003Cp\u003E7.(Bonus) ถ้าลองลบ deployment manifest แล้วทำการ commit และ push ไปยัง GitHub หลังจาก Flux ทำการ reconcile เสร็จ จะเห็นได้ว่าตัว deployment ของ nginx จะถูกลบไปเช่นกัน\u003C\u002Fp\u003E\n\n\u003Cp\u003Eอีกตัวอย่างนึงจะเป็นการใช้งาน Flux ร่วมกับ Helm\u003C\u002Fp\u003E\n\n\u003Col\u003E\n\u003Cli\u003E\n\u003Cp\u003Eเริ่มต้นจากการสร้าง HelmRepository CRD ที่ชี้ไปยัง Helm Chart repository ในตัวอย่างนี้เราจะใช้ \u003Ca href=\"https:\u002F\u002Fprometheus-community.github.io\u002Fhelm-charts\"\u003E\u003Ccode\u003Eprometheus-community\u003C\u002Fcode\u003E\u003C\u002Fa\u003E\u003Cbr\u003E\n\u003C\u002Fp\u003E\n\u003Cpre class=\"highlight plaintext\"\u003E\u003Ccode\u003Emkdir -p clusters\u002Feks-gitops-demo\u002Fmonitoring\n\ncat &lt;&lt; EOF &gt; clusters\u002Feks-gitops-demo\u002Fmonitoring\u002Fnamespace.yaml\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: monitoring\nEOF\n---\ncat &lt;&lt; EOF &gt; clusters\u002Feks-gitops-demo\u002Fmonitoring\u002Fprometheus-community.yaml\napiVersion: source.toolkit.fluxcd.io\u002Fv1beta1\nkind: HelmRepository\nmetadata:\n  name: prometheus-community\n  namespace: monitoring\nspec:\n  url: https:\u002F\u002Fprometheus-community.github.io\u002Fhelm-charts\n  interval: 10m\nEOF\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp\u003Eหลังจากนั้นทำการสร้าง HelmRelease CRD สำหรับที่จะให้ Flux deploy โดยใช้ Chart ที่ชื่อ \u003Ccode\u003Ekube-prometheus-stack\u003C\u002Fcode\u003E หลังจากนั้นทำการ commit และ push ไปยัง GitHub\u003Cbr\u003E\n\u003C\u002Fp\u003E\n\u003Cpre class=\"highlight plaintext\"\u003E\u003Ccode\u003Emkdir -p clusters\u002Feks-gitops-demo\u002Fmonitoring\n\ncat &lt;&lt; EOF &gt; clusters\u002Feks-gitops-demo\u002Fmonitoring\u002Fnamespace.yaml\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: monitoring\nEOF\n\ncat &lt;&lt; EOF &gt; clusters\u002Feks-gitops-demo\u002Fmonitoring\u002Fkube-prometheus-stack.yaml\napiVersion: helm.toolkit.fluxcd.io\u002Fv2beta1\nkind: HelmRelease\nmetadata:\n  name: kube-prometheus-stack\n  namespace: monitoring\nspec:\n  releaseName: kube-prometheus-stack\n  interval: 10m\n  chart:\n    spec:\n      chart: kube-prometheus-stack\n      sourceRef:\n        kind: HelmRepository\n        name: prometheus-community\n        namespace: monitoring\nEOF\n\ngit add clusters\u002Feks-gitops-demo\u002Fmonitoring\u002F*\ngit commit -m \"Add Prometheus with Helm\"\ngit push\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Eหลักจากนั้นใช้คำสั่ง \u003Ccode\u003Eflux reconcile source git flux-system\u003C\u002Fcode\u003E เพื่อ pull change จาก GitHub และเนื่องจากใน HelmRelease CRD เราตั้ง interval ในการ reconcile เป็นทุกๆ 10 นาที เราสามารถใช้คำสั่ง \u003Ccode\u003Eflux --namespace monitoring reconcile helmrelease kube-prometheus-stack\u003C\u002Fcode\u003E เพื่อให้ reconcile ทันทีได้เช่นกัน\u003Cbr\u003E\n\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--x48IyWzb--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fbpaokz1a1zb0b4iv74uh.jpg\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--x48IyWzb--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fbpaokz1a1zb0b4iv74uh.jpg\" alt=\"Alt Text\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Eหลักจาก reconcile เสร็จสิ้น เราสามารถเช็คได้ว่า resource ต่างๆสำหรับ Prometheus ได้มีการติดตั้งใน cluster อย่างถูกต้องโดย Helm Chart ผ่าน Flux\u003Cbr\u003E\n\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--SU_zA0rX--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fhur9rqc565v8oxi7n616.jpg\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--SU_zA0rX--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fhur9rqc565v8oxi7n616.jpg\" alt=\"Alt Text\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"conclusion\" href=\"#conclusion\"\u003E\n  \u003C\u002Fa\u003E\n  Conclusion\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003EGitOps เป็นการนำเทคนิคและการใช้งาน Git, CI\u002FCD และ IaC มาประกอบกันเพื่อให้เราสามารถจัดการ infrastructure ได้อย่างมีประสิทธิภาพและลดความผิดพลาดที่อาจจะเกิดขึ้นจาก manual process\u003C\u002Fp\u003E\n\n\u003Cp\u003EFlux เป็น tool ที่ช่วยให้เราสามารถ implement GitOps บน Kubernetes ได้อย่างสะดวกยิ่งขึ้น ซึ่งใน blog post นี้เราได้เห็นวิธีการติดตั้งบน Amazon EKS ผ่าน eksctl\u003C\u002Fp\u003E\n\n\u003Cp\u003Eหลังจากนั้นเราได้เห็นตัวอย่างวิธีการติดใช้งาน Flux ในเบื้องต้น และใน part ที่ 2 เราจะมาดูตัวอย่างและ feature อื่นๆของ Flux กัน\u003C\u002Fp\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"references\" href=\"#references\"\u003E\n  \u003C\u002Fa\u003E\n  References\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003E[1] \u003Ca href=\"https:\u002F\u002Fwww.gitops.tech\u002F#what-is-gitops\"\u003Ehttps:\u002F\u002Fwww.gitops.tech\u002F#what-is-gitops\u003C\u002Fa\u003E\u003Cbr\u003E\n[2] \u003Ca href=\"https:\u002F\u002Ffluxcd.io\u002F\"\u003Ehttps:\u002F\u002Ffluxcd.io\u002F\u003C\u002Fa\u003E\u003Cbr\u003E\n[3] \u003Ca href=\"https:\u002F\u002Feksctl.io\u002F\"\u003Ehttps:\u002F\u002Feksctl.io\u002F\u003C\u002Fa\u003E\u003Cbr\u003E\n[4] \u003Ca href=\"https:\u002F\u002Fhelm.sh\u002F\"\u003Ehttps:\u002F\u002Fhelm.sh\u002F\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n",body_markdown:"### Introduction\nGitOps[1] เป็นการนำ tool, best practice และประโยชน์ต่างๆจาก Git และ Continuous Integration\u002FContinuous Delivery (CI\u002FCD) ที่มีการใช้งานกันเป็น standard ใน Software Development Life Cycle (SDLC) มาใช้ร่วมกับ Infrastructure as Code (IaC) ในทางฝั่งของ IT operation เพื่อจัดการกับ infrastructure ต่างๆ\n\nFlux[2] เป็นหนึ่งใน GitOps tool ที่ได้รับได้ความนิยมในปัจจุบัน เพื่อใช้การใช้จัดการ resource ต่างๆบน Kubernetes cluster โดย version ที่ใช้ในปัจจุบันคือ Flux v2 ซึ่งตัว Flux operator ใน cluster จะทำการ pull ตัว declarative (IaC) จาก Git repository และทำการ reconcile Kubernetes resource ต่างๆให้ตรงตามนั้น\n\nใน blog post นี้เราจะมาดูการติดตั้งและใช้งาน Flux ในเบื้องต้นกัน\n\n### Prerequisites\n- ทำการติดตั้ง [`eksctl`](https:\u002F\u002Feksctl.io\u002Fintroduction\u002F#installation) และ [`flux`](https:\u002F\u002Ffluxcd.io\u002Fdocs\u002Finstallation\u002F)\n- สร้าง [`personal access token`](https:\u002F\u002Fdocs.github.com\u002Fen\u002Fgithub\u002Fauthenticating-to-github\u002Fkeeping-your-account-and-data-secure\u002Fcreating-a-personal-access-token) บน GitHub account\n\n### How to setup Flux on Amazon EKS cluster\neksctl[3] เป็นหนึ่งใน standard tool ที่ใช้ในการสร้างและจัดการ EKS cluster และตั้งแต่ vesion `0.53.0` จะมี feature ในการติดตั้ง Flux รวมอยู่ด้วย\n\nขั้นตอนในการสร้าง EKS cluster ใหม่และติดตั้ง Flux โดยอัตโนมัติ\n\n1. export ค่าต่างๆที่จะต้องใช้ในขั้นตอนต่อๆไป\n    ```\n    export GITHUB_USERNAME=\u003Cyour GitHub username\u003E\n    export GITHUB_TOKEN=\u003Cyour GitHub personal access token\u003E\n    ```\n\n2. สร้าง config file ด้วย code ด้านล่างนี้และเปลี่ยน `\u003CGitHub username\u003E` เป็นชื่อ GitHub username ของเรา\n    ```\n    cat \u003C\u003C EOF \u003E eks-gitops-demo.yaml\n    apiVersion: eksctl.io\u002Fv1alpha5\n    kind: ClusterConfig\n\n    metadata:\n      name: eks-gitops-demo\n      region: ap-southeast-1\n\n    managedNodeGroups:\n      - name: ng-1\n        instanceType: m5.large\n        desiredCapacity: 1\n\n    gitops:\n      flux:\n        gitProvider: github\n        flags:\n          owner: \"${GITHUB_USERNAME}\"\n          personal: \"true\"\n          private: \"true\"\n          repository: \"eks-gitops-demo\"\n          branch: \"master\"\n          namespace: \"flux-system\"\n          path: \"clusters\u002Feks-gitops-demo\"\n    EOF\n    ```\n\n3. ทำการสร้าง EKS cluster โดยใช้คำสั่ง `eksctl create cluster --config-file eks-gitops-demo.yaml` และรอจน cluster สร้างเสร็จ\n\n4. เราสามารถเช็ค resource ต่างๆที่เกี่ยวกับ Flux โดยใช้คำสั่ง `kubectl --namespace flux-system get all`\n![Alt Text](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fs6jtbd9fsfcd1rwi4bwz.jpg)\n\n5. และใน GitHub account ของเราจะมี repository ใหม่ที่ชื่อ `eks-gitops-demo` ถูกสร้างขึ้นมาและมี commit ในส่วนของ Kubernetes manifest file ของ Flux component ต่างๆ\n![Alt Text](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fmhynb58ha1sold17px72.jpg)\n\nถึงตรงนี้แสดงว่าขั้นตอนการสร้าง EKS cluster ใหม่ที่มีการติดตั้ง Flux มาด้วยเป็นอันเสร็จสมบูรณ์แล้ว\n\nNote. สำหรับกรณีที่เป็น EKS cluster เดิมหรือต้องการติดตั้ง Flux แยกทีหลัง\n- ในกรณีที่ cluster ที่ถูกสร้างด้วย eksctl เราสามารถติดตั้ง Flux โดยการใช้คำสั่ง [`eksctl enable flux`](https:\u002F\u002Feksctl.io\u002Fusage\u002Fgitops-v2\u002F) ได้\n- ในกรณีที่ไม่ได้ใช้ eksctl เราสามารถติดตั้ง Flux โดยการใช้ flux CLI และคำสั่ง [`flux bootstrap`](https:\u002F\u002Ffluxcd.io\u002Fdocs\u002Finstallation\u002F)\n\n### How to use Flux basic features\nต่อมาเราจะมาดูการใช้งาน Flux แบบเบื้องต้นกัน\n\nตัวอย่างแรกจะเป็นการใช้ Kubernetes manifest file ตามปกติ\n\n1. เริ่มต้นจากการ clone GitHub repository ที่ Flux ได้สร้างขึ้นมา\n    ```\n    git clone git@github.com:${GITHUB_USERNAME}\u002Feks-gitops-demo.git\n    cd eks-gitops-demo\n    ```\n\n2. หลังจากนั้นเราจะสร้าง Kubernetes manifest file สำหรับ `nginx:1.14.2` deployment แล้วทำการ commit และ push ไปยัง GitHub\n    ```\n    mkdir -p clusters\u002Feks-gitops-demo\u002Fdefault\u002Fnginx\n\n    cat \u003C\u003C EOF \u003E clusters\u002Feks-gitops-demo\u002Fdefault\u002Fnginx\u002Fdeployment.yaml\n    apiVersion: apps\u002Fv1\n    kind: Deployment\n    metadata:\n      name: nginx-deployment\n      labels:\n        app: nginx\n    spec:\n      replicas: 3\n      selector:\n        matchLabels:\n          app: nginx\n      template:\n        metadata:\n          labels:\n            app: nginx\n        spec:\n          containers:\n          - name: nginx\n            image: nginx:1.14.2\n            ports:\n            - containerPort: 80\n    EOF\n\n    git add clusters\u002Feks-gitops-demo\u002Fdefault\u002Fnginx\u002Fdeployment.yaml\n    git commit -m \"Add Nginx deployment\"\n    git push\n    ```\n3. ตามค่า default config Flux จะ pull ข้อมูลจาก GitHub ทุกๆ 10 นาทีและทำการ reconcile Kubernetes resource แต่เราสามารถใช้คำสั่ง `flux reconcile source git flux-system` เพื่อทำการ pull โดยทันทีได้\n![Alt Text](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fwtob1udj0lzhomopaq3d.jpg)\n\n4. หลังจากนั้นเราสามารถเช็คได้ว่า Flux ทำการ apply change ต่างๆและมีการสร้าง Kubernetes deployment ขึ้นมา โดยใช้คำสั่ง `kubectl get deployment nginx-deployment`\n![Alt Text](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fxbusoxtmat7xu0bdq0ou.jpg)\n\n5. หลังจากนั้นลองทำการเปลี่ยนใน deployment manifest file `nginx:1.15.0` และทำการ commit และ push ไปยัง GitHub อีกครั้งนึง\n    ```\n    sed -i '' 's\u002F1.14.2\u002F1.15.0\u002F' clusters\u002Feks-gitops-demo\u002Fdefault\u002Fnginx\u002Fdeployment.yaml\n\n    git add clusters\u002Feks-gitops-demo\u002Fdefault\u002Fnginx\u002Fdeployment.yaml\n    git commit -m \"Change Nginx image to 1.15.0\"\n    git push\n    ```\n\n6. หลังจาก Flux ทำการ reconcile เสร็จ จะเห็นได้ว่า deployment มีการเปลี่ยนไปใช้ `nginx:1.15.0`\n![Alt Text](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fra7rbztybg0rqm3mx8fc.jpg)\n\n7.(Bonus) ถ้าลองลบ deployment manifest แล้วทำการ commit และ push ไปยัง GitHub หลังจาก Flux ทำการ reconcile เสร็จ จะเห็นได้ว่าตัว deployment ของ nginx จะถูกลบไปเช่นกัน\n\nอีกตัวอย่างนึงจะเป็นการใช้งาน Flux ร่วมกับ Helm\n\n1. เริ่มต้นจากการสร้าง HelmRepository CRD ที่ชี้ไปยัง Helm Chart repository ในตัวอย่างนี้เราจะใช้ [`prometheus-community`](https:\u002F\u002Fprometheus-community.github.io\u002Fhelm-charts)\n    ```\n    mkdir -p clusters\u002Feks-gitops-demo\u002Fmonitoring\n\n    cat \u003C\u003C EOF \u003E clusters\u002Feks-gitops-demo\u002Fmonitoring\u002Fnamespace.yaml\n    apiVersion: v1\n    kind: Namespace\n    metadata:\n      name: monitoring\n    EOF\n    ---\n    cat \u003C\u003C EOF \u003E clusters\u002Feks-gitops-demo\u002Fmonitoring\u002Fprometheus-community.yaml\n    apiVersion: source.toolkit.fluxcd.io\u002Fv1beta1\n    kind: HelmRepository\n    metadata:\n      name: prometheus-community\n      namespace: monitoring\n    spec:\n      url: https:\u002F\u002Fprometheus-community.github.io\u002Fhelm-charts\n      interval: 10m\n    EOF\n    ```\n\n2. หลังจากนั้นทำการสร้าง HelmRelease CRD สำหรับที่จะให้ Flux deploy โดยใช้ Chart ที่ชื่อ `kube-prometheus-stack` หลังจากนั้นทำการ commit และ push ไปยัง GitHub\n    ```\n    mkdir -p clusters\u002Feks-gitops-demo\u002Fmonitoring\n\n    cat \u003C\u003C EOF \u003E clusters\u002Feks-gitops-demo\u002Fmonitoring\u002Fnamespace.yaml\n    apiVersion: v1\n    kind: Namespace\n    metadata:\n      name: monitoring\n    EOF\n\n    cat \u003C\u003C EOF \u003E clusters\u002Feks-gitops-demo\u002Fmonitoring\u002Fkube-prometheus-stack.yaml\n    apiVersion: helm.toolkit.fluxcd.io\u002Fv2beta1\n    kind: HelmRelease\n    metadata:\n      name: kube-prometheus-stack\n      namespace: monitoring\n    spec:\n      releaseName: kube-prometheus-stack\n      interval: 10m\n      chart:\n        spec:\n          chart: kube-prometheus-stack\n          sourceRef:\n            kind: HelmRepository\n            name: prometheus-community\n            namespace: monitoring\n    EOF\n\n    git add clusters\u002Feks-gitops-demo\u002Fmonitoring\u002F*\n    git commit -m \"Add Prometheus with Helm\"\n    git push\n    ```\n\n3. หลักจากนั้นใช้คำสั่ง `flux reconcile source git flux-system` เพื่อ pull change จาก GitHub และเนื่องจากใน HelmRelease CRD เราตั้ง interval ในการ reconcile เป็นทุกๆ 10 นาที เราสามารถใช้คำสั่ง `flux --namespace monitoring reconcile helmrelease kube-prometheus-stack` เพื่อให้ reconcile ทันทีได้เช่นกัน\n![Alt Text](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fbpaokz1a1zb0b4iv74uh.jpg)\n\n4. หลักจาก reconcile เสร็จสิ้น เราสามารถเช็คได้ว่า resource ต่างๆสำหรับ Prometheus ได้มีการติดตั้งใน cluster อย่างถูกต้องโดย Helm Chart ผ่าน Flux\n![Alt Text](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fhur9rqc565v8oxi7n616.jpg)\n\n### Conclusion\nGitOps เป็นการนำเทคนิคและการใช้งาน Git, CI\u002FCD และ IaC มาประกอบกันเพื่อให้เราสามารถจัดการ infrastructure ได้อย่างมีประสิทธิภาพและลดความผิดพลาดที่อาจจะเกิดขึ้นจาก manual process\n\nFlux เป็น tool ที่ช่วยให้เราสามารถ implement GitOps บน Kubernetes ได้อย่างสะดวกยิ่งขึ้น ซึ่งใน blog post นี้เราได้เห็นวิธีการติดตั้งบน Amazon EKS ผ่าน eksctl\n\nหลังจากนั้นเราได้เห็นตัวอย่างวิธีการติดใช้งาน Flux ในเบื้องต้น และใน part ที่ 2 เราจะมาดูตัวอย่างและ feature อื่นๆของ Flux กัน\n\n### References\n[1] https:\u002F\u002Fwww.gitops.tech\u002F#what-is-gitops\n[2] https:\u002F\u002Ffluxcd.io\u002F\n[3] https:\u002F\u002Feksctl.io\u002F\n[4] https:\u002F\u002Fhelm.sh\u002F",user:{name:"Pongsan Sayampol",username:e,twitter_username:a,github_username:e,website_url:"https:\u002F\u002Fwww.linkedin.com\u002Fin\u002Fpongsan-sayampol\u002F",profile_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--3PK2AODj--\u002Fc_fill,f_auto,fl_progressive,h_640,q_auto,w_640\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F680469\u002F2bbab0bf-39ca-46e9-93f7-3c0e9d736dda.jpg",profile_image_90:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--Z3YHiGJX--\u002Fc_fill,f_auto,fl_progressive,h_90,q_auto,w_90\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F680469\u002F2bbab0bf-39ca-46e9-93f7-3c0e9d736dda.jpg"},organization:{name:"AWS Community ASEAN",username:f,slug:f,profile_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--cGr2s89f--\u002Fc_fill,f_auto,fl_progressive,h_640,q_auto,w_640\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Forganization\u002Fprofile_image\u002F3974\u002F95700370-548c-431b-8ed5-cce70f477aed.png",profile_image_90:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--IUOJCtfq--\u002Fc_fill,f_auto,fl_progressive,h_90,q_auto,w_90\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Forganization\u002Fprofile_image\u002F3974\u002F95700370-548c-431b-8ed5-cce70f477aed.png"}}},serverRendered:true,routePath:"\u002Farticles\u002Faonz\u002F823241",config:{_app:{basePath:"\u002F",assetsPath:"\u002F_nuxt\u002F",cdnURL:a}}}}(null,"2021-09-15T06:28:37Z","https:\u002F\u002Fdev.to\u002Fawscommunity-asean\u002Fflux-gitops-tool-amazon-eks-part-1-4gla",9,"aonz","awscommunity-asean"));