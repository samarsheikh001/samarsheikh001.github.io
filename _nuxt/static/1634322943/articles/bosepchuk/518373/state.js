window.__NUXT__=(function(a,b,c,d){return {staticAssetsBase:"\u002F_nuxt\u002Fstatic\u002F1634322943",layout:"default",error:a,state:{currentArticle:{type_of:"article",id:518373,title:"How to be more successful at software maintenance",description:"Learn what makes software maintenance so challenging and what you can do to be more successful at it.",readable_publish_date:"Nov 18 '20",slug:"how-to-be-more-successful-at-software-maintenance-1dbo",path:"\u002Fbosepchuk\u002Fhow-to-be-more-successful-at-software-maintenance-1dbo",url:"https:\u002F\u002Fdev.to\u002Fbosepchuk\u002Fhow-to-be-more-successful-at-software-maintenance-1dbo",comments_count:2,public_reactions_count:c,collection_id:a,published_timestamp:b,positive_reactions_count:c,cover_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--NpLVTAUB--\u002Fc_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fi\u002Fxi0w7aemzo65zeb9c55o.jpg",social_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--CRJpjezk--\u002Fc_imagga_scale,f_auto,fl_progressive,h_500,q_auto,w_1000\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fi\u002Fxi0w7aemzo65zeb9c55o.jpg",canonical_url:"https:\u002F\u002Fsmallbusinessprogramming.com\u002Fhow-to-be-more-successful-at-software-maintenance\u002F",created_at:b,edited_at:a,crossposted_at:a,published_at:b,last_comment_at:"2020-12-11T14:19:00Z",reading_time_minutes:9,tag_list:"codequality, technicaldebt, softwareengineering, refactoring",tags:["codequality","technicaldebt","softwareengineering","refactoring"],body_html:"\u003Cp\u003EIn this post I want to explore the kind of software maintenance that happens after active maintenance ends. This is the stage of the software life cycle where the software has been in production for some time and the initial wave of bug fixes and enhancement requests ends. It's also at this point that managers may cut the number of developers assigned to the project and turn their attention elsewhere.\u003C\u002Fp\u003E\n\n\u003Cp\u003EKeeping this kind of project running safely, securely, \u003Cstrong\u003E\u003Cem\u003Eand profitability\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E as the years tick by--even if you're not adding or changing functionality--is especially challenging.\u003C\u002Fp\u003E\n\n\u003Cp\u003EI've spent more than a decade in this situation. And I'd like share some of my observations and advice about maintaining this kind of software with you.\u003C\u002Fp\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"the-8-laws-of-software-maintenance\" href=\"#the-8-laws-of-software-maintenance\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  The 8 laws of software maintenance\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003EIf your software lives long enough you'll experience one or more of the following:\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"1-youll-have-trouble-getting-enough-resources-to-maintain-your-project\" href=\"#1-youll-have-trouble-getting-enough-resources-to-maintain-your-project\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  1. You'll have trouble getting enough resources to maintain your project\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EKeeping old software running isn't sexy. Managers are more interested in acquiring new functionality than maintaining older systems. And, very few programmers want to spend their careers doing maintenance so both talent and money may be in short supply.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"2-your-hardware-and-software-dependencies-will-become-outofdate\" href=\"#2-your-hardware-and-software-dependencies-will-become-outofdate\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  2. Your hardware and software dependencies will become out-of-date\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--TzQoOIyv--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fi\u002Fpbfhi8m9o9jo2colkwzj.jpg\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--TzQoOIyv--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fi\u002Fpbfhi8m9o9jo2colkwzj.jpg\" alt=\"old car\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EThe languages, frameworks, libraries, APIs, development tools, build systems, and hardware used by your project are constantly shifting under your feet. Some stacks are shifting faster than others but nothing is standing still. And the more dependencies you have, the harder your project will be to maintain.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"3-your-code-base-will-be-a-mess\" href=\"#3-your-code-base-will-be-a-mess\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  3. Your code base will be a mess\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EI can say this with a fair bit of confidence because most code bases are a mess. But very old code bases can be especially problematic. They might have been developed without unit tests, documentation, static analysis, coding standards, style guides, code reviews, or modern development methods. \u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--KXIwtjxq--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fi\u002Foakn1gtsuainl6igtx6o.jpg\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--KXIwtjxq--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fi\u002Foakn1gtsuainl6igtx6o.jpg\" alt=\"firefighters fighting a fire\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EVery old code bases have frequently been worked on by several programmers with different programming styles over time. And if your software has been underfunded or developed with speed as the top priority, it probably contains heaps of low quality code.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"4-your-memory-will-fade\" href=\"#4-your-memory-will-fade\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  4. Your memory will fade\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EYour understanding the requirements, design decisions, and how your code works degrades rapidly after active development stops. People forget the details or take valuable knowledge with them when they move on to other projects. And your documentation and test coverage will almost certainly be inadequate to make up for that missing knowledge.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"5-youll-lose-something-important\" href=\"#5-youll-lose-something-important\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  5. You'll lose something important\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EInformation, software, or hardware critical maintaining, building, testing, documenting, or deploying your software may be lost. Think config files, compilers, compiler switches, hardware configurations, encryption keys, source code for dependencies, drivers, backup scripts, development environments, test environments, etc.\u003C\u002Fp\u003E\n\n\u003Cp\u003ELosing any single critical component of your project could mean that it cannot continue to operate without heroic effort on your part. And some problems--like losing the contents of your database--can leave you with no choice but to shutdown your project.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"6-youll-need-to-change-your-software\" href=\"#6-youll-need-to-change-your-software\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  6. You'll need to change your software\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EYou may not want to change it but, if your software lives long enough, you'll likely discover a good reason to change it.\u003C\u002Fp\u003E\n\n\u003Cp\u003EReasons include:\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003Enew requirements\u003C\u002Fli\u003E\n\u003Cli\u003Edefects\u003C\u002Fli\u003E\n\u003Cli\u003Eobsolete dependencies\u003C\u002Fli\u003E\n\u003Cli\u003Esecurity vulnerabilities\u003C\u002Fli\u003E\n\u003Cli\u003Enew legislation or regulations (privacy, PCI DSS, etc.)\u003C\u002Fli\u003E\n\u003Cli\u003Ehardware failures\u003C\u002Fli\u003E\n\u003Cli\u003Ehardware obsolescence\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EAlways assume you'll have to make a change at some point in the future no matter what anybody tells you.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"7-maintenance-is-difficult-and-expensive\" href=\"#7-maintenance-is-difficult-and-expensive\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  7. Maintenance is difficult and expensive\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EThis is the stage of your project where your chickens come home to roost. The decisions you and your predecessors made earlier in the software development life cycle will determine how painful and expensive keeping this system running will be. But, no matter how much care and foresight everyone exercised, maintaining old software is almost always difficult and expensive.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--mE5JWvn9--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fi\u002Fxpf1je6n0ij3h27bmnow.jpg\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--mE5JWvn9--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fi\u002Fxpf1je6n0ij3h27bmnow.jpg\" alt=\"poorly maintained house\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Cstrong\u003ECleaning up the code base to make it easier to maintain (aka refactoring) is tempting to most programmers, but it is often a terrible investment.\u003C\u002Fstrong\u003E \u003C\u002Fp\u003E\n\n\u003Cp\u003ELarge sums of money are wasted on ill-advised code cleanup projects that will never be paid back by faster future development. For example, I currently maintain tens of thousands of lines of code that haven't been meaningfully modified in years and may never be modified again. So any refactoring or cleanup I do on that code is almost certainly wasted. It doesn't matter how ugly I think that code is.\u003C\u002Fp\u003E\n\n\u003Cp\u003EYou might be able to make economically advantageous, highly targeted changes if you look hard enough. But you are largely stuck with whatever you have at this point.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"8-your-software-will-stay-in-production-much-longer-than-anybody-anticipated\" href=\"#8-your-software-will-stay-in-production-much-longer-than-anybody-anticipated\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  8. Your software will stay in production much longer than anybody anticipated\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EThis is certainly not true of all software but if you restrict yourself to the types of projects we are discussing in this post (software in the late stages of maintenance) you'll find that this type of software tends to be hard to kill for various reasons:\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003Ereplacing it never gets to the top of anybody's to-do list (regardless of what anybody says)\u003C\u002Fli\u003E\n\u003Cli\u003Eit's just too expensive to replace\u003C\u002Fli\u003E\n\u003Cli\u003Ethe replacement project is late or fails to meet user needs\u003C\u002Fli\u003E\n\u003Cli\u003Ethe replacement project never delivers working software (because the project failed or was cancelled)\u003C\u002Fli\u003E\n\u003Cli\u003Eyour users can't or won't upgrade (for various reasons)\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"how-to-make-software-maintenance-better\" href=\"#how-to-make-software-maintenance-better\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  How to make software maintenance better\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003ELike I said earlier, keeping this kind of project running safely, securely, \u003Cstrong\u003E\u003Cem\u003Eand profitability\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E as the years tick by--even if you're not adding or changing functionality--is especially challenging.\u003C\u002Fp\u003E\n\n\u003Cp\u003EYour biggest risks are that:\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003Eyou waste your maintenance budget on low value activities\u003C\u002Fli\u003E\n\u003Cli\u003Ean unexcepted event cripples the value of your project and\u002For brings it to a premature end\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003EThere are no one-size-fits-all solutions to this kind of software maintenance but there are some things you can do to make your life better. Your first step is to do some analysis.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"how-and-when-will-you-retire-this-software\" href=\"#how-and-when-will-you-retire-this-software\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  How and when will you retire this software?\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EWhat's the retirement plan for your software? Is it expected to live for another year? 5? 10? 50? Do you plan to develop a replacement product and migrate your users to it? Does this software need to be changed to enable the migration? How realistic is the delivery date? Or will you retire the software without replacement? Or do something else?\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"what-do-your-stakeholders-want-from-this-software-between-now-and-the-time-you-retire-it\" href=\"#what-do-your-stakeholders-want-from-this-software-between-now-and-the-time-you-retire-it\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  What do your stakeholders want from this software between now and the time you retire it?\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EDon't assume you know what's important to them. Ask them. You might be surprised by what they say.\u003C\u002Fp\u003E\n\n\u003Cp\u003EI did just that with the owners of a project I had been maintaining for over 10 years. I thought I knew their preferences very well. But I setup a meeting to ask them (just to be safe). I knew they didn't care about technical debt or code quality but I was surprised by their views on security, up-time, disaster recovery, and several other issues.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"what-is-the-value-of-your-software\" href=\"#what-is-the-value-of-your-software\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  What is the value of your software?\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EHow much money will your software make (or save) you each month or year until its planned retirement? There are several ways to do this but, if you are looking for a recommendation, I suggest you start with a \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FNet_present_value\"\u003Enet present value\u003C\u002Fa\u003E analysis.\u003C\u002Fp\u003E\n\n\u003Cp\u003EYou should also account for non-monetary factors in the value of your software. For example, if you promised your biggest customers that you would support the software for another 5 years, it would be wise to take that into account in your analysis.\u003C\u002Fp\u003E\n\n\u003Cp\u003EYou may want to get the business types involved in this analysis to help you figure things out.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"what-will-it-cost-to-keep-your-software-in-production-until-its-planned-retirement-date\" href=\"#what-will-it-cost-to-keep-your-software-in-production-until-its-planned-retirement-date\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  What will it cost to keep your software in production until its planned retirement date?\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EWhat does it cost now? Is it reasonable to project that number into the future with some sort of inflation factor? What unavoidable maintenance tasks will you have to perform? For example, you might expect to migrate to new servers every 5-7 years and migrate your code to a new version of your language every x years. There are also one-off concerns like the \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FYear_2038_problem\"\u003Eyear 2038 problem\u003C\u002Fa\u003E. Or maybe you know you'll need to replace one of your dependencies because its end of life date has been announced.\u003C\u002Fp\u003E\n\n\u003Cp\u003EThere are also costs that are harder to pin down. For example, is your project written in a language that is no longer popular? How will you find people with the skills to maintain it all the way to its retirement? Are you on old hardware? How will you keep that running? Or what's the probability that you have a security breach that costs you money or damages your reputation?\u003C\u002Fp\u003E\n\n\u003Cp\u003EIt's natural for people to underestimate how much effort it takes to keep software running. So any analysis you do will be more realistic than just throwing a number out there.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"how-risky-is-your-maintenance-debt\" href=\"#how-risky-is-your-maintenance-debt\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  How risky is your \"maintenance debt\"?\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EMaintenance debt is a relatively new term. It is described in \u003Ca href=\"https:\u002F\u002Fwww.researchgate.net\u002Fpublication\u002F335983023_Delaying_Maintenance_Can_Prove_Fatal\"\u003Ethis paper\u003C\u002Fa\u003E as follows:\u003C\u002Fp\u003E\n\n\u003Cblockquote\u003E\n\u003Cp\u003EWe introduce the term \"maintenance debt\" for maintenance needs generated by an implementation’s dependence on external IT factors such as libraries, platforms and tools, that have become obsolescent. The application continues to run, and the IT department forgets this theoretical liability, focussing on more urgent requirements and problems elsewhere.\u003C\u002Fp\u003E\n\n\u003Cp\u003ESuch debt accumulates over time, silently eating away at the value of the software asset. Eventually something happens that makes system change unavoidable. The owner may then discover that the system can no longer be modified--it is literally unmaintainable. Less dramatically, it may take too long, or cost too much, for maintenance to solve the business problem, and an alternative solution must be found. The software has suddenly crashed to £0 value.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"is-it-worth-keeping-your-software-in-production-until-its-planned-retirement-date\" href=\"#is-it-worth-keeping-your-software-in-production-until-its-planned-retirement-date\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  Is it worth keeping your software in production until its planned retirement date?\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EIt might become clear to you that your planned retirement date is uneconomical. Maybe you need to move your retirement date up? Or reduce your maintenance budget? Or increase how much you charge your users?\u003C\u002Fp\u003E\n\n\u003Cp\u003EPerhaps you can purchase off-the-shelf software that largely does what your software does for a fraction of the cost and migrate to that.\u003C\u002Fp\u003E\n\n\u003Cp\u003EOr maybe you realize that your software is extremely valuable and it makes sense to devote more resources to its maintenance to make it even more valuable and\u002For push back the retirement date.\u003C\u002Fp\u003E\n\n\u003Cp\u003EYet another option is that your software is a money pit and you need to figure out if you should \u003Ca href=\"https:\u002F\u002Fsmallbusinessprogramming.com\u002Fsoftware-rewrite-vs-refactor-debate-8-things-you-need-to-know\u002F\"\u003Erewrite or refactor\u003C\u002Fa\u003E it. Or perhaps the best thing to do is shutdown the project immediately without having a replacement (as Google is fond of doing) and work on something completely different.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Cstrong\u003EThe important thing is to do the analysis\u003C\u002Fstrong\u003E. The business types respond to data. And, even if there's quite a large level of uncertainly in your estimates of cost and value, it's a good starting point to having an intelligent conversation about the best way to maximize the profitability of your software.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"its-all-about-risk-management\" href=\"#its-all-about-risk-management\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  It's all about risk management\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EIf you've made it to this point and you've discovered your software is worth maintaining in some way, you'll have to decide how you are going to spend your maintenance budget.\u003C\u002Fp\u003E\n\n\u003Cp\u003EYou'll need to assign some of it to your \"must-do\" maintenance tasks. Then you can take whatever's left and use it to reduce the risk that something bad happens to your software.\u003C\u002Fp\u003E\n\n\u003Cp\u003EFor example, if you are worried about a hardware failure, maybe you work on your backup, replication, or redundancy. If you are worried about key people leaving the project, then you might focus on employee retention, letting your developers work on their software pain points, and documenting the system.\u003C\u002Fp\u003E\n\n\u003Cp\u003EMy point is that \u003Cstrong\u003Eit's unlikely that you'll have enough resources to do everything you might want to do to maintain your software so you'll need to prioritize your efforts\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"additional-things-you-can-do\" href=\"#additional-things-you-can-do\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  Additional things you can do\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003EIn addition to everything I described above, I think it's wise to do the following two steps periodically.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"1-revisit-your-analysis-from-time-to-time\" href=\"#1-revisit-your-analysis-from-time-to-time\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  1. Revisit your analysis from time to time\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EThe value of your software will change over time--often in unanticipated ways--so it's wise to redo your analysis periodically and make adjustments to your maintenance plans as necessary.\u003C\u002Fp\u003E\n\n\u003Ch4\u003E\n  \u003Ca name=\"2-build-and-deploy-even-if-you-have-no-changes\" href=\"#2-build-and-deploy-even-if-you-have-no-changes\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  2. Build and deploy, even if you have no changes\n\u003C\u002Fh4\u003E\n\n\u003Cp\u003EYou might consider updating your dependencies to recent compatible versions, building, testing, and deploying periodically. Even if you have no changes to integrate it's worth something to demonstrate that you can still do it successfully. It's also a good opportunity to look at your hardware and documentation to evaluate how well it's meeting your needs.\u003C\u002Fp\u003E\n\n\u003Cp\u003EHow often you build and deploy is up to you but every six months or so seems reasonable to me.\u003C\u002Fp\u003E\n\n\u003Cp\u003EThe scenario you want to avoid is that you need to make some small change and discover that its impossible or nearly impossible because you don't have a critical piece of information, software, or hardware required to complete the process. At that point all your options are bad (and probably expensive).\u003C\u002Fp\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"wrapping-up\" href=\"#wrapping-up\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  Wrapping up\n\u003C\u002Fh3\u003E\n\n\u003Cp\u003EIf you find yourself responsible for maintaining a software system after active maintenance ends I recommend you \u003Cstrong\u003Efocus on striking a good balance between squeezing as much profit out of it as you can and taking steps to reduce the most serious risks of something catastrophic occurring\u003C\u002Fstrong\u003E to the system.\u003C\u002Fp\u003E\n\n\u003Cp\u003EFollowing the steps outlined in this post will help get you going on the right path. And, remember, it's your stakeholders who decide what makes your software valuable, not you. Good luck!\u003C\u002Fp\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"additional-resources\" href=\"#additional-resources\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  Additional resources:\n\u003C\u002Fh3\u003E\n\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Ca href=\"https:\u002F\u002Fwww.amazon.com\u002FSoftware-Engineering-Google-Lessons-Programming\u002Fdp\u002F1492082791\u002F\"\u003ESoftware Engineering at Google\u003C\u002Fa\u003E (book)\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Ca href=\"https:\u002F\u002Fwww.amazon.com\u002FWorking-Effectively-Legacy-Michael-Feathers\u002Fdp\u002F0131177052\u002F\"\u003EWorking Effectively with Legacy Code\u003C\u002Fa\u003E (book)\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Ca href=\"https:\u002F\u002Fwww.theverge.com\u002F2020\u002F4\u002F14\u002F21219561\u002Fcoronavirus-pandemic-unemployment-systems-cobol-legacy-software-infrastructure\"\u003EWhy governments can't migrate away from cobol\u003C\u002Fa\u003E (article)\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Ca href=\"https:\u002F\u002Fwww.researchgate.net\u002Fpublication\u002F335983023_Delaying_Maintenance_Can_Prove_Fatal\"\u003EMaintenance Debt\u003C\u002Fa\u003E (research paper)\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003E\u003Cem\u003EHave a comment, question or a story to share? Let me have it in the comments.\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Cem\u003EEnjoy this post? Please \"like\" it.\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\n",body_markdown:"---\ntitle: How to be more successful at software maintenance\npublished: true\ndescription: Learn what makes software maintenance so challenging and what you can do to be more successful at it.\ntags: #codequality, #technicaldebt, #softwareengineering, #refactoring\ncover_image: https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fi\u002Fxi0w7aemzo65zeb9c55o.jpg\ncanonical_url: https:\u002F\u002Fsmallbusinessprogramming.com\u002Fhow-to-be-more-successful-at-software-maintenance\u002F\n---\nIn this post I want to explore the kind of software maintenance that happens after active maintenance ends. This is the stage of the software life cycle where the software has been in production for some time and the initial wave of bug fixes and enhancement requests ends. It's also at this point that managers may cut the number of developers assigned to the project and turn their attention elsewhere.\n\nKeeping this kind of project running safely, securely, ***and profitability*** as the years tick by--even if you're not adding or changing functionality--is especially challenging.\n\nI've spent more than a decade in this situation. And I'd like share some of my observations and advice about maintaining this kind of software with you.\n\n### The 8 laws of software maintenance\n\nIf your software lives long enough you'll experience one or more of the following:\n\n#### 1. You'll have trouble getting enough resources to maintain your project\nKeeping old software running isn't sexy. Managers are more interested in acquiring new functionality than maintaining older systems. And, very few programmers want to spend their careers doing maintenance so both talent and money may be in short supply.\n\n#### 2. Your hardware and software dependencies will become out-of-date\n\n![old car](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fi\u002Fpbfhi8m9o9jo2colkwzj.jpg)\n\nThe languages, frameworks, libraries, APIs, development tools, build systems, and hardware used by your project are constantly shifting under your feet. Some stacks are shifting faster than others but nothing is standing still. And the more dependencies you have, the harder your project will be to maintain.\n\n#### 3. Your code base will be a mess\nI can say this with a fair bit of confidence because most code bases are a mess. But very old code bases can be especially problematic. They might have been developed without unit tests, documentation, static analysis, coding standards, style guides, code reviews, or modern development methods. \n\n![firefighters fighting a fire](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fi\u002Foakn1gtsuainl6igtx6o.jpg)\n\nVery old code bases have frequently been worked on by several programmers with different programming styles over time. And if your software has been underfunded or developed with speed as the top priority, it probably contains heaps of low quality code.\n\n#### 4. Your memory will fade\nYour understanding the requirements, design decisions, and how your code works degrades rapidly after active development stops. People forget the details or take valuable knowledge with them when they move on to other projects. And your documentation and test coverage will almost certainly be inadequate to make up for that missing knowledge.\n\n#### 5. You'll lose something important\nInformation, software, or hardware critical maintaining, building, testing, documenting, or deploying your software may be lost. Think config files, compilers, compiler switches, hardware configurations, encryption keys, source code for dependencies, drivers, backup scripts, development environments, test environments, etc.\n\nLosing any single critical component of your project could mean that it cannot continue to operate without heroic effort on your part. And some problems--like losing the contents of your database--can leave you with no choice but to shutdown your project.\n\n#### 6. You'll need to change your software\nYou may not want to change it but, if your software lives long enough, you'll likely discover a good reason to change it.\n\nReasons include:\n\n* new requirements\n* defects\n* obsolete dependencies\n* security vulnerabilities\n* new legislation or regulations (privacy, PCI DSS, etc.)\n* hardware failures\n* hardware obsolescence\n\n**Always assume you'll have to make a change at some point in the future no matter what anybody tells you.**\n\n#### 7. Maintenance is difficult and expensive\nThis is the stage of your project where your chickens come home to roost. The decisions you and your predecessors made earlier in the software development life cycle will determine how painful and expensive keeping this system running will be. But, no matter how much care and foresight everyone exercised, maintaining old software is almost always difficult and expensive.\n\n![poorly maintained house](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fi\u002Fxpf1je6n0ij3h27bmnow.jpg)\n\n**Cleaning up the code base to make it easier to maintain (aka refactoring) is tempting to most programmers, but it is often a terrible investment.** \n\nLarge sums of money are wasted on ill-advised code cleanup projects that will never be paid back by faster future development. For example, I currently maintain tens of thousands of lines of code that haven't been meaningfully modified in years and may never be modified again. So any refactoring or cleanup I do on that code is almost certainly wasted. It doesn't matter how ugly I think that code is.\n\nYou might be able to make economically advantageous, highly targeted changes if you look hard enough. But you are largely stuck with whatever you have at this point.\n\n#### 8. Your software will stay in production much longer than anybody anticipated\nThis is certainly not true of all software but if you restrict yourself to the types of projects we are discussing in this post (software in the late stages of maintenance) you'll find that this type of software tends to be hard to kill for various reasons:\n\n* replacing it never gets to the top of anybody's to-do list (regardless of what anybody says)\n* it's just too expensive to replace\n* the replacement project is late or fails to meet user needs\n* the replacement project never delivers working software (because the project failed or was cancelled)\n* your users can't or won't upgrade (for various reasons)\n\n### How to make software maintenance better\nLike I said earlier, keeping this kind of project running safely, securely, ***and profitability*** as the years tick by--even if you're not adding or changing functionality--is especially challenging.\n\nYour biggest risks are that:\n\n* you waste your maintenance budget on low value activities\n* an unexcepted event cripples the value of your project and\u002For brings it to a premature end\n\nThere are no one-size-fits-all solutions to this kind of software maintenance but there are some things you can do to make your life better. Your first step is to do some analysis.\n\n#### How and when will you retire this software?\nWhat's the retirement plan for your software? Is it expected to live for another year? 5? 10? 50? Do you plan to develop a replacement product and migrate your users to it? Does this software need to be changed to enable the migration? How realistic is the delivery date? Or will you retire the software without replacement? Or do something else?\n\n#### What do your stakeholders want from this software between now and the time you retire it?\nDon't assume you know what's important to them. Ask them. You might be surprised by what they say.\n\nI did just that with the owners of a project I had been maintaining for over 10 years. I thought I knew their preferences very well. But I setup a meeting to ask them (just to be safe). I knew they didn't care about technical debt or code quality but I was surprised by their views on security, up-time, disaster recovery, and several other issues.\n\n#### What is the value of your software?\nHow much money will your software make (or save) you each month or year until its planned retirement? There are several ways to do this but, if you are looking for a recommendation, I suggest you start with a [net present value](https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FNet_present_value) analysis.\n\nYou should also account for non-monetary factors in the value of your software. For example, if you promised your biggest customers that you would support the software for another 5 years, it would be wise to take that into account in your analysis.\n\nYou may want to get the business types involved in this analysis to help you figure things out.\n\n#### What will it cost to keep your software in production until its planned retirement date?\nWhat does it cost now? Is it reasonable to project that number into the future with some sort of inflation factor? What unavoidable maintenance tasks will you have to perform? For example, you might expect to migrate to new servers every 5-7 years and migrate your code to a new version of your language every x years. There are also one-off concerns like the [year 2038 problem](https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FYear_2038_problem). Or maybe you know you'll need to replace one of your dependencies because its end of life date has been announced.\n\nThere are also costs that are harder to pin down. For example, is your project written in a language that is no longer popular? How will you find people with the skills to maintain it all the way to its retirement? Are you on old hardware? How will you keep that running? Or what's the probability that you have a security breach that costs you money or damages your reputation?\n\nIt's natural for people to underestimate how much effort it takes to keep software running. So any analysis you do will be more realistic than just throwing a number out there.\n\n#### How risky is your \"maintenance debt\"?\nMaintenance debt is a relatively new term. It is described in [this paper](https:\u002F\u002Fwww.researchgate.net\u002Fpublication\u002F335983023_Delaying_Maintenance_Can_Prove_Fatal) as follows:\n\u003E We introduce the term \"maintenance debt\" for maintenance needs generated by an implementation’s dependence on external IT factors such as libraries, platforms and tools, that have become obsolescent. The application continues to run, and the IT department forgets this theoretical liability, focussing on more urgent requirements and problems elsewhere.\n\n\u003E Such debt accumulates over time, silently eating away at the value of the software asset. Eventually something happens that makes system change unavoidable. The owner may then discover that the system can no longer be modified--it is literally unmaintainable. Less dramatically, it may take too long, or cost too much, for maintenance to solve the business problem, and an alternative solution must be found. The software has suddenly crashed to £0 value.\n\n#### Is it worth keeping your software in production until its planned retirement date?\nIt might become clear to you that your planned retirement date is uneconomical. Maybe you need to move your retirement date up? Or reduce your maintenance budget? Or increase how much you charge your users?\n\nPerhaps you can purchase off-the-shelf software that largely does what your software does for a fraction of the cost and migrate to that.\n\nOr maybe you realize that your software is extremely valuable and it makes sense to devote more resources to its maintenance to make it even more valuable and\u002For push back the retirement date.\n\nYet another option is that your software is a money pit and you need to figure out if you should [rewrite or refactor](https:\u002F\u002Fsmallbusinessprogramming.com\u002Fsoftware-rewrite-vs-refactor-debate-8-things-you-need-to-know\u002F) it. Or perhaps the best thing to do is shutdown the project immediately without having a replacement (as Google is fond of doing) and work on something completely different.\n\n**The important thing is to do the analysis**. The business types respond to data. And, even if there's quite a large level of uncertainly in your estimates of cost and value, it's a good starting point to having an intelligent conversation about the best way to maximize the profitability of your software.\n\n#### It's all about risk management\nIf you've made it to this point and you've discovered your software is worth maintaining in some way, you'll have to decide how you are going to spend your maintenance budget.\n\nYou'll need to assign some of it to your \"must-do\" maintenance tasks. Then you can take whatever's left and use it to reduce the risk that something bad happens to your software.\n\nFor example, if you are worried about a hardware failure, maybe you work on your backup, replication, or redundancy. If you are worried about key people leaving the project, then you might focus on employee retention, letting your developers work on their software pain points, and documenting the system.\n\nMy point is that **it's unlikely that you'll have enough resources to do everything you might want to do to maintain your software so you'll need to prioritize your efforts**.\n\n### Additional things you can do\nIn addition to everything I described above, I think it's wise to do the following two steps periodically.\n\n#### 1. Revisit your analysis from time to time\nThe value of your software will change over time--often in unanticipated ways--so it's wise to redo your analysis periodically and make adjustments to your maintenance plans as necessary.\n\n#### 2. Build and deploy, even if you have no changes\nYou might consider updating your dependencies to recent compatible versions, building, testing, and deploying periodically. Even if you have no changes to integrate it's worth something to demonstrate that you can still do it successfully. It's also a good opportunity to look at your hardware and documentation to evaluate how well it's meeting your needs.\n\nHow often you build and deploy is up to you but every six months or so seems reasonable to me.\n\nThe scenario you want to avoid is that you need to make some small change and discover that its impossible or nearly impossible because you don't have a critical piece of information, software, or hardware required to complete the process. At that point all your options are bad (and probably expensive).\n\n### Wrapping up\nIf you find yourself responsible for maintaining a software system after active maintenance ends I recommend you **focus on striking a good balance between squeezing as much profit out of it as you can and taking steps to reduce the most serious risks of something catastrophic occurring** to the system.\n\nFollowing the steps outlined in this post will help get you going on the right path. And, remember, it's your stakeholders who decide what makes your software valuable, not you. Good luck!\n\n### Additional resources:\n\n* [Software Engineering at Google](https:\u002F\u002Fwww.amazon.com\u002FSoftware-Engineering-Google-Lessons-Programming\u002Fdp\u002F1492082791\u002F) (book)\n* [Working Effectively with Legacy Code](https:\u002F\u002Fwww.amazon.com\u002FWorking-Effectively-Legacy-Michael-Feathers\u002Fdp\u002F0131177052\u002F) (book)\n* [Why governments can't migrate away from cobol](https:\u002F\u002Fwww.theverge.com\u002F2020\u002F4\u002F14\u002F21219561\u002Fcoronavirus-pandemic-unemployment-systems-cobol-legacy-software-infrastructure) (article)\n* [Maintenance Debt](https:\u002F\u002Fwww.researchgate.net\u002Fpublication\u002F335983023_Delaying_Maintenance_Can_Prove_Fatal) (research paper)\n\n*Have a comment, question or a story to share? Let me have it in the comments.*\n\n*Enjoy this post? Please \"like\" it.*",user:{name:"Blaine Osepchuk",username:d,twitter_username:"BlaineOsepchuk",github_username:d,website_url:"https:\u002F\u002Fsmallbusinessprogramming.com",profile_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--e2lYTuKD--\u002Fc_fill,f_auto,fl_progressive,h_640,q_auto,w_640\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F21001\u002F02beb73a-c476-4d04-a7d3-5564f4d6f85d.jpeg",profile_image_90:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--_EorslXK--\u002Fc_fill,f_auto,fl_progressive,h_90,q_auto,w_90\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F21001\u002F02beb73a-c476-4d04-a7d3-5564f4d6f85d.jpeg"}}},serverRendered:true,routePath:"\u002Farticles\u002Fbosepchuk\u002F518373",config:{_app:{basePath:"\u002F",assetsPath:"\u002F_nuxt\u002F",cdnURL:a}}}}(null,"2020-11-18T15:41:17Z",8,"bosepchuk"));