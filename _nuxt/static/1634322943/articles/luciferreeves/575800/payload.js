__NUXT_JSONP__("/articles/luciferreeves/575800", (function(a,b,c,d){b.type_of="article";b.id=575800;b.title="Big O Notation - explained as easily as possible";b.description="‚Äî Originally published on that computer scientist. Consider following the original blog for up-to-dat...";b.readable_publish_date="Jan 19";b.slug="big-o-notation-explained-as-easily-as-possible-3lg6";b.path="\u002Fluciferreeves\u002Fbig-o-notation-explained-as-easily-as-possible-3lg6";b.url="https:\u002F\u002Fdev.to\u002Fluciferreeves\u002Fbig-o-notation-explained-as-easily-as-possible-3lg6";b.comments_count=0;b.public_reactions_count=c;b.collection_id=10855;b.published_timestamp=a;b.positive_reactions_count=c;b.cover_image="https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--w7fVhBoq--\u002Fc_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fi\u002Fmtz0neijrvuszozxnws2.jpg";b.social_image="https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--C9FmVfWh--\u002Fc_imagga_scale,f_auto,fl_progressive,h_500,q_auto,w_1000\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fi\u002Fmtz0neijrvuszozxnws2.jpg";b.canonical_url="https:\u002F\u002Fthatcomputerscientist.com\u002Fbig-o-notation-explained-as-easily-as-possible";b.created_at="2021-01-19T09:03:49Z";b.edited_at="2021-01-19T09:28:10Z";b.crossposted_at=null;b.published_at=a;b.last_comment_at=a;b.reading_time_minutes=3;b.tag_list="algorithms, programming, computerscience, datastructures";b.tags=["algorithms","programming","computerscience","datastructures"];b.body_html="\u003Cp\u003E\u003Cem\u003E\u003Csmall\u003E‚Äî Originally published on \u003Ca href=\"https:\u002F\u002Fthatcomputerscientist.com\u002F\"\u003Ethat computer scientist\u003C\u002Fa\u003E. Consider following the original blog for up-to-date articles.\u003C\u002Fsmall\u003E\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\n\u003Cblockquote\u003E\n\u003Cp\u003EIf you want to learn the math involved with the Big O, read  \u003Ca href=\"https:\u002F\u002Fthatcomputerscientist.com\u002Fanalysing-algorithms-worst-case-running-time\"\u003EAnalysing Algorithms: Worst Case Running Time\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\n\u003Cp\u003EData Structures and Algorithms is about solving problems efficiently. A bad programmer solves their problems inefficiently and a really bad programmer doesn't even know why their solution is inefficient. So, the question is, \u003Cem\u003EHow do you rank an algorithm's efficiency?\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EThe simple answer to that question is the \u003Cstrong\u003EBig O Notation\u003C\u002Fstrong\u003E. How does that work? Let me explain!\u003C\u002Fp\u003E\n\n\u003Cp\u003ESay you wrote a function which goes through every number in a list and adds it to a \u003Cem\u003Etotal_sum\u003C\u002Fem\u003E variable.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--ecYKHXLG--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fcdn.hashnode.com\u002Fres\u002Fhashnode\u002Fimage\u002Fupload\u002Fv1610785957976\u002F1d53AER34.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--ecYKHXLG--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fcdn.hashnode.com\u002Fres\u002Fhashnode\u002Fimage\u002Fupload\u002Fv1610785957976\u002F1d53AER34.png\" alt=\"Screenshot 2021-01-16 at 2.02.19 PM.png\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EIf you consider \"addition\" to be 1 operation then running this function on a list of 10 numbers will cost 10 operations, running it on a list of 20 numbers costs 20 operations  and similarly running it on a list of n numbers costs the \u003Cem\u003Elength of list\u003C\u002Fem\u003E (n) operations.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--l-BZkVVx--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880\u002Fhttps:\u002F\u002Fcdn.hashnode.com\u002Fres\u002Fhashnode\u002Fimage\u002Fupload\u002Fv1610786373466\u002FWWOOmyjH9.gif\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--l-BZkVVx--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880\u002Fhttps:\u002F\u002Fcdn.hashnode.com\u002Fres\u002Fhashnode\u002Fimage\u002Fupload\u002Fv1610786373466\u002FWWOOmyjH9.gif\" alt=\"Screen Recording 2021-01-16 at 2.01.09 PM.gif\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003ENow let's assume you wrote another function that would return the first number in a list.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--MjY4k2CX--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fcdn.hashnode.com\u002Fres\u002Fhashnode\u002Fimage\u002Fupload\u002Fv1610786595803\u002FWcObNzV40.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--MjY4k2CX--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fcdn.hashnode.com\u002Fres\u002Fhashnode\u002Fimage\u002Fupload\u002Fv1610786595803\u002FWcObNzV40.png\" alt=\"Screenshot 2021-01-16 at 2.09.39 PM.png\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003ENow, no matter how large this list is, this function will never cost more than one operation. Fairly, these two algorithms have different \u003Cstrong\u003Etime complexity\u003C\u002Fstrong\u003E or \u003Cem\u003Erelationship between growth of input size and growth of operations executed\u003C\u002Fem\u003E. We communicate these time complexities using \u003Cstrong\u003E\u003Cem\u003EBig O Notation\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E.\u003C\u002Fp\u003E\n\n\u003Cblockquote\u003E\n\u003Cp\u003EBig O Notation is a mathematical notation used to classify algorithms according to how their run time or space requirements grow as the input size grows.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\n\u003Cp\u003EReferring to the complexities as \u003Cem\u003E'\u003C\u002Fem\u003E\u003Cem\u003En\u003C\u002Fem\u003E\u003Cem\u003E'\u003C\u002Fem\u003E, common complexities (ranked from good to bad) are:\u003C\u002Fp\u003E\n\n\u003Cul\u003E\n\u003Cli\u003EConstant - \u003Cstrong\u003EO(1)\u003C\u002Fstrong\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003ELogarithmic \u003Cstrong\u003EO(log n)\u003C\u002Fstrong\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003ELinear - \u003Cstrong\u003EO(n)\u003C\u002Fstrong\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003En log n - \u003Cstrong\u003EO(n log n)\u003C\u002Fstrong\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003EQuadratic - \u003Cstrong\u003EO(n¬≤)\u003C\u002Fstrong\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003EExponential - \u003Cstrong\u003EO(2‚Åø)\u003C\u002Fstrong\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003EFactorial - \u003Cstrong\u003EO(n!)\u003C\u002Fstrong\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--tB5LLmbh--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fcdn.hashnode.com\u002Fres\u002Fhashnode\u002Fimage\u002Fupload\u002Fv1610787546688\u002FSufUcCJVY.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--tB5LLmbh--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fcdn.hashnode.com\u002Fres\u002Fhashnode\u002Fimage\u002Fupload\u002Fv1610787546688\u002FSufUcCJVY.png\" alt=\"Screenshot 2021-01-16 at 2.23.08 PM.png\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EOur first algorithm runs in \u003Cem\u003EO(n)\u003C\u002Fem\u003E, meaning its operations grew in a linear relationship with the input size - in this case, the amount of numbers in the list. Our second algorithm is not dependent on the input size at all  - so it runs in constant time. \u003Cbr\u003E\nLet's take a look at how many operations a program has to execute in function with an input size of \u003Cem\u003En = 5 vs n = 50\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\n\n\u003Cdiv class=\"table-wrapper-paragraph\"\u003E\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003E\u003C\u002Fth\u003E\n\u003Cth\u003En = 5\u003C\u002Fth\u003E\n\u003Cth\u003En = 50\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E\u003Cstrong\u003EO(1)\u003C\u002Fstrong\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E1\u003C\u002Ftd\u003E\n\u003Ctd\u003E1\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E\u003Cstrong\u003EO(log n)\u003C\u002Fstrong\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E4\u003C\u002Ftd\u003E\n\u003Ctd\u003E6\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E\u003Cstrong\u003EO(n)\u003C\u002Fstrong\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E5\u003C\u002Ftd\u003E\n\u003Ctd\u003E50\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E\u003Cstrong\u003EO(n log n)\u003C\u002Fstrong\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E20\u003C\u002Ftd\u003E\n\u003Ctd\u003E300\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E\u003Cstrong\u003EO(n¬≤)\u003C\u002Fstrong\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E25\u003C\u002Ftd\u003E\n\u003Ctd\u003E2500\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E\u003Cstrong\u003EO(2‚Åø)\u003C\u002Fstrong\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E32\u003C\u002Ftd\u003E\n\u003Ctd\u003E1125899906842624\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E\u003Cstrong\u003EO(n!)\u003C\u002Fstrong\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E120\u003C\u002Ftd\u003E\n\u003Ctd\u003E3.0414093e+64\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\n\u003C\u002Ftable\u003E\u003C\u002Fdiv\u003E\n\n\u003Cp\u003EIt might not matter when the input is small, but this gap gets very dramatic as the input size increases. \u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--ZcaDmhF5--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880\u002Fhttps:\u002F\u002Fcdn.hashnode.com\u002Fres\u002Fhashnode\u002Fimage\u002Fupload\u002Fv1610788579877\u002FejJP5RkiF.gif\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--ZcaDmhF5--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880\u002Fhttps:\u002F\u002Fcdn.hashnode.com\u002Fres\u002Fhashnode\u002Fimage\u002Fupload\u002Fv1610788579877\u002FejJP5RkiF.gif\" alt=\"Screen Recording 2021-01-16 at 2.33.46 PM.gif\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EIf n were 10000, a function that runs in \u003Cem\u003Elog(n)\u003C\u002Fem\u003E would only take 14 operations and a function that runs in \u003Cem\u003En!\u003C\u002Fem\u003E would set your computer on fire!\u003C\u002Fp\u003E\n\n\u003Cp\u003EFor Big O Notation, we \u003Cem\u003Edrop constants\u003C\u002Fem\u003E so \u003Cem\u003EO(10.n)\u003C\u002Fem\u003E and \u003Cem\u003EO(n\u002F10)\u003C\u002Fem\u003E are both equivalent to \u003Cem\u003EO(n)\u003C\u002Fem\u003E because the graph is still linear. \u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--A2yYoTox--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fcdn.hashnode.com\u002Fres\u002Fhashnode\u002Fimage\u002Fupload\u002Fv1610788828910\u002FJYXeRjI-G.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--A2yYoTox--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fcdn.hashnode.com\u002Fres\u002Fhashnode\u002Fimage\u002Fupload\u002Fv1610788828910\u002FJYXeRjI-G.png\" alt=\"Screenshot 2021-01-16 at 2.47.52 PM.png\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EBig O Notation is also used for \u003Cstrong\u003Espace complexity\u003C\u002Fstrong\u003E, which works the same way - \u003Cem\u003Ehow much space an algorithm uses as n grows\u003C\u002Fem\u003E or \u003Cem\u003Erelationship between growth of input size and growth of space needed\u003C\u002Fem\u003E.\u003C\u002Fp\u003E\n\n\u003Cp\u003ESo, yeah! This has been the simplest possible explanation of the Big O Notation from my side and I hope you enjoyed reading this. If you found this information helpful, share it with your friends on different social media platforms and consider clicking those like buttons up there, it really motivates me to write more.\u003C\u002Fp\u003E\n\n\u003Cp\u003EAnd If you REALLY liked the article, consider \u003Ca href=\"https:\u002F\u002Fko-fi.com\u002Fluciferreeves\"\u003Ebuying me a coffee\u003C\u002Fa\u003E üòä. If you have any suggestions or feedback, feel free to let me know that in the comments. \u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Cstrong\u003E\u003Cem\u003EHappy Programming!\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Ftwitter.com\u002FLuciferCReeves?ref_src=twsrc%5Etfw\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--nCsPrTmG--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fimg.shields.io\u002Ftwitter\u002Ffollow\u002FLuciferCReeves%3Flabel%3DFollow%2520Me%2520on%2520Twitter%26logo%3Dtwitter%26style%3Dfor-the-badge%26labelColor%3D00acee%26logoColor%3Dfff\" alt=\"Twitter Follow\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fluciferreeves\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--DGtVk1M4--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fimg.shields.io\u002Fgithub\u002Ffollowers\u002Fluciferreeves%3Flabel%3DFollow%2520me%2520on%2520github%26logo%3Dgithub%26style%3Dfor-the-badge\" alt=\"GitHub followers\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n";b.body_markdown="*\u003Csmall\u003E‚Äî Originally published on [that computer scientist](https:\u002F\u002Fthatcomputerscientist.com\u002F). Consider following the original blog for up-to-date articles.\u003C\u002Fsmall\u003E*\n\n\u003E If you want to learn the math involved with the Big O, read  [Analysing Algorithms: Worst Case Running Time](https:\u002F\u002Fthatcomputerscientist.com\u002Fanalysing-algorithms-worst-case-running-time).\n\nData Structures and Algorithms is about solving problems efficiently. A bad programmer solves their problems inefficiently and a really bad programmer doesn't even know why their solution is inefficient. So, the question is, *How do you rank an algorithm's efficiency?*\n\nThe simple answer to that question is the **Big O Notation**. How does that work? Let me explain!\n\nSay you wrote a function which goes through every number in a list and adds it to a *total_sum* variable.\n\n![Screenshot 2021-01-16 at 2.02.19 PM.png](https:\u002F\u002Fcdn.hashnode.com\u002Fres\u002Fhashnode\u002Fimage\u002Fupload\u002Fv1610785957976\u002F1d53AER34.png)\n\nIf you consider \"addition\" to be 1 operation then running this function on a list of 10 numbers will cost 10 operations, running it on a list of 20 numbers costs 20 operations  and similarly running it on a list of n numbers costs the *length of list* (n) operations.\n\n![Screen Recording 2021-01-16 at 2.01.09 PM.gif](https:\u002F\u002Fcdn.hashnode.com\u002Fres\u002Fhashnode\u002Fimage\u002Fupload\u002Fv1610786373466\u002FWWOOmyjH9.gif)\n\nNow let's assume you wrote another function that would return the first number in a list.\n\n![Screenshot 2021-01-16 at 2.09.39 PM.png](https:\u002F\u002Fcdn.hashnode.com\u002Fres\u002Fhashnode\u002Fimage\u002Fupload\u002Fv1610786595803\u002FWcObNzV40.png)\n\nNow, no matter how large this list is, this function will never cost more than one operation. Fairly, these two algorithms have different **time complexity** or *relationship between growth of input size and growth of operations executed*. We communicate these time complexities using ***Big O Notation***.\n\n\u003E Big O Notation is a mathematical notation used to classify algorithms according to how their run time or space requirements grow as the input size grows.\n\nReferring to the complexities as *'**n**'*, common complexities (ranked from good to bad) are:\n\n- Constant - **O(1)**\n- Logarithmic **O(log n)**\n- Linear - **O(n)**\n- n log n - **O(n log n)**\n- Quadratic - **O(n¬≤)**\n- Exponential - **O(2‚Åø)**\n- Factorial - **O(n!)**\n\n![Screenshot 2021-01-16 at 2.23.08 PM.png](https:\u002F\u002Fcdn.hashnode.com\u002Fres\u002Fhashnode\u002Fimage\u002Fupload\u002Fv1610787546688\u002FSufUcCJVY.png)\n\nOur first algorithm runs in *O(n)*, meaning its operations grew in a linear relationship with the input size - in this case, the amount of numbers in the list. Our second algorithm is not dependent on the input size at all  - so it runs in constant time. \nLet's take a look at how many operations a program has to execute in function with an input size of *n = 5 vs n = 50*.\n\n|            | n = 5 | n = 50           |\n|------------|-------|------------------|\n| **O(1)**      | 1     | 1                |\n| **O(log n)**   | 4     | 6                |\n| **O(n)**       | 5     | 50               |\n| **O(n log n)** | 20    | 300              |\n| **O(n¬≤)**     | 25    | 2500             |\n| **O(2‚Åø)**      | 32    | 1125899906842624 |\n| **O(n!)**      | 120   | 3.0414093e+64    |\n\nIt might not matter when the input is small, but this gap gets very dramatic as the input size increases. \n\n![Screen Recording 2021-01-16 at 2.33.46 PM.gif](https:\u002F\u002Fcdn.hashnode.com\u002Fres\u002Fhashnode\u002Fimage\u002Fupload\u002Fv1610788579877\u002FejJP5RkiF.gif)\n\nIf n were 10000, a function that runs in *log(n)* would only take 14 operations and a function that runs in *n!* would set your computer on fire!\n\nFor Big O Notation, we *drop constants* so *O(10.n)* and *O(n\u002F10)* are both equivalent to *O(n)* because the graph is still linear. \n\n![Screenshot 2021-01-16 at 2.47.52 PM.png](https:\u002F\u002Fcdn.hashnode.com\u002Fres\u002Fhashnode\u002Fimage\u002Fupload\u002Fv1610788828910\u002FJYXeRjI-G.png)\n\nBig O Notation is also used for **space complexity**, which works the same way - *how much space an algorithm uses as n grows* or *relationship between growth of input size and growth of space needed*.\n\nSo, yeah! This has been the simplest possible explanation of the Big O Notation from my side and I hope you enjoyed reading this. If you found this information helpful, share it with your friends on different social media platforms and consider clicking those like buttons up there, it really motivates me to write more.\n\nAnd If you REALLY liked the article, consider [buying me a coffee](https:\u002F\u002Fko-fi.com\u002Fluciferreeves) üòä. If you have any suggestions or feedback, feel free to let me know that in the comments. \n\n***Happy Programming!***\n\n[![Twitter Follow](https:\u002F\u002Fimg.shields.io\u002Ftwitter\u002Ffollow\u002FLuciferCReeves?label=Follow%20Me%20on%20Twitter&logo=twitter&style=for-the-badge&labelColor=00acee&logoColor=fff)](https:\u002F\u002Ftwitter.com\u002FLuciferCReeves?ref_src=twsrc%5Etfw) [![GitHub followers](https:\u002F\u002Fimg.shields.io\u002Fgithub\u002Ffollowers\u002Fluciferreeves?label=Follow%20me%20on%20github&logo=github&style=for-the-badge)](https:\u002F\u002Fgithub.com\u002Fluciferreeves)";b.user={name:"Conrad Reeves",username:d,twitter_username:"LuciferCReeves",github_username:d,website_url:"https:\u002F\u002Fthatcomputerscientist.com\u002F",profile_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--CU4DX5xL--\u002Fc_fill,f_auto,fl_progressive,h_640,q_auto,w_640\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F373434\u002F514a0566-dfc9-49f4-8688-7bdf2d0852d4.jpeg",profile_image_90:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--kYwlLnnE--\u002Fc_fill,f_auto,fl_progressive,h_90,q_auto,w_90\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F373434\u002F514a0566-dfc9-49f4-8688-7bdf2d0852d4.jpeg"};return {data:[{}],fetch:{"data-v-25febe66:0":{article:b}},mutations:[["SET_CURRENT_ARTICLE",b]]}}("2021-01-19T09:16:53Z",{},12,"luciferreeves")));