window.__NUXT__=(function(a,b,c,d,e){return {staticAssetsBase:"\u002F_nuxt\u002Fstatic\u002F1634322943",layout:"default",error:a,state:{currentArticle:{type_of:"article",id:710961,title:"Input, output and memory for the BPU",description:"Two weeks ago I listed basic components necessary to build a simple computer. In this week's tutorial...",readable_publish_date:"Jun 4",slug:"input-output-and-memory-for-the-bpu-4kgg",path:"\u002Folus2000\u002Finput-output-and-memory-for-the-bpu-4kgg",url:c,comments_count:0,public_reactions_count:d,collection_id:12820,published_timestamp:b,positive_reactions_count:d,cover_image:a,social_image:"https:\u002F\u002Fdev.to\u002Fsocial_previews\u002Farticle\u002F710961.png",canonical_url:c,created_at:"2021-05-28T07:55:25Z",edited_at:"2021-06-07T18:15:51Z",crossposted_at:a,published_at:b,last_comment_at:b,reading_time_minutes:5,tag_list:"tutorial, esoteric, hardware",tags:["tutorial","esoteric","hardware"],body_html:"\u003Cp\u003ETwo weeks ago I listed basic components necessary to build a simple computer. In this week's tutorial I'm going to design the parts of brainfuck computer that work outside of the BPU: memory and communication with the user. Today's work will involve designing a flag circuit and learning a simple handshake protocol.\u003C\u002Fp\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"memory\" href=\"#memory\"\u003E\n  \u003C\u002Fa\u003E\n  Memory\n\u003C\u002Fh3\u003E\n\n\u003Ch6\u003E\n  \u003Ca name=\"may-contain-knowledge\" href=\"#may-contain-knowledge\"\u003E\n  \u003C\u002Fa\u003E\n  May contain knowledge\n\u003C\u002Fh6\u003E\n\n\u003Cp\u003EThis is, sans CPU, the most important part of the computer. Memory is used to store both the program which is run by the CPU and data used in computation. As a consequence, a standard RAM chip will not require too much additional hardware to work with the BPU: the BPU will be designed to communicate with memory, not vice versa.\u003C\u002Fp\u003E\n\n\u003Cp\u003EA memory chip is divided into cells which hold integer values, just like brainfuck memory. A BPU memory is connected to two buses: data bus, from which it will load and in which it will store it's contents, and address bus which selects a memory cell to interact with. To implement conditional jumps I also need a \"Zero flag\" line separate from the data bus. It will check if the currently addressed memory cell is zero even if memory isn't broadcasting its contents to the data bus.\u003C\u002Fp\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--nnEbjZIo--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F1ps7bl83hfl9oetno9pb.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--nnEbjZIo--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F1ps7bl83hfl9oetno9pb.png\" alt=\"memory module diagram\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003Cfigure\u003E\u003Cbr\u003E\u003Cfigcaption\u003EMemory module in Logisim\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\n \u003C\u002Fp\u003E\n\n\u003Cp\u003EMemory should connect to the following lines:\u003C\u002Fp\u003E\n\n\u003Cdiv class=\"table-wrapper-paragraph\"\u003E\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003EName\u003C\u002Fth\u003E\n\u003Cth\u003EType\u003C\u002Fth\u003E\n\u003Cth\u003EDescription\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EAddress bus\u003C\u002Ftd\u003E\n\u003Ctd\u003EInput\u003C\u002Ftd\u003E\n\u003Ctd\u003EUsed to address cells\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EData bus\u003C\u002Ftd\u003E\n\u003Ctd\u003EInput\u002FOutput\u003C\u002Ftd\u003E\n\u003Ctd\u003EUsed to communicate with other components\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EZero flag\u003C\u002Ftd\u003E\n\u003Ctd\u003EOutput\u003C\u002Ftd\u003E\n\u003Ctd\u003EUsed by the BPU in conditional jumps\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E\u003Ccode\u003ED-&gt;RAM\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003EControl\u003C\u002Ftd\u003E\n\u003Ctd\u003EEnables storing data from the data bus\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E\u003Ccode\u003ERAM-&gt;D\u003C\u002Fcode\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003EControl\u003C\u002Ftd\u003E\n\u003Ctd\u003EEnables loading data to the data bus\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EReset\u003C\u002Ftd\u003E\n\u003Ctd\u003EControl\u003C\u002Ftd\u003E\n\u003Ctd\u003ESets all cells to 0; connected to the computer's reset switch\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EClock\u003C\u002Ftd\u003E\n\u003Ctd\u003EClock\u003C\u002Ftd\u003E\n\u003Ctd\u003EData is stored on rising edges of the clock if enabled with D-&gt;RAM\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\n\u003C\u002Ftable\u003E\u003C\u002Fdiv\u003E\n\n\u003Ch5\u003E\n  \u003Ca name=\"zero-flag\" href=\"#zero-flag\"\u003E\n  \u003C\u002Fa\u003E\n  Zero flag\n\u003C\u002Fh5\u003E\n\n\u003Cp\u003ENote that \u003Ccode\u003ERAM-&gt;D\u003C\u002Fcode\u003E doesn't connect to \u003Ccode\u003Eld\u003C\u002Fcode\u003E input of the RAM chip which would normally be used for this purpose. Instead \u003Ccode\u003Eld\u003C\u002Fcode\u003E is permanently set to 1 so that data is always broadcasted, but bridged off from the data bus by a buffer controlled by the \u003Ccode\u003ERAM-&gt;D\u003C\u002Fcode\u003E signal. This way it is possible to check if a cell is zero without broadcasting it's contents to the data bus. The small \"=0\" circuit which calculates the flag is just a single multi-input NOR gate.\u003C\u002Fp\u003E\n\n\u003Cfigure\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--hPMCLAnN--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F47mg19xlyaphpmtfzc50.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--hPMCLAnN--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F47mg19xlyaphpmtfzc50.png\" alt=\"Zero flag diagram\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cfigcaption\u003EZero flag circuit in Logisim\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\n\n\n \n\n\u003Ch3\u003E\n  \u003Ca name=\"inputoutput-overview\" href=\"#inputoutput-overview\"\u003E\n  \u003C\u002Fa\u003E\n  Input\u002FOutput overview\n\u003C\u002Fh3\u003E\n\n\u003Ch6\u003E\n  \u003Ca name=\"talking-to-other-devices\" href=\"#talking-to-other-devices\"\u003E\n  \u003C\u002Fa\u003E\n  Talking to other devices\n\u003C\u002Fh6\u003E\n\n\u003Cp\u003EMemory is just one of many circuits that a BPU might need to communicate with, but other ones don't get separate interfaces and signals: they all share the same lines and signals and may require an additional circuit to figure out which device the BPU is trying to communicate with.\u003C\u002Fp\u003E\n\n\u003Cp\u003EFortunately I will not need such a thing because I will only implement the simplest possible I\u002FO for debugging and as an example of the handshake protocol.\u003C\u002Fp\u003E\n\n\u003Ch5\u003E\n  \u003Ca name=\"handshake\" href=\"#handshake\"\u003E\n  \u003C\u002Fa\u003E\n  Handshake\n\u003C\u002Fh5\u003E\n\n\u003Cp\u003EThe handshake is used when two devices (possibly running on different clocks so they are not synchronised) need to communicate. Except from any lines they need to send data two one-bit lines are required to perform a handshake: a \"Start\" flag controlled by the device that initialises the connection (the processor) and a \"Ready\" flag controlled by the other one (the device). The handshake proceeds as follows:\u003C\u002Fp\u003E\n\n\u003Cdiv class=\"table-wrapper-paragraph\"\u003E\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003EStart\u003C\u002Fth\u003E\n\u003Cth\u003EReady\u003C\u002Fth\u003E\n\u003Cth\u003EDescription\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E0\u003C\u002Ftd\u003E\n\u003Ctd\u003E0\u003C\u002Ftd\u003E\n\u003Ctd\u003EThe processor and the device are doing their separate things. When the processor wants to connect, it broadcasts relevant data on the data lines, sets \"Start\" to 1 and waits.\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E1\u003C\u002Ftd\u003E\n\u003Ctd\u003E0\u003C\u002Ftd\u003E\n\u003Ctd\u003EWhen the device is ready it starts processing data broadcasted on the data lines. It may take any amount of time. The processor waits, still broadcasting data and \"Start\". After the device is done processing it broadcasts the answer, sets \"Ready\" to 1 and waits.\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E1\u003C\u002Ftd\u003E\n\u003Ctd\u003E1\u003C\u002Ftd\u003E\n\u003Ctd\u003EThe device waits for the response. The processor captures data broadcasted by the device, stops broadcasting data and sets \"Start\" to 0 terminating the connection.\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E0\u003C\u002Ftd\u003E\n\u003Ctd\u003E1\u003C\u002Ftd\u003E\n\u003Ctd\u003EThe device stops broadcasting data, sets \"Ready\" to 0 and continues it's operation until another communication is requested.\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\n\u003C\u002Ftable\u003E\u003C\u002Fdiv\u003E\n\n\u003Cp\u003EThis method has many advantages: it is simple, it assumes nothing about both devices and it allows for temporary synchronisation between components that can otherwise be running on very different speeds.\u003C\u002Fp\u003E\n\n\u003Ch5\u003E\n  \u003Ca name=\"handshaking-in-the-bpu\" href=\"#handshaking-in-the-bpu\"\u003E\n  \u003C\u002Fa\u003E\n  Handshaking in the BPU\n\u003C\u002Fh5\u003E\n\n\u003Cp\u003ETwo Brainfuck Assembly Language commands are used for communication with external devices: \u003Ccode\u003E,\u003C\u002Fcode\u003E for input and \u003Ccode\u003E.\u003C\u002Fcode\u003E for output. They will perform a variant of the handshake described above.\u003C\u002Fp\u003E\n\n\u003Cp\u003EFor this purpose the BPU needs equivalents of \"Start\" and \"Ready\" signals that would also specify whether the processor requests an input or an output. I will implement this on three signal lines: \u003Ccode\u003Ein\u003C\u002Fcode\u003E for requesting input, \u003Ccode\u003Eout\u003C\u002Fcode\u003E for requesting output and \u003Ccode\u003Eresume\u003C\u002Fcode\u003E as an equivalent of the \"Ready\" signal.\u003C\u002Fp\u003E\n\n\u003Cp\u003EInput handshake:\u003C\u002Fp\u003E\n\n\u003Cdiv class=\"table-wrapper-paragraph\"\u003E\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003EHandshake element\u003C\u002Fth\u003E\n\u003Cth\u003EBPU equivalent\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EStart\u003C\u002Ftd\u003E\n\u003Ctd\u003E\n\u003Ccode\u003Ein\u003C\u002Fcode\u003E signal\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EReady\u003C\u002Ftd\u003E\n\u003Ctd\u003E\n\u003Ccode\u003Eresume\u003C\u002Fcode\u003E signal\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EData for the device\u003C\u002Ftd\u003E\n\u003Ctd\u003E\n\u003Ccode\u003E,\u003C\u002Fcode\u003E command argument\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EData from the device\u003C\u002Ftd\u003E\n\u003Ctd\u003Esent over the data bus\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\n\u003C\u002Ftable\u003E\u003C\u002Fdiv\u003E\n\n\u003Cp\u003EOutput handshake:\u003C\u002Fp\u003E\n\n\u003Cdiv class=\"table-wrapper-paragraph\"\u003E\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003EHandshake element\u003C\u002Fth\u003E\n\u003Cth\u003EBPU equivalent\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EStart\u003C\u002Ftd\u003E\n\u003Ctd\u003E\n\u003Ccode\u003Eout\u003C\u002Fcode\u003E signal\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EReady\u003C\u002Ftd\u003E\n\u003Ctd\u003E\n\u003Ccode\u003Eresume\u003C\u002Fcode\u003E signal\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EData for the device\u003C\u002Ftd\u003E\n\u003Ctd\u003E\n\u003Ccode\u003E.\u003C\u002Fcode\u003E command argument and contents of the data bus\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EData from the device\u003C\u002Ftd\u003E\n\u003Ctd\u003Enone\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\n\u003C\u002Ftable\u003E\u003C\u002Fdiv\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"inputoutput-design\" href=\"#inputoutput-design\"\u003E\n  \u003C\u002Fa\u003E\n  Input\u002FOutput design\n\u003C\u002Fh3\u003E\n\n\u003Ch6\u003E\n  \u003Ca name=\"insert-your-implementation-here\" href=\"#insert-your-implementation-here\"\u003E\n  \u003C\u002Fa\u003E\n  [Insert your implementation here]\n\u003C\u002Fh6\u003E\n\n\u003Cp\u003EWith knowledge about the handshake protocol and what signals will be used to perform it I can now design a simple manual input and a simple output display. Because I'm using only a single input and output I will not be using command arguments.\u003C\u002Fp\u003E\n\n\u003Ch5\u003E\n  \u003Ca name=\"input\" href=\"#input\"\u003E\n  \u003C\u002Fa\u003E\n  Input\n\u003C\u002Fh5\u003E\n\n\u003Cp\u003EManual input is a really simple circuit. Almost nothing is automated so it is as straightforward as can be:\u003C\u002Fp\u003E\n\n\u003Cfigure\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--GenYqOQX--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F572z0sn8ev6pml3hux1g.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--GenYqOQX--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F572z0sn8ev6pml3hux1g.png\" alt=\"input diagram\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cfigcaption\u003EManual BPU input in Logisim\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\n\n\n\n\u003Cp\u003EWhen the \u003Ccode\u003Ein\u003C\u002Fcode\u003E signal is on, the LED lights up to notify the user and input is broadcasted to the data bus. Pressing the button will send a \u003Ccode\u003Eresume\u003C\u002Fcode\u003E signal and continue the program.\u003C\u002Fp\u003E\n\n\u003Ch5\u003E\n  \u003Ca name=\"output\" href=\"#output\"\u003E\n  \u003C\u002Fa\u003E\n  Output\n\u003C\u002Fh5\u003E\n\n\u003Cp\u003EOutput display is not as easy. It requires a register to store the output value and it should also work independently of the user. Therefore it needs to implement automatic handshaking: something that emits a \"Ready\" signal after receiving the \u003Ccode\u003Ein\u003C\u002Fcode\u003E signal and storing data, and takes it down when the \u003Ccode\u003Ein\u003C\u002Fcode\u003E signal ends.\u003C\u002Fp\u003E\n\n\u003Cp\u003EFortunately both are still quite simple to set up. The data register is just a standard register with its \"enable\" input connected to the \u003Ccode\u003Ein\u003C\u002Fcode\u003E signal so it only loads data when it's supposed to. The handshake can be performed by a one-byte register (AKA D-flip-flop): it will pass on the \u003Ccode\u003Ein\u003C\u002Fcode\u003E signal as a \u003Ccode\u003Eresume\u003C\u002Fcode\u003E signal but synchronised with the module's clock* and will be reset asynchronously when \u003Ccode\u003Ein\u003C\u002Fcode\u003E goes down.\u003C\u002Fp\u003E\n\n\u003Cfigure\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--852PUD1k--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fd6e37nnqr7bh0bnjx7gq.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--852PUD1k--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fd6e37nnqr7bh0bnjx7gq.png\" alt=\"output diagram\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cfigcaption\u003EHex output circuit diagram in Logisim\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\n\n\n\n\u003Cp\u003EOutputs are set up for connection with Logisim's hex displays, so from the outside the whole setup looks like this:\u003C\u002Fp\u003E\n\n\u003Cfigure\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs---aj1BsPz--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fermsni2qyjor8ktt7456.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs---aj1BsPz--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fermsni2qyjor8ktt7456.png\" alt=\"output block in use\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cfigcaption\u003EHex output module in use\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\n\n\n\n\u003Cp\u003E*In my final simulation everything will run on the same clock, but  I want to design BPU to be able to communicate with devices with different speeds.\u003C\u002Fp\u003E\n\n\u003Ch3\u003E\n  \u003Ca name=\"conclusion\" href=\"#conclusion\"\u003E\n  \u003C\u002Fa\u003E\n  Conclusion\n\u003C\u002Fh3\u003E\n\n\u003Ch6\u003E\n  \u003Ca name=\"thats-all-folks\" href=\"#thats-all-folks\"\u003E\n  \u003C\u002Fa\u003E\n  That's all, folks!\n\u003C\u002Fh6\u003E\n\n\u003Cp\u003EThis week I've shown you the handshake protocol for communication between devices of different speeds. I also designed the external parts needed to operate the BPU. Next week I'll begin designing the BPU itself starting from some core registers.\u003C\u002Fp\u003E\n\n",body_markdown:"Two weeks ago I listed basic components necessary to build a simple computer. In this week's tutorial I'm going to design the parts of brainfuck computer that work outside of the BPU: memory and communication with the user. Today's work will involve designing a flag circuit and learning a simple handshake protocol.\n\n### Memory\n###### May contain knowledge\n \nThis is, sans CPU, the most important part of the computer. Memory is used to store both the program which is run by the CPU and data used in computation. As a consequence, a standard RAM chip will not require too much additional hardware to work with the BPU: the BPU will be designed to communicate with memory, not vice versa.\n\nA memory chip is divided into cells which hold integer values, just like brainfuck memory. A BPU memory is connected to two buses: data bus, from which it will load and in which it will store it's contents, and address bus which selects a memory cell to interact with. To implement conditional jumps I also need a \"Zero flag\" line separate from the data bus. It will check if the currently addressed memory cell is zero even if memory isn't broadcasting its contents to the data bus.\n\n![memory module diagram](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F1ps7bl83hfl9oetno9pb.png)\n \u003Cfigcaption\u003EMemory module in Logisim\u003C\u002Ffigcaption\u003E\n \n\nMemory should connect to the following lines:\n\n| Name | Type | Description |\n| --- | --- | --- |\n| Address bus | Input | Used to address cells |\n| Data bus | Input\u002FOutput | Used to communicate with other components |\n| Zero flag | Output | Used by the BPU in conditional jumps |\n| `D-\u003ERAM` | Control | Enables storing data from the data bus |\n| `RAM-\u003ED` | Control | Enables loading data to the data bus |\n| Reset | Control | Sets all cells to 0; connected to the computer's reset switch |\n| Clock | Clock | Data is stored on rising edges of the clock if enabled with D-\u003ERAM |\n\n##### Zero flag\nNote that `RAM-\u003ED` doesn't connect to `ld` input of the RAM chip which would normally be used for this purpose. Instead `ld` is permanently set to 1 so that data is always broadcasted, but bridged off from the data bus by a buffer controlled by the `RAM-\u003ED` signal. This way it is possible to check if a cell is zero without broadcasting it's contents to the data bus. The small \"=0\" circuit which calculates the flag is just a single multi-input NOR gate.\n\n![Zero flag diagram](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F47mg19xlyaphpmtfzc50.png)\n\u003Cfigcaption\u003EZero flag circuit in Logisim\u003C\u002Ffigcaption\u003E\n \n### Input\u002FOutput overview\n###### Talking to other devices\nMemory is just one of many circuits that a BPU might need to communicate with, but other ones don't get separate interfaces and signals: they all share the same lines and signals and may require an additional circuit to figure out which device the BPU is trying to communicate with.\n\nFortunately I will not need such a thing because I will only implement the simplest possible I\u002FO for debugging and as an example of the handshake protocol.\n\n##### Handshake\nThe handshake is used when two devices (possibly running on different clocks so they are not synchronised) need to communicate. Except from any lines they need to send data two one-bit lines are required to perform a handshake: a \"Start\" flag controlled by the device that initialises the connection (the processor) and a \"Ready\" flag controlled by the other one (the device). The handshake proceeds as follows:\n\n| Start | Ready | Description |\n| --- | --- | --- |\n| 0 | 0 | The processor and the device are doing their separate things. When the processor wants to connect, it broadcasts relevant data on the data lines, sets \"Start\" to 1 and waits. |\n| 1 | 0 | When the device is ready it starts processing data broadcasted on the data lines. It may take any amount of time. The processor waits, still broadcasting data and \"Start\". After the device is done processing it broadcasts the answer, sets \"Ready\" to 1 and waits. |\n| 1 | 1 | The device waits for the response. The processor captures data broadcasted by the device, stops broadcasting data and sets \"Start\" to 0 terminating the connection. |\n| 0 | 1 | The device stops broadcasting data, sets \"Ready\" to 0 and continues it's operation until another communication is requested. |\n\nThis method has many advantages: it is simple, it assumes nothing about both devices and it allows for temporary synchronisation between components that can otherwise be running on very different speeds.\n\n##### Handshaking in the BPU\nTwo Brainfuck Assembly Language commands are used for communication with external devices: `,` for input and `.` for output. They will perform a variant of the handshake described above.\n\nFor this purpose the BPU needs equivalents of \"Start\" and \"Ready\" signals that would also specify whether the processor requests an input or an output. I will implement this on three signal lines: `in` for requesting input, `out` for requesting output and `resume` as an equivalent of the \"Ready\" signal.\n\nInput handshake:\n\n| Handshake element | BPU equivalent |\n| --- | --- |\n| Start | `in` signal |\n| Ready | `resume` signal |\n| Data for the device | `,` command argument |\n| Data from the device | sent over the data bus |\n\nOutput handshake:\n\n| Handshake element | BPU equivalent |\n| --- | --- |\n| Start | `out` signal |\n| Ready | `resume` signal |\n| Data for the device | `.` command argument and contents of the data bus |\n| Data from the device | none |\n\n### Input\u002FOutput design\n###### [Insert your implementation here]\nWith knowledge about the handshake protocol and what signals will be used to perform it I can now design a simple manual input and a simple output display. Because I'm using only a single input and output I will not be using command arguments.\n\n##### Input\nManual input is a really simple circuit. Almost nothing is automated so it is as straightforward as can be:\n\n![input diagram](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002F572z0sn8ev6pml3hux1g.png)\n\u003Cfigcaption\u003EManual BPU input in Logisim\u003C\u002Ffigcaption\u003E\n\nWhen the `in` signal is on, the LED lights up to notify the user and input is broadcasted to the data bus. Pressing the button will send a `resume` signal and continue the program.\n\n##### Output\nOutput display is not as easy. It requires a register to store the output value and it should also work independently of the user. Therefore it needs to implement automatic handshaking: something that emits a \"Ready\" signal after receiving the `in` signal and storing data, and takes it down when the `in` signal ends.\n\nFortunately both are still quite simple to set up. The data register is just a standard register with its \"enable\" input connected to the `in` signal so it only loads data when it's supposed to. The handshake can be performed by a one-byte register (AKA D-flip-flop): it will pass on the `in` signal as a `resume` signal but synchronised with the module's clock* and will be reset asynchronously when `in` goes down.\n\n![output diagram](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fd6e37nnqr7bh0bnjx7gq.png)\n\u003Cfigcaption\u003EHex output circuit diagram in Logisim\u003C\u002Ffigcaption\u003E\n\nOutputs are set up for connection with Logisim's hex displays, so from the outside the whole setup looks like this:\n\n![output block in use](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fermsni2qyjor8ktt7456.png)\n\u003Cfigcaption\u003EHex output module in use\u003C\u002Ffigcaption\u003E\n\n*In my final simulation everything will run on the same clock, but  I want to design BPU to be able to communicate with devices with different speeds.\n\n### Conclusion\n###### That's all, folks!\nThis week I've shown you the handshake protocol for communication between devices of different speeds. I also designed the external parts needed to operate the BPU. Next week I'll begin designing the BPU itself starting from some core registers.\n",user:{name:"Alex Esoposting",username:e,twitter_username:a,github_username:e,website_url:a,profile_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--3eWw6cjS--\u002Fc_fill,f_auto,fl_progressive,h_640,q_auto,w_640\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F627763\u002F3318a5a4-c71a-46c6-92b4-54f8203e41f8.png",profile_image_90:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--CRlN1LEZ--\u002Fc_fill,f_auto,fl_progressive,h_90,q_auto,w_90\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F627763\u002F3318a5a4-c71a-46c6-92b4-54f8203e41f8.png"}}},serverRendered:true,routePath:"\u002Farticles\u002Folus2000\u002F710961",config:{_app:{basePath:"\u002F",assetsPath:"\u002F_nuxt\u002F",cdnURL:a}}}}(null,"2021-06-04T10:54:58Z","https:\u002F\u002Fdev.to\u002Folus2000\u002Finput-output-and-memory-for-the-bpu-4kgg",6,"olus2000"));