window.__NUXT__=(function(a,b,c,d){return {staticAssetsBase:"\u002F_nuxt\u002Fstatic\u002F1634322943",layout:"default",error:a,state:{currentArticle:{type_of:"article",id:651465,title:"Build your own YouTube mp3 downloader ...",description:"Introduction :   Hello everyone,                 Recently I had the opportunity to work on a...",readable_publish_date:"Mar 31",slug:"build-your-own-youtube-mp3-downloader-1gnh",path:"\u002Framgopalsrikar\u002Fbuild-your-own-youtube-mp3-downloader-1gnh",url:c,comments_count:0,public_reactions_count:d,collection_id:a,published_timestamp:b,positive_reactions_count:d,cover_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--aPKsFe8X--\u002Fc_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fg4cp9cdrw4sq1wbm4yzj.jpeg",social_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--J70rlRUd--\u002Fc_imagga_scale,f_auto,fl_progressive,h_500,q_auto,w_1000\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fg4cp9cdrw4sq1wbm4yzj.jpeg",canonical_url:c,created_at:b,edited_at:"2021-04-05T20:31:56Z",crossposted_at:a,published_at:b,last_comment_at:b,reading_time_minutes:4,tag_list:"aws, serverless, restapi",tags:["aws","serverless","restapi"],body_html:"\u003Ch2\u003E\n  \u003Ca name=\"introduction-\" href=\"#introduction-\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  Introduction :\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EHello everyone,\u003Cbr\u003E\n                Recently I had the opportunity to work on a music application, where I have developed a REST API to download the audio file given a video ID of the source youtube video. In this blog, I will be covering my experience while building the project like common pitfalls, design decisions I had to undergo while working on the project and maximum performance I could achieve given the constraint so let's dive into the project.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"youtubedl-opensource-library-\" href=\"#youtubedl-opensource-library-\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  Youtube_dl open-source library :\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EThe initial challenge while working on downloading content from youtube, is to find an open-source library, fortunately, I found a library called \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fytdl-org\u002Fyoutube-dl\"\u003Eyoutube-dl open-source library\u003C\u002Fa\u003E from GitHub. After going through the library and experimenting with python SDK I was comfortable working with the library, the interesting part is the SDK gives an option to download the directly best quality mp3 file makes its execution locally easy and not demanding much attention, problems araised when I tried to implement in the cloud.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"lambda-and-its-limitation-\" href=\"#lambda-and-its-limitation-\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  Lambda and its limitation :\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EAs my code started working locally I packaged my lambda function file and its dependent libraries into a zip file and uploaded it into lambda configured with python environment and tried to download the file into the temporary repository in lambda. To my surprise, the lambda function produced an error which is due to the fact that mp4 to mp3 conversion requires FFmpeg which is Linux kernel depended, unfortunately, we don't have access to the operating system of lambda so it was like a dead-end for conversion, but later I got to know about lambda layers and we could initialize a layer on top of the function with FFmpeg library, it was a great way to get introduced to lambda layers and I have implemented it.\u003C\u002Fp\u003E\n\n\u003Cp\u003EThe lambda function started running and given the appropriate output, but the heavy load of downloading a file and later converting it into mp3 has been pushing the limits of lambda, especially when given a large video file, making the implementation not much reliable and also due to limitation of the size of tmp repository to 512Mb handling a video larger than it lead to errors. To overcome these limitations I have decided the following steps:\u003C\u002Fp\u003E\n\n\u003Col\u003E\n\u003Cli\u003EIt's time to Decouple everything\u003C\u002Fli\u003E\n\u003Cli\u003EAvoiding lambda \u002Ftmp repository\u003C\u002Fli\u003E\n\u003Cli\u003EElastic transcoder to the rescue!\u003C\u002Fli\u003E\n\u003Cli\u003EWhat does my architecture now look like?\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"1-its-time-to-decouple-everything\" href=\"#1-its-time-to-decouple-everything\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  1. It's time to Decouple everything\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003ESince discussed above the computing and storage limitations of lambda, I tried to break the process into multiple small processes hence decoupling the application. The first small process would be handling the API gateway request and revert back the response of the s3-presigned URL if the file present or else send file is processing. Allocating the lambda function just to handle API gateway requests helps us satisfy the criteria to send a response within 29 seconds a request being made from API gateway or else it produces an error message, Adding any additional load on lambda can hinder the time constraints at hand. \u003C\u002Fp\u003E\n\n\u003Cp\u003ESo the functionality handled by lambda is to check if the requested file is processed or not from dynamoDB and send a response based on the status of the file being processed.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"2-avoiding-lambda-tmp-repository\" href=\"#2-avoiding-lambda-tmp-repository\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  2. Avoiding lambda \u002Ftmp repository\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EThe way youtube-dl works is, initially it downloads the mp4 file to the path location mentioned in its sdk, where once the file download is completed it starts processing audio conversion, here we try to decouple the processes as discussed above, where we create one lambda function for transcoding and other lambda function for downloading, since we are using 2 different lambda function it doesn't make sense to download directly to \u002Ftmp repository instead, we need to figure out a way to divert the incoming data to another more elastic storage which in our case is S3.\u003C\u002Fp\u003E\n\n\u003Cp\u003Ethere are few implementations I found using node js, popular ones were from the source cloudonaut.io named \u003Ca href=\"https:\u002F\u002Fcloudonaut.io\u002Fdownload-youtube-videos-with-aws-lambda-and-store-them-on-s3\u002F\"\u003EDownload youtube videos using lambda and store them in s3\u003C\u002Fa\u003E but since many of the implementations found were on node js, it made it difficult to implement in python, anyways from stack overflow i could be able to establish establish the dedicated connection, the code of the python version could be found in my github repository under \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FRamGopalSrikar\u002Fmp3-youtube-download\u002Fblob\u002Fmaster\u002Fyoutube-downloader\u002Flambda_function.py\"\u003Eyoutube downloader lambda function\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"3-elastic-transcoder-to-the-rescue\" href=\"#3-elastic-transcoder-to-the-rescue\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  3. Elastic transcoder to the rescue!\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003EPerforming transcoding of media files from mp4 to the desired quality of mp3 puts a strain on lambda especially for long media files, especially in our case where we are planning to perform transcoding of media files of length 4 hours, hence using AWS service elastic transcoder comes to rescue!.\u003C\u002Fp\u003E\n\n\u003Cp\u003EWhile configuring elastic transcoder, we usually set up a data pipeline with source and target S3 buckets while selecting presetID as \"1351620000001-300010\" which is 320kpbs audio quality. once, everything is configured writing lambda function for passing the s3 mp4 objects into the pipeline and make sure the lambda function gets triggered by the S3 event notification for .mp4 format. \u003C\u002Fp\u003E\n\n\u003Cp\u003EThe above operation makes sure that the transcoding operation is performed immediately after the mp4 file is uploaded to s3  Next, we need to initialize another lambda function which performs operations such as updating data in dynamodb, deleting mp4 file that was generated to activate this lambda function we use similar s3 event notification but, instead we trigger for .mp3 file format being uploaded.\u003C\u002Fp\u003E\n\n\u003Ch2\u003E\n  \u003Ca name=\"4-what-does-my-architecture-now-look-like\" href=\"#4-what-does-my-architecture-now-look-like\" class=\"anchor\"\u003E\n  \u003C\u002Fa\u003E\n  4. What does my architecture now look like?\n\u003C\u002Fh2\u003E\n\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--IABl-IHX--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fbnlinsajrplg224nqjx2.png\" class=\"article-body-image-wrapper\"\u003E\u003Cimg src=\"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--IABl-IHX--\u002Fc_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fbnlinsajrplg224nqjx2.png\" alt=\"Screenshot 2021-03-27 at 6.26.36 PM\" loading=\"lazy\"\u003E\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\n\u003Cp\u003EThe \u003Ca href=\"https:\u002F\u002Fgithub.com\u002FRamGopalSrikar\u002Fmp3-youtube-download\"\u003Egithub code\u003C\u002Fa\u003E consist of source code for 4 lambda functions we used, soon ill be updating a cloud formation template making it easy to deploy.\u003C\u002Fp\u003E\n\n",body_markdown:"## Introduction :\n\nHello everyone,\n                Recently I had the opportunity to work on a music application, where I have developed a REST API to download the audio file given a video ID of the source youtube video. In this blog, I will be covering my experience while building the project like common pitfalls, design decisions I had to undergo while working on the project and maximum performance I could achieve given the constraint so let's dive into the project.\n\n## Youtube_dl open-source library :\n\nThe initial challenge while working on downloading content from youtube, is to find an open-source library, fortunately, I found a library called [youtube-dl open-source library] (https:\u002F\u002Fgithub.com\u002Fytdl-org\u002Fyoutube-dl) from GitHub. After going through the library and experimenting with python SDK I was comfortable working with the library, the interesting part is the SDK gives an option to download the directly best quality mp3 file makes its execution locally easy and not demanding much attention, problems araised when I tried to implement in the cloud.\n\n## Lambda and its limitation :\n\nAs my code started working locally I packaged my lambda function file and its dependent libraries into a zip file and uploaded it into lambda configured with python environment and tried to download the file into the temporary repository in lambda. To my surprise, the lambda function produced an error which is due to the fact that mp4 to mp3 conversion requires FFmpeg which is Linux kernel depended, unfortunately, we don't have access to the operating system of lambda so it was like a dead-end for conversion, but later I got to know about lambda layers and we could initialize a layer on top of the function with FFmpeg library, it was a great way to get introduced to lambda layers and I have implemented it.\n \nThe lambda function started running and given the appropriate output, but the heavy load of downloading a file and later converting it into mp3 has been pushing the limits of lambda, especially when given a large video file, making the implementation not much reliable and also due to limitation of the size of tmp repository to 512Mb handling a video larger than it lead to errors. To overcome these limitations I have decided the following steps:\n\n1. It's time to Decouple everything\n2. Avoiding lambda \u002Ftmp repository\n3. Elastic transcoder to the rescue!\n4. What does my architecture now look like?\n\n## 1. It's time to Decouple everything\n\nSince discussed above the computing and storage limitations of lambda, I tried to break the process into multiple small processes hence decoupling the application. The first small process would be handling the API gateway request and revert back the response of the s3-presigned URL if the file present or else send file is processing. Allocating the lambda function just to handle API gateway requests helps us satisfy the criteria to send a response within 29 seconds a request being made from API gateway or else it produces an error message, Adding any additional load on lambda can hinder the time constraints at hand. \n\nSo the functionality handled by lambda is to check if the requested file is processed or not from dynamoDB and send a response based on the status of the file being processed.\n\n## 2. Avoiding lambda \u002Ftmp repository\n\nThe way youtube-dl works is, initially it downloads the mp4 file to the path location mentioned in its sdk, where once the file download is completed it starts processing audio conversion, here we try to decouple the processes as discussed above, where we create one lambda function for transcoding and other lambda function for downloading, since we are using 2 different lambda function it doesn't make sense to download directly to \u002Ftmp repository instead, we need to figure out a way to divert the incoming data to another more elastic storage which in our case is S3.\n\nthere are few implementations I found using node js, popular ones were from the source cloudonaut.io named [Download youtube videos using lambda and store them in s3](https:\u002F\u002Fcloudonaut.io\u002Fdownload-youtube-videos-with-aws-lambda-and-store-them-on-s3\u002F) but since many of the implementations found were on node js, it made it difficult to implement in python, anyways from stack overflow i could be able to establish establish the dedicated connection, the code of the python version could be found in my github repository under [youtube downloader lambda function](https:\u002F\u002Fgithub.com\u002FRamGopalSrikar\u002Fmp3-youtube-download\u002Fblob\u002Fmaster\u002Fyoutube-downloader\u002Flambda_function.py).\n\n## 3. Elastic transcoder to the rescue!\n\nPerforming transcoding of media files from mp4 to the desired quality of mp3 puts a strain on lambda especially for long media files, especially in our case where we are planning to perform transcoding of media files of length 4 hours, hence using AWS service elastic transcoder comes to rescue!.\n \nWhile configuring elastic transcoder, we usually set up a data pipeline with source and target S3 buckets while selecting presetID as \"1351620000001-300010\" which is 320kpbs audio quality. once, everything is configured writing lambda function for passing the s3 mp4 objects into the pipeline and make sure the lambda function gets triggered by the S3 event notification for .mp4 format. \n\nThe above operation makes sure that the transcoding operation is performed immediately after the mp4 file is uploaded to s3  Next, we need to initialize another lambda function which performs operations such as updating data in dynamodb, deleting mp4 file that was generated to activate this lambda function we use similar s3 event notification but, instead we trigger for .mp3 file format being uploaded.\n\n\n## 4. What does my architecture now look like?\n\n\n![Screenshot 2021-03-27 at 6.26.36 PM](https:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Farticles\u002Fbnlinsajrplg224nqjx2.png)\n \n\nThe [github code](https:\u002F\u002Fgithub.com\u002FRamGopalSrikar\u002Fmp3-youtube-download) consist of source code for 4 lambda functions we used, soon ill be updating a cloud formation template making it easy to deploy.\n\n\n\n\n\n\n",user:{name:"Ram Gopal Srikar Katakam",username:"ramgopalsrikar",twitter_username:a,github_username:"RamGopalSrikar",website_url:a,profile_image:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--6Pnbqr4y--\u002Fc_fill,f_auto,fl_progressive,h_640,q_auto,w_640\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F604679\u002F18fb0804-5244-42b2-98f4-fbd4c10f6662.jpeg",profile_image_90:"https:\u002F\u002Fres.cloudinary.com\u002Fpracticaldev\u002Fimage\u002Ffetch\u002Fs--Jeo5XZo5--\u002Fc_fill,f_auto,fl_progressive,h_90,q_auto,w_90\u002Fhttps:\u002F\u002Fdev-to-uploads.s3.amazonaws.com\u002Fuploads\u002Fuser\u002Fprofile_image\u002F604679\u002F18fb0804-5244-42b2-98f4-fbd4c10f6662.jpeg"}}},serverRendered:true,routePath:"\u002Farticles\u002Framgopalsrikar\u002F651465",config:{_app:{basePath:"\u002F",assetsPath:"\u002F_nuxt\u002F",cdnURL:a}}}}(null,"2021-03-31T20:59:12Z","https:\u002F\u002Fdev.to\u002Framgopalsrikar\u002Fbuild-your-own-youtube-mp3-downloader-1gnh",14));